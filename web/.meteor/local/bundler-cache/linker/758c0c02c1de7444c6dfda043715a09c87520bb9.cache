[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nDate = Package['es5-shim'].Date;\nparseInt = Package['es5-shim'].parseInt;\nReact = Package['react-runtime'].React;\nReactDOM = Package['react-runtime'].ReactDOM;\nReactDOMServer = Package['react-runtime'].ReactDOMServer;\nReactMeteorData = Package['react-meteor-data'].ReactMeteorData;\nBlazeToReact = Package['thereactivestack:blazetoreact'].BlazeToReact;\nReactRouterSSR = Package['reactrouter:react-router-ssr'].ReactRouterSSR;\nReactHelmet = Package['nfl:react-helmet'].ReactHelmet;\nHTTP = Package.http.HTTP;\nHTTPInternals = Package.http.HTTPInternals;\nAsync = Package['meteorhacks:async'].Async;\nMeteor = Package.meteor.Meteor;\nWebApp = Package.webapp.WebApp;\nmain = Package.webapp.main;\nWebAppInternals = Package.webapp.WebAppInternals;\n_ = Package.underscore._;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nSymbol = Package['ecmascript-runtime'].Symbol;\nMap = Package['ecmascript-runtime'].Map;\nSet = Package['ecmascript-runtime'].Set;\nPromise = Package.promise.Promise;\nReactRouter = Package['reactrouter:react-router'].ReactRouter;\nAutoupdate = Package.autoupdate.Autoupdate;\n\n","servePath":"/packages/global-imports.js"},{"type":"js","data":"(function(){\n\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// server.js                                                           //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n                                                                       //\nglobal.require = Npm.require;                                          //\nglobal.React = require('react');                                       // 1\nif (typeof global.jQuery === 'undefined') { global.jQuery = {}; }      // 2\nWebpackStats = null;                                                   // 3\n/******/ (function(modules) { // webpackBootstrap                      // 4\n/******/ \t// The module cache                                          // 5\n/******/ \tvar installedModules = {};                                   // 6\n                                                                       // 7\n/******/ \t// The require function                                      // 8\n/******/ \tfunction __webpack_require__(moduleId) {                     // 9\n                                                                       // 10\n/******/ \t\t// Check if module is in cache                              // 11\n/******/ \t\tif(installedModules[moduleId])                              // 12\n/******/ \t\t\treturn installedModules[moduleId].exports;                 // 13\n                                                                       // 14\n/******/ \t\t// Create a new module (and put it into the cache)          // 15\n/******/ \t\tvar module = installedModules[moduleId] = {                 // 16\n/******/ \t\t\texports: {},                                               // 17\n/******/ \t\t\tid: moduleId,                                              // 18\n/******/ \t\t\tloaded: false                                              // 19\n/******/ \t\t};                                                          // 20\n                                                                       // 21\n/******/ \t\t// Execute the module function                              // 22\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n                                                                       // 24\n/******/ \t\t// Flag the module as loaded                                // 25\n/******/ \t\tmodule.loaded = true;                                       // 26\n                                                                       // 27\n/******/ \t\t// Return the exports of the module                         // 28\n/******/ \t\treturn module.exports;                                      // 29\n/******/ \t}                                                            // 30\n                                                                       // 31\n                                                                       // 32\n/******/ \t// expose the modules object (__webpack_modules__)           // 33\n/******/ \t__webpack_require__.m = modules;                             // 34\n                                                                       // 35\n/******/ \t// expose the module cache                                   // 36\n/******/ \t__webpack_require__.c = installedModules;                    // 37\n                                                                       // 38\n/******/ \t// __webpack_public_path__                                   // 39\n/******/ \t__webpack_require__.p = \"http://localhost:3500/assets/\";     //\n                                                                       //\n/******/ \t// Load entry module and return exports                      //\n/******/ \treturn __webpack_require__(0);                               //\n/******/ })                                                            //\n/************************************************************************/\n/******/ ([                                                            // 1\n/* 0 */                                                                // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\tvar _reactrouterReactRouterSsr = __webpack_require__(1);              // 7\n                                                                       // 8\n\t__webpack_require__(2);                                               // 9\n                                                                       // 10\n\t// Do server-rendering only in production                             // 11\n\t// Otherwise, it will break the hot-reload                            // 12\n\t// DO NOT REMOVE THIS LINE TO TEST, use: meteor --production          // 13\n\tif (false) {                                                          // 14\n\t  // Load Webpack infos for SSR                                       // 15\n\t  _reactrouterReactRouterSsr.ReactRouterSSR.LoadWebpackStats(WebpackStats);\n                                                                       //\n\t  require('./routes').default;                                        //\n\t}                                                                     //\n                                                                       //\n/***/ },                                                               //\n/* 1 */                                                                //\n/***/ function(module, exports) {                                      //\n                                                                       //\n\tmodule.exports = Package['reactrouter:react-router-ssr'];             //\n                                                                       //\n/***/ },                                                               // 1\n/* 2 */                                                                // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       //\n\t__webpack_require__(3);                                               //\n                                                                       //\n\t__webpack_require__(4);                                               //\n                                                                       //\n/***/ },                                                               // 1\n/* 3 */                                                                // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       //\n\t\"use strict\";                                                         //\n                                                                       //\n\tglobal.__dirname = process.env[\"PWD\"];                                //\n                                                                       //\n/***/ },                                                               // 1\n/* 4 */                                                                // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\tvar _meteor = __webpack_require__(5);                                 // 7\n                                                                       // 8\n\tvar _layout = __webpack_require__(6);                                 // 9\n                                                                       // 10\n\tvar _layout2 = _interopRequireDefault(_layout);                       // 11\n                                                                       // 12\n\tvar _wordnet = __webpack_require__(40);                               // 13\n                                                                       // 14\n\tvar _wordnet2 = _interopRequireDefault(_wordnet);                     // 15\n                                                                       // 16\n\tvar _ngraph = __webpack_require__(10);                                // 17\n                                                                       // 18\n\tvar _ngraph2 = _interopRequireDefault(_ngraph);                       // 19\n                                                                       // 20\n\tvar _ngraph3 = __webpack_require__(46);                               // 21\n                                                                       // 22\n\tvar _ngraph4 = _interopRequireDefault(_ngraph3);                      // 23\n                                                                       // 24\n\tvar _ngraph5 = __webpack_require__(47);                               // 25\n                                                                       // 26\n\tvar _ngraph6 = _interopRequireDefault(_ngraph5);                      // 27\n                                                                       // 28\n\tvar _ngraph7 = __webpack_require__(48);                               // 29\n                                                                       // 30\n\tvar _ngraph8 = _interopRequireDefault(_ngraph7);                      // 31\n                                                                       // 32\n\tvar _ngraph9 = __webpack_require__(49);                               // 33\n                                                                       // 34\n\tvar _ngraph10 = _interopRequireDefault(_ngraph9);                     // 35\n                                                                       // 36\n\tvar _ngraph11 = __webpack_require__(51);                              // 37\n                                                                       // 38\n\tvar _ngraph12 = _interopRequireDefault(_ngraph11);                    // 39\n                                                                       // 40\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n                                                                       // 42\n\tvar wordnet = new _wordnet2.default(process.cwd() + '/../web.browser/app/dict');\n                                                                       // 44\n\tvar graph = null;                                                     // 45\n                                                                       // 46\n\t_meteor.Meteor.methods({                                              // 47\n\t  // calculate the layout of the graph before serving it to the client\n\t  calculateLayout: function calculateLayout() {                       // 49\n                                                                       // 50\n\t    // if the graph hasn't been created                               // 51\n\t    // load the data set                                              // 52\n\t    if (!graph) {                                                     // 53\n\t      HTTP.get(_meteor.Meteor.absoluteUrl('/generated.json'), function (err, result) {\n\t        // if we don't have an er                                     // 55\n\t        if (!err && result.data) {                                    // 56\n\t          (function () {                                              // 57\n\t            var data = result.data;                                   // 58\n\t            // call the load function w/ graph data in json,          // 59\n\t            var graph = load(data,                                    // 60\n\t            // function that returns object w/ id and info_dict[word] from python,\n\t            function (node) {                                         // 62\n\t              return {                                                // 63\n\t                id: node[\"id\"],                                       // 64\n\t                data: {                                               // 65\n\t                  definition: node['definition'],                     // 66\n\t                  pos: node['pos'],                                   // 67\n\t                  sense_n: node['sense_n']                            // 68\n\t                }                                                     // 69\n\t              };                                                      // 70\n\t            },                                                        // 71\n\t            // function that links two nodes                          // 72\n\t            function (link) {                                         // 73\n\t              return {                                                // 74\n\t                fromId: data.nodes[link.source].id,                   // 75\n\t                toId: data.nodes[link.target].id                      // 76\n\t              };                                                      // 77\n\t            });                                                       // 78\n                                                                       // 79\n\t            graphCallback(graph, true);                               // 80\n\t          })();                                                       // 81\n\t        }                                                             // 82\n\t      });                                                             // 83\n\t    } else {                                                          // 84\n\t      graphCallback(graph, false);                                    // 85\n\t    }                                                                 // 86\n                                                                       // 87\n\t    // pass the graph that was created in ngraph                      // 88\n\t    // we don't want to overwrite the previous iterations             // 89\n\t    function graphCallback(graph, overwrite) {                        // 90\n\t      // create instance of ngraph.graph w/ chinese whispers graph clustering algorithm\n\t      //var whisper = createWhisper(graph);                           // 92\n\t      //var requiredChangeRate = 0; // 0 is complete convergence      // 93\n\t      ////                                                            // 94\n\t      //while (whisper.getChangeRate() > requiredChangeRate) {        // 95\n\t      //  whisper.step();                                             // 96\n\t      //}                                                             // 97\n\t      //let coarseGraph = coarsen(graph, whisper);                    // 98\n\t      //let index = 0;                                                // 99\n\t      //coarseGraph.forEachNode(function(node) {                      // 100\n\t      //  node.data.forEach(function(id) {                            // 101\n\t      //    coarseGraph.addNode(id, {hidden: true, data: graph.getNode(id).data});\n\t      //    coarseGraph.addLink(node.id, id);                         // 103\n\t      //    index++;                                                  // 104\n\t      //  });                                                         // 105\n\t      //});                                                           // 106\n                                                                       // 107\n\t      //var clusters = whisper.createClusterMap();                    // 108\n\t      //// removeLinks for removing links in the graph                // 109\n\t      //var removedLinks = [];                                        // 110\n\t      //                                                              // 111\n\t      //// use forEach to remove links and cluster                    // 112\n\t      //clusters.forEach(visitCluster);                               // 113\n\t      //                                                              // 114\n\t      //function visitCluster(clusterNodes, clusterClass) {           // 115\n\t      //  var i;                                                      // 116\n\t      //  for (i = 0; i < clusterNodes.length; ++i) {                 // 117\n\t      //    let node = graph.getNode(clusterNodes[i]);                // 118\n\t      //    graph.addNode(node.id, {cluster: clusterClass, info: node.data});\n\t      //  }                                                           // 120\n\t      //                                                              // 121\n\t      //  for (i = 0; i < clusterNodes.length; ++i) {                 // 122\n\t      //    let node = graph.getNode(clusterNodes[i]);                // 123\n\t      //    graph.forEachLinkedNode(node.id,                          // 124\n\t      //      function(linkedNode, link) {                            // 125\n\t      //        // if the clusters are not the same                   // 126\n\t      //        // we remove the link from the graph                  // 127\n\t      //        if (linkedNode.data.cluster != node.data.cluster) {   // 128\n\t      //          graph.removeLink(link);                             // 129\n\t      //          removedLinks.push(link);                            // 130\n\t      //        }                                                     // 131\n\t      //      },                                                      // 132\n\t      //      true                                                    // 133\n\t      //    );                                                        // 134\n\t      //  }                                                           // 135\n\t      //}                                                             // 136\n\t      //                                                              // 137\n\t      //let removedThisIteration;                                     // 138\n\t      //while (!removedThisIteration || removedThisIteration.length > 0) {\n\t      //  removedThisIteration = [];                                  // 140\n\t      //  graph.forEachLink(function(link) {                          // 141\n\t      //    if (!link) return;                                        // 142\n\t      //    let from = graph.getNode(link.fromId);                    // 143\n\t      //    let to = graph.getNode(link.toId);                        // 144\n\t      //    if (from.data.cluster !== to.data.cluster) {              // 145\n\t      //      graph.removeLink(link);                                 // 146\n\t      //      removedThisIteration.push(link);                        // 147\n\t      //    }                                                         // 148\n\t      //  });                                                         // 149\n\t      //  for (var i = 0; i < removedThisIteration.length; ++i) {     // 150\n\t      //    removedLinks.push(removedThisIteration[i]);               // 151\n\t      //  }                                                           // 152\n\t      //}                                                             // 153\n\t      //// print each connection in the graph w/o being in the same cluster\n\t      //graph.forEachLink(function(link) {                            // 155\n\t      //  let from = graph.getNode(link.fromId);                      // 156\n\t      //  let to = graph.getNode(link.toId);                          // 157\n\t      //  if (from.data.cluster !== to.data.cluster) {                // 158\n\t      //    console.log({from: from.data.cluster, to: to.data.cluster});\n\t      //  }                                                           // 160\n\t      //});                                                           // 161\n\t      //                                                              // 162\n\t      //console.log(removedLinks.length);                             // 163\n                                                                       // 164\n\t      //var path = kruskal(graph);                                    // 165\n\t      //let tree = createGraph();                                     // 166\n\t      //graph.forEachNode(function(node) {                            // 167\n\t      //  tree.addNode(node.id, node.data);                           // 168\n\t      //});                                                           // 169\n\t      //for (var i = 0; i < path.length; ++i) {                       // 170\n\t      //  let edge = path[i];                                         // 171\n\t      //  tree.addLink(edge.fromId, edge.toId);                       // 172\n\t      //}                                                             // 173\n                                                                       // 174\n\t      var layout = (0, _layout2.default)(graph, {                     // 175\n\t        iterations: 50,                                               // 176\n\t        saveEach: 25                                                  // 177\n\t      });                                                             // 178\n\t      layout.run(true);                                               // 179\n\t    }                                                                 // 180\n\t  },                                                                  // 181\n\t  findSynsets: function findSynsets(word) {                           // 182\n\t    var response = Async.runSync(function (done) {                    // 183\n\t      wordnet.lookup(word, function (results) {                       // 184\n\t        // if there are no results                                    // 185\n\t        if (results.length === 0) {                                   // 186\n\t          // render message saying no words were found for 'word'     // 187\n\t          done(null, null);                                           // 188\n\t        }                                                             // 189\n\t        // console.log(JSON.stringify(results, null, '\\t'));          // 190\n\t        var synsets = [];                                             // 191\n\t        for (var i = 0; i < results.length; i++) {                    // 192\n\t          var synset = results[i];                                    // 193\n\t          // console.log(synset.lemma, synset.pos);                   // 194\n\t          synsets.push({                                              // 195\n\t            name: synset.lemma,                                       // 196\n\t            definition: synset.def,                                   // 197\n\t            synonyms: synset.synonyms,                                // 198\n\t            pos: synset.pos                                           // 199\n\t          });                                                         // 200\n\t        }                                                             // 201\n\t        done(null, synsets);                                          // 202\n\t      });                                                             // 203\n\t    });                                                               // 204\n\t    return response.result;                                           // 205\n\t  }                                                                   // 206\n\t});                                                                   // 207\n                                                                       // 208\n\t// jsonGraph is the file created in python                            // 209\n\t// nodeTransform is a function that operates                          // 210\n\t// linkTransform                                                      // 211\n\tfunction load(jsonGraph, nodeTransform, linkTransform) {              // 212\n\t  // stored used to store jsonGraph                                   // 213\n\t  var stored;                                                         // 214\n\t  nodeTransform = nodeTransform || id;                                // 215\n\t  linkTransform = linkTransform || id;                                // 216\n\t  // either parse the json string to a json object                    // 217\n\t  if (typeof jsonGraph === 'string') {                                // 218\n\t    stored = JSON.parse(jsonGraph);                                   // 219\n\t  } else {                                                            // 220\n\t    stored = jsonGraph;                                               // 221\n\t  }                                                                   // 222\n                                                                       // 223\n\t  // create an empty ngraph.graph                                     // 224\n\t  var graph = (0, _ngraph4.default)(),                                // 225\n\t      i;                                                              // 226\n                                                                       // 227\n\t  if (stored.links === undefined || stored.nodes === undefined) {     // 228\n\t    throw new Error('Cannot load graph without links and nodes');     // 229\n\t  }                                                                   // 230\n                                                                       // 231\n\t  for (i = 0; i < stored.nodes.length; ++i) {                         // 232\n\t    // apply nodeTranform to each node                                // 233\n\t    // ex: set to {id: node[\"id\"], data: node['data']};               // 234\n\t    var parsedNode = nodeTransform(stored.nodes[i]);                  // 235\n\t    if (!parsedNode.hasOwnProperty('id')) {                           // 236\n\t      throw new Error('Graph node format is invalid: Node id is missing');\n\t    }                                                                 // 238\n\t    // add the node w/ id and parsedNode                              // 239\n\t    graph.addNode(parsedNode.id, parsedNode.data);                    // 240\n\t  }                                                                   // 241\n                                                                       // 242\n\t  for (i = 0; i < stored.links.length; ++i) {                         // 243\n\t    // apply linkTransform to each link                               // 244\n\t    // ex: return fromId, toId for the two nodes                      // 245\n\t    var link = linkTransform(stored.links[i]);                        // 246\n\t    if (!link.hasOwnProperty('fromId') || !link.hasOwnProperty('toId')) {\n\t      throw new Error('Graph link format is invalid. Both fromId and toId are required');\n\t    }                                                                 // 249\n                                                                       // 250\n\t    graph.addLink(link.fromId, link.toId, link.data);                 // 251\n\t  }                                                                   //\n                                                                       //\n\t  return graph;                                                       //\n\t}                                                                     //\n                                                                       //\n/***/ },                                                               //\n/* 5 */                                                                //\n/***/ function(module, exports) {                                      //\n                                                                       //\n\tmodule.exports = Package['meteor'];                                   //\n                                                                       //\n/***/ },                                                               // 1\n/* 6 */                                                                // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\tObject.defineProperty(exports, \"__esModule\", {                        // 7\n\t  value: true                                                         // 8\n\t});                                                                   // 9\n\texports.default = createLayout;                                       // 10\n                                                                       // 11\n\tvar _path = __webpack_require__(7);                                   // 12\n                                                                       // 13\n\tvar _path2 = _interopRequireDefault(_path);                           // 14\n                                                                       // 15\n\tvar _fs = __webpack_require__(8);                                     // 16\n                                                                       // 17\n\tvar _fs2 = _interopRequireDefault(_fs);                               // 18\n                                                                       // 19\n\tvar _mkdirp = __webpack_require__(9);                                 // 20\n                                                                       // 21\n\tvar _mkdirp2 = _interopRequireDefault(_mkdirp);                       // 22\n                                                                       // 23\n\tvar _ngraph = __webpack_require__(10);                                // 24\n                                                                       // 25\n\tvar _ngraph2 = _interopRequireDefault(_ngraph);                       // 26\n                                                                       // 27\n\tvar _ngraph3 = __webpack_require__(37);                               // 28\n                                                                       // 29\n\tvar _ngraph4 = _interopRequireDefault(_ngraph3);                      // 30\n                                                                       // 31\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n                                                                       // 33\n\tfunction createLayout(graph, options) {                               // 34\n\t  options = options || {};                                            // 35\n\t  var iterations = typeof options.iterations === 'number' ? options.iterations : 500;\n\t  var saveEach = typeof options.saveEach === 'number' ? options.saveEach : 5;\n\t  var is2d = options.is2d ? true : false;                             // 38\n\t  var coordinatesPerRecord = is2d ? 2 : 3;                            // 39\n\t  var intSize = 4;                                                    // 40\n\t  var layouter = is2d ? _ngraph2.default.get2dLayout : _ngraph2.default;\n\t  var layout = layouter(graph, options.physicsSettings);              // 42\n\t  var outDir = process.env[\"PWD\"] + \"/public/data\";                   // 43\n                                                                       // 44\n\t  if (!_fs2.default.existsSync(outDir)) {                             // 45\n\t    _mkdirp2.default.sync(outDir);                                    // 46\n\t  }                                                                   // 47\n\t  var lastIteration = getLastIteration(outDir);                       // 48\n                                                                       // 49\n\t  return {                                                            // 50\n\t    run: run,                                                         // 51\n\t    lastIteration: getLastIteration                                   // 52\n\t  };                                                                  // 53\n                                                                       // 54\n\t  function getLastIteration() {                                       // 55\n\t    var files = _fs2.default.readdirSync(outDir);                     // 56\n\t    var largest = 0;                                                  // 57\n\t    for (var i = 0; i < files.length; ++i) {                          // 58\n\t      var match = files[i].match(/^(\\d+)\\.bin$/i);                    // 59\n\t      if (!match) continue;                                           // 60\n\t      var iterationNumber = parseInt(match[1], 10);                   // 61\n\t      if (iterationNumber > largest) largest = iterationNumber;       // 62\n\t    }                                                                 // 63\n\t    return largest;                                                   // 64\n\t  }                                                                   // 65\n                                                                       // 66\n\t  function run(overwrite) {                                           // 67\n\t    if (overwrite) {                                                  // 68\n\t      lastIteration = 0;                                              // 69\n\t    } else {                                                          // 70\n\t      if (lastIteration >= iterations) {                              // 71\n\t        printLastIterationHelp();                                     // 72\n\t        return;                                                       // 73\n\t      } else if (lastIteration > 0) {                                 // 74\n\t        initLayout(lastIteration);                                    // 75\n\t      }                                                               // 76\n\t    }                                                                 // 77\n                                                                       // 78\n\t    for (var step = lastIteration + 1; step < iterations; ++step) {   // 79\n\t      console.log('Step ' + step);                                    // 80\n\t      layout.step();                                                  // 81\n\t      if (step % saveEach === 0) {                                    // 82\n\t        saveIteration(step);                                          // 83\n\t      }                                                               // 84\n\t    }                                                                 // 85\n\t    saveIteration('positions');                                       // 86\n\t  }                                                                   // 87\n                                                                       // 88\n\t  function initLayout(iteration) {                                    // 89\n\t    var lastName = _path2.default.join(outDir, iteration + '.bin');   // 90\n\t    console.log('Attempting to resume layout from ' + lastName);      // 91\n\t    var buf = _fs2.default.readFileSync(lastName);                    // 92\n\t    var idx = 0;                                                      // 93\n\t    graph.forEachNode(initPosition);                                  // 94\n                                                                       // 95\n\t    function initPosition(node) {                                     // 96\n\t      var x = buf.readInt32LE(idx);                                   // 97\n\t      var y = buf.readInt32LE(idx + 4);                               // 98\n\t      if (is2d) {                                                     // 99\n\t        layout.setNodePosition(node.id, x, y);                        // 100\n\t        idx += 8;                                                     // 101\n\t      } else {                                                        // 102\n\t        var z = buf.readInt32LE(idx + 8);                             // 103\n\t        layout.setNodePosition(node.id, x, y, z);                     // 104\n\t        idx += 12;                                                    // 105\n\t      }                                                               // 106\n\t    }                                                                 // 107\n\t  }                                                                   // 108\n                                                                       // 109\n\t  function printLastIterationHelp() {                                 // 110\n\t    console.log('The ' + outDir + ' already has ' + lastIteration + ' saved iterations.');\n\t    console.log('* If you want to overwite existing work call `layout.run(true)`');\n\t    console.log('* If you want to perform more iterations set higher value for `options.iterations`');\n\t  }                                                                   // 114\n                                                                       // 115\n\t  function saveIteration(name) {                                      // 116\n\t    var fname = _path2.default.join(outDir, name + '.bin');           // 117\n                                                                       // 118\n\t    console.log(\"Saving: \", fname);                                   // 119\n\t    var nodesLength = graph.getNodesCount();                          // 120\n\t    var buf = new Buffer(nodesLength * intSize * coordinatesPerRecord);\n\t    var i = 0;                                                        // 122\n                                                                       // 123\n\t    graph.forEachNode(saveNode);                                      // 124\n                                                                       // 125\n\t    _fs2.default.writeFileSync(fname, buf);                           // 126\n                                                                       // 127\n\t    (0, _ngraph4.default)(graph, {                                    // 128\n\t      outDir: outDir                                                  // 129\n\t    });                                                               // 130\n                                                                       // 131\n\t    function saveNode(node) {                                         // 132\n\t      var idx = i * intSize * coordinatesPerRecord;                   // 133\n\t      var pos = layout.getNodePosition(node.id);                      // 134\n\t      buf.writeInt32LE(Math.ceil(pos.x), idx);                        // 135\n\t      buf.writeInt32LE(Math.ceil(pos.y), idx + 4);                    // 136\n\t      if (!is2d) {                                                    // 137\n\t        buf.writeInt32LE(Math.ceil(pos.z), idx + 8);                  // 138\n\t      }                                                               // 139\n\t      i++;                                                            // 140\n\t    }                                                                 //\n\t  }                                                                   //\n\t}                                                                     //\n\tmodule.exports = exports['default'];                                  //\n                                                                       //\n/***/ },                                                               //\n/* 7 */                                                                //\n/***/ function(module, exports) {                                      //\n                                                                       //\n\tmodule.exports = require(\"path\");                                     //\n                                                                       //\n/***/ },                                                               //\n/* 8 */                                                                //\n/***/ function(module, exports) {                                      //\n                                                                       //\n\tmodule.exports = require(\"fs\");                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 9 */                                                                // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar path = __webpack_require__(7);                                    // 5\n\tvar fs = __webpack_require__(8);                                      // 6\n\tvar _0777 = parseInt('0777', 8);                                      // 7\n                                                                       // 8\n\tmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;              // 9\n                                                                       // 10\n\tfunction mkdirP (p, opts, f, made) {                                  // 11\n\t    if (typeof opts === 'function') {                                 // 12\n\t        f = opts;                                                     // 13\n\t        opts = {};                                                    // 14\n\t    }                                                                 // 15\n\t    else if (!opts || typeof opts !== 'object') {                     // 16\n\t        opts = { mode: opts };                                        // 17\n\t    }                                                                 // 18\n\t                                                                      // 19\n\t    var mode = opts.mode;                                             // 20\n\t    var xfs = opts.fs || fs;                                          // 21\n\t                                                                      // 22\n\t    if (mode === undefined) {                                         // 23\n\t        mode = _0777 & (~process.umask());                            // 24\n\t    }                                                                 // 25\n\t    if (!made) made = null;                                           // 26\n\t                                                                      // 27\n\t    var cb = f || function () {};                                     // 28\n\t    p = path.resolve(p);                                              // 29\n\t                                                                      // 30\n\t    xfs.mkdir(p, mode, function (er) {                                // 31\n\t        if (!er) {                                                    // 32\n\t            made = made || p;                                         // 33\n\t            return cb(null, made);                                    // 34\n\t        }                                                             // 35\n\t        switch (er.code) {                                            // 36\n\t            case 'ENOENT':                                            // 37\n\t                mkdirP(path.dirname(p), opts, function (er, made) {   // 38\n\t                    if (er) cb(er, made);                             // 39\n\t                    else mkdirP(p, opts, cb, made);                   // 40\n\t                });                                                   // 41\n\t                break;                                                // 42\n                                                                       // 43\n\t            // In the case of any other error, just see if there's a dir\n\t            // there already.  If so, then hooray!  If not, then something\n\t            // is borked.                                             // 46\n\t            default:                                                  // 47\n\t                xfs.stat(p, function (er2, stat) {                    // 48\n\t                    // if the stat fails, then that's super weird.    // 49\n\t                    // let the original error be the failure reason.  // 50\n\t                    if (er2 || !stat.isDirectory()) cb(er, made)      // 51\n\t                    else cb(null, made);                              // 52\n\t                });                                                   // 53\n\t                break;                                                // 54\n\t        }                                                             // 55\n\t    });                                                               // 56\n\t}                                                                     // 57\n                                                                       // 58\n\tmkdirP.sync = function sync (p, opts, made) {                         // 59\n\t    if (!opts || typeof opts !== 'object') {                          // 60\n\t        opts = { mode: opts };                                        // 61\n\t    }                                                                 // 62\n\t                                                                      // 63\n\t    var mode = opts.mode;                                             // 64\n\t    var xfs = opts.fs || fs;                                          // 65\n\t                                                                      // 66\n\t    if (mode === undefined) {                                         // 67\n\t        mode = _0777 & (~process.umask());                            // 68\n\t    }                                                                 // 69\n\t    if (!made) made = null;                                           // 70\n                                                                       // 71\n\t    p = path.resolve(p);                                              // 72\n                                                                       // 73\n\t    try {                                                             // 74\n\t        xfs.mkdirSync(p, mode);                                       // 75\n\t        made = made || p;                                             // 76\n\t    }                                                                 // 77\n\t    catch (err0) {                                                    // 78\n\t        switch (err0.code) {                                          // 79\n\t            case 'ENOENT' :                                           // 80\n\t                made = sync(path.dirname(p), opts, made);             // 81\n\t                sync(p, opts, made);                                  // 82\n\t                break;                                                // 83\n                                                                       // 84\n\t            // In the case of any other error, just see if there's a dir\n\t            // there already.  If so, then hooray!  If not, then something\n\t            // is borked.                                             // 87\n\t            default:                                                  // 88\n\t                var stat;                                             // 89\n\t                try {                                                 // 90\n\t                    stat = xfs.statSync(p);                           // 91\n\t                }                                                     // 92\n\t                catch (err1) {                                        // 93\n\t                    throw err0;                                       // 94\n\t                }                                                     // 95\n\t                if (!stat.isDirectory()) throw err0;                  // 96\n\t                break;                                                // 97\n\t        }                                                             // 98\n\t    }                                                                 //\n                                                                       //\n\t    return made;                                                      //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 10 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * This module provides all required forces to regular ngraph.physics.simulator\n\t * to make it 3D simulator. Ideally ngraph.physics.simulator should operate\n\t * with vectors, but on practices that showed performance decrease... Maybe\n\t * I was doing it wrong, will see if I can refactor/throw away this module.\n\t */                                                                   // 10\n\tmodule.exports = createLayout;                                        // 11\n\tcreateLayout.get2dLayout = __webpack_require__(11);                   // 12\n                                                                       // 13\n\tfunction createLayout(graph, physicsSettings) {                       // 14\n\t  var merge = __webpack_require__(15);                                // 15\n\t  physicsSettings = merge(physicsSettings, {                          // 16\n\t        createQuadTree: __webpack_require__(28),                      // 17\n\t        createBounds: __webpack_require__(32),                        // 18\n\t        createDragForce: __webpack_require__(33),                     // 19\n\t        createSpringForce: __webpack_require__(34),                   // 20\n\t        integrator: __webpack_require__(35),                          // 21\n\t        createBody: __webpack_require__(36)                           // 22\n\t      });                                                             //\n                                                                       //\n\t  return createLayout.get2dLayout(graph, physicsSettings);            //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 11 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tmodule.exports = createLayout;                                        // 5\n\tmodule.exports.simulator = __webpack_require__(12);                   // 6\n                                                                       // 7\n\tvar eventify = __webpack_require__(16);                               // 8\n                                                                       // 9\n\t/**                                                                   // 10\n\t * Creates force based layout for a given graph.                      // 11\n\t * @param {ngraph.graph} graph which needs to be laid out             // 12\n\t * @param {object} physicsSettings if you need custom settings        // 13\n\t * for physics simulator you can pass your own settings here. If it's not passed\n\t * a default one will be created.                                     // 15\n\t */                                                                   // 16\n\tfunction createLayout(graph, physicsSettings) {                       // 17\n\t  if (!graph) {                                                       // 18\n\t    throw new Error('Graph structure cannot be undefined');           // 19\n\t  }                                                                   // 20\n                                                                       // 21\n\t  var createSimulator = __webpack_require__(12);                      // 22\n\t  var physicsSimulator = createSimulator(physicsSettings);            // 23\n                                                                       // 24\n\t  var nodeBodies = typeof Object.create === 'function' ? Object.create(null) : {};\n\t  var springs = {};                                                   // 26\n                                                                       // 27\n\t  var springTransform = physicsSimulator.settings.springTransform || noop;\n                                                                       // 29\n\t  // Initialize physical objects according to what we have in the graph:\n\t  initPhysics();                                                      // 31\n\t  listenToEvents();                                                   // 32\n                                                                       // 33\n\t  var api = {                                                         // 34\n\t    /**                                                               // 35\n\t     * Performs one step of iterative layout algorithm                // 36\n\t     */                                                               // 37\n\t    step: function() {                                                // 38\n\t      return physicsSimulator.step();                                 // 39\n\t    },                                                                // 40\n                                                                       // 41\n\t    /**                                                               // 42\n\t     * For a given `nodeId` returns position                          // 43\n\t     */                                                               // 44\n\t    getNodePosition: function (nodeId) {                              // 45\n\t      return getInitializedBody(nodeId).pos;                          // 46\n\t    },                                                                // 47\n                                                                       // 48\n\t    /**                                                               // 49\n\t     * Sets position of a node to a given coordinates                 // 50\n\t     * @param {string} nodeId node identifier                         // 51\n\t     * @param {number} x position of a node                           // 52\n\t     * @param {number} y position of a node                           // 53\n\t     * @param {number=} z position of node (only if applicable to body)\n\t     */                                                               // 55\n\t    setNodePosition: function (nodeId) {                              // 56\n\t      var body = getInitializedBody(nodeId);                          // 57\n\t      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n\t    },                                                                // 59\n                                                                       // 60\n\t    /**                                                               // 61\n\t     * @returns {Object} Link position by link id                     // 62\n\t     * @returns {Object.from} {x, y} coordinates of link start        // 63\n\t     * @returns {Object.to} {x, y} coordinates of link end            // 64\n\t     */                                                               // 65\n\t    getLinkPosition: function (linkId) {                              // 66\n\t      var spring = springs[linkId];                                   // 67\n\t      if (spring) {                                                   // 68\n\t        return {                                                      // 69\n\t          from: spring.from.pos,                                      // 70\n\t          to: spring.to.pos                                           // 71\n\t        };                                                            // 72\n\t      }                                                               // 73\n\t    },                                                                // 74\n                                                                       // 75\n\t    /**                                                               // 76\n\t     * @returns {Object} area required to fit in the graph. Object contains\n\t     * `x1`, `y1` - top left coordinates                              // 78\n\t     * `x2`, `y2` - bottom right coordinates                          // 79\n\t     */                                                               // 80\n\t    getGraphRect: function () {                                       // 81\n\t      return physicsSimulator.getBBox();                              // 82\n\t    },                                                                // 83\n                                                                       // 84\n\t    /*                                                                // 85\n\t     * Requests layout algorithm to pin/unpin node to its current position\n\t     * Pinned nodes should not be affected by layout algorithm and always\n\t     * remain at their position                                       // 88\n\t     */                                                               // 89\n\t    pinNode: function (node, isPinned) {                              // 90\n\t      var body = getInitializedBody(node.id);                         // 91\n\t       body.isPinned = !!isPinned;                                    // 92\n\t    },                                                                // 93\n                                                                       // 94\n\t    /**                                                               // 95\n\t     * Checks whether given graph's node is currently pinned          // 96\n\t     */                                                               // 97\n\t    isNodePinned: function (node) {                                   // 98\n\t      return getInitializedBody(node.id).isPinned;                    // 99\n\t    },                                                                // 100\n                                                                       // 101\n\t    /**                                                               // 102\n\t     * Request to release all resources                               // 103\n\t     */                                                               // 104\n\t    dispose: function() {                                             // 105\n\t      graph.off('changed', onGraphChanged);                           // 106\n\t      physicsSimulator.off('stable', onStableChanged);                // 107\n\t    },                                                                // 108\n                                                                       // 109\n\t    /**                                                               // 110\n\t     * Gets physical body for a given node id. If node is not found undefined\n\t     * value is returned.                                             // 112\n\t     */                                                               // 113\n\t    getBody: getBody,                                                 // 114\n                                                                       // 115\n\t    /**                                                               // 116\n\t     * Gets spring for a given edge.                                  // 117\n\t     *                                                                // 118\n\t     * @param {string} linkId link identifer. If two arguments are passed then\n\t     * this argument is treated as formNodeId                         // 120\n\t     * @param {string=} toId when defined this parameter denotes head of the link\n\t     * and first argument is trated as tail of the link (fromId)      // 122\n\t     */                                                               // 123\n\t    getSpring: getSpring,                                             // 124\n                                                                       // 125\n\t    /**                                                               // 126\n\t     * [Read only] Gets current physics simulator                     // 127\n\t     */                                                               // 128\n\t    simulator: physicsSimulator                                       // 129\n\t  };                                                                  // 130\n                                                                       // 131\n\t  eventify(api);                                                      // 132\n\t  return api;                                                         // 133\n                                                                       // 134\n\t  function getSpring(fromId, toId) {                                  // 135\n\t    var linkId;                                                       // 136\n\t    if (toId === undefined) {                                         // 137\n\t      if (typeof fromId !== 'object') {                               // 138\n\t        // assume fromId as a linkId:                                 // 139\n\t        linkId = fromId;                                              // 140\n\t      } else {                                                        // 141\n\t        // assume fromId to be a link object:                         // 142\n\t        linkId = fromId.id;                                           // 143\n\t      }                                                               // 144\n\t    } else {                                                          // 145\n\t      // toId is defined, should grab link:                           // 146\n\t      var link = graph.hasLink(fromId, toId);                         // 147\n\t      if (!link) return;                                              // 148\n\t      linkId = link.id;                                               // 149\n\t    }                                                                 // 150\n                                                                       // 151\n\t    return springs[linkId];                                           // 152\n\t  }                                                                   // 153\n                                                                       // 154\n\t  function getBody(nodeId) {                                          // 155\n\t    return nodeBodies[nodeId];                                        // 156\n\t  }                                                                   // 157\n                                                                       // 158\n\t  function listenToEvents() {                                         // 159\n\t    graph.on('changed', onGraphChanged);                              // 160\n\t    physicsSimulator.on('stable', onStableChanged);                   // 161\n\t  }                                                                   // 162\n                                                                       // 163\n\t  function onStableChanged(isStable) {                                // 164\n\t    api.fire('stable', isStable);                                     // 165\n\t  }                                                                   // 166\n                                                                       // 167\n\t  function onGraphChanged(changes) {                                  // 168\n\t    for (var i = 0; i < changes.length; ++i) {                        // 169\n\t      var change = changes[i];                                        // 170\n\t      if (change.changeType === 'add') {                              // 171\n\t        if (change.node) {                                            // 172\n\t          initBody(change.node.id);                                   // 173\n\t        }                                                             // 174\n\t        if (change.link) {                                            // 175\n\t          initLink(change.link);                                      // 176\n\t        }                                                             // 177\n\t      } else if (change.changeType === 'remove') {                    // 178\n\t        if (change.node) {                                            // 179\n\t          releaseNode(change.node);                                   // 180\n\t        }                                                             // 181\n\t        if (change.link) {                                            // 182\n\t          releaseLink(change.link);                                   // 183\n\t        }                                                             // 184\n\t      }                                                               // 185\n\t    }                                                                 // 186\n\t  }                                                                   // 187\n                                                                       // 188\n\t  function initPhysics() {                                            // 189\n\t    graph.forEachNode(function (node) {                               // 190\n\t      initBody(node.id);                                              // 191\n\t    });                                                               // 192\n\t    graph.forEachLink(initLink);                                      // 193\n\t  }                                                                   // 194\n                                                                       // 195\n\t  function initBody(nodeId) {                                         // 196\n\t    var body = nodeBodies[nodeId];                                    // 197\n\t    if (!body) {                                                      // 198\n\t      var node = graph.getNode(nodeId);                               // 199\n\t      if (!node) {                                                    // 200\n\t        throw new Error('initBody() was called with unknown node id');\n\t      }                                                               // 202\n                                                                       // 203\n\t      var pos = node.position;                                        // 204\n\t      if (!pos) {                                                     // 205\n\t        var neighbors = getNeighborBodies(node);                      // 206\n\t        pos = physicsSimulator.getBestNewBodyPosition(neighbors);     // 207\n\t      }                                                               // 208\n                                                                       // 209\n\t      body = physicsSimulator.addBodyAt(pos);                         // 210\n                                                                       // 211\n\t      nodeBodies[nodeId] = body;                                      // 212\n\t      updateBodyMass(nodeId);                                         // 213\n                                                                       // 214\n\t      if (isNodeOriginallyPinned(node)) {                             // 215\n\t        body.isPinned = true;                                         // 216\n\t      }                                                               // 217\n\t    }                                                                 // 218\n\t  }                                                                   // 219\n                                                                       // 220\n\t  function releaseNode(node) {                                        // 221\n\t    var nodeId = node.id;                                             // 222\n\t    var body = nodeBodies[nodeId];                                    // 223\n\t    if (body) {                                                       // 224\n\t      nodeBodies[nodeId] = null;                                      // 225\n\t      delete nodeBodies[nodeId];                                      // 226\n                                                                       // 227\n\t      physicsSimulator.removeBody(body);                              // 228\n\t    }                                                                 // 229\n\t  }                                                                   // 230\n                                                                       // 231\n\t  function initLink(link) {                                           // 232\n\t    updateBodyMass(link.fromId);                                      // 233\n\t    updateBodyMass(link.toId);                                        // 234\n                                                                       // 235\n\t    var fromBody = nodeBodies[link.fromId],                           // 236\n\t        toBody  = nodeBodies[link.toId],                              // 237\n\t        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n                                                                       // 239\n\t    springTransform(link, spring);                                    // 240\n                                                                       // 241\n\t    springs[link.id] = spring;                                        // 242\n\t  }                                                                   // 243\n                                                                       // 244\n\t  function releaseLink(link) {                                        // 245\n\t    var spring = springs[link.id];                                    // 246\n\t    if (spring) {                                                     // 247\n\t      var from = graph.getNode(link.fromId),                          // 248\n\t          to = graph.getNode(link.toId);                              // 249\n                                                                       // 250\n\t      if (from) updateBodyMass(from.id);                              // 251\n\t      if (to) updateBodyMass(to.id);                                  // 252\n                                                                       // 253\n\t      delete springs[link.id];                                        // 254\n                                                                       // 255\n\t      physicsSimulator.removeSpring(spring);                          // 256\n\t    }                                                                 // 257\n\t  }                                                                   // 258\n                                                                       // 259\n\t  function getNeighborBodies(node) {                                  // 260\n\t    // TODO: Could probably be done better on memory                  // 261\n\t    var neighbors = [];                                               // 262\n\t    if (!node.links) {                                                // 263\n\t      return neighbors;                                               // 264\n\t    }                                                                 // 265\n\t    var maxNeighbors = Math.min(node.links.length, 2);                // 266\n\t    for (var i = 0; i < maxNeighbors; ++i) {                          // 267\n\t      var link = node.links[i];                                       // 268\n\t      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n\t      if (otherBody && otherBody.pos) {                               // 270\n\t        neighbors.push(otherBody);                                    // 271\n\t      }                                                               // 272\n\t    }                                                                 // 273\n                                                                       // 274\n\t    return neighbors;                                                 // 275\n\t  }                                                                   // 276\n                                                                       // 277\n\t  function updateBodyMass(nodeId) {                                   // 278\n\t    var body = nodeBodies[nodeId];                                    // 279\n\t    body.mass = nodeMass(nodeId);                                     // 280\n\t  }                                                                   // 281\n                                                                       // 282\n\t  /**                                                                 // 283\n\t   * Checks whether graph node has in its settings pinned attribute,  // 284\n\t   * which means layout algorithm cannot move it. Node can be preconfigured\n\t   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n\t   *                                                                  // 287\n\t   * @param {Object} node a graph node to check                       // 288\n\t   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n\t   */                                                                 // 290\n\t  function isNodeOriginallyPinned(node) {                             // 291\n\t    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n\t  }                                                                   // 293\n                                                                       // 294\n\t  function getInitializedBody(nodeId) {                               // 295\n\t    var body = nodeBodies[nodeId];                                    // 296\n\t    if (!body) {                                                      // 297\n\t      initBody(nodeId);                                               // 298\n\t      body = nodeBodies[nodeId];                                      // 299\n\t    }                                                                 // 300\n\t    return body;                                                      // 301\n\t  }                                                                   // 302\n                                                                       // 303\n\t  /**                                                                 // 304\n\t   * Calculates mass of a body, which corresponds to node with given id.\n\t   *                                                                  // 306\n\t   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n\t   * @returns {Number} recommended mass of the body;                  // 308\n\t   */                                                                 // 309\n\t  function nodeMass(nodeId) {                                         // 310\n\t    var links = graph.getLinks(nodeId);                               // 311\n\t    if (!links) return 1;                                             // 312\n\t    return 1 + links.length / 3.0;                                    // 313\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n\tfunction noop() { }                                                   //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 12 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Manages a simulation of physical forces acting on bodies and springs.\n\t */                                                                   // 7\n\tmodule.exports = physicsSimulator;                                    // 8\n                                                                       // 9\n\tfunction physicsSimulator(settings) {                                 // 10\n\t  var Spring = __webpack_require__(13);                               // 11\n\t  var expose = __webpack_require__(14);                               // 12\n\t  var merge = __webpack_require__(15);                                // 13\n\t  var eventify = __webpack_require__(16);                             // 14\n                                                                       // 15\n\t  settings = merge(settings, {                                        // 16\n\t      /**                                                             // 17\n\t       * Ideal length for links (springs in physical model).          // 18\n\t       */                                                             // 19\n\t      springLength: 30,                                               // 20\n                                                                       // 21\n\t      /**                                                             // 22\n\t       * Hook's law coefficient. 1 - solid spring.                    // 23\n\t       */                                                             // 24\n\t      springCoeff: 0.0008,                                            // 25\n                                                                       // 26\n\t      /**                                                             // 27\n\t       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n\t       * if you make it positive nodes start attract each other :).   // 29\n\t       */                                                             // 30\n\t      gravity: -1.2,                                                  // 31\n                                                                       // 32\n\t      /**                                                             // 33\n\t       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n\t       * The closer it's to 1 the more nodes algorithm will have to go through.\n\t       * Setting it to one makes Barnes Hut simulation no different from\n\t       * brute-force forces calculation (each node is considered).    // 37\n\t       */                                                             // 38\n\t      theta: 0.8,                                                     // 39\n                                                                       // 40\n\t      /**                                                             // 41\n\t       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n\t       * The closer it is to 0 the less tight system will be.         // 43\n\t       */                                                             // 44\n\t      dragCoeff: 0.02,                                                // 45\n                                                                       // 46\n\t      /**                                                             // 47\n\t       * Default time step (dt) for forces integration                // 48\n\t       */                                                             // 49\n\t      timeStep : 20,                                                  // 50\n                                                                       // 51\n\t      /**                                                             // 52\n\t        * Maximum movement of the system which can be considered as stabilized\n\t        */                                                            // 54\n\t      stableThreshold: 0.009                                          // 55\n\t  });                                                                 // 56\n                                                                       // 57\n\t  // We allow clients to override basic factory methods:              // 58\n\t  var createQuadTree = settings.createQuadTree || __webpack_require__(17);\n\t  var createBounds = settings.createBounds || __webpack_require__(22);\n\t  var createDragForce = settings.createDragForce || __webpack_require__(23);\n\t  var createSpringForce = settings.createSpringForce || __webpack_require__(24);\n\t  var integrate = settings.integrator || __webpack_require__(25);     // 63\n\t  var createBody = settings.createBody || __webpack_require__(26);    // 64\n                                                                       // 65\n\t  var bodies = [], // Bodies in this simulation.                      // 66\n\t      springs = [], // Springs in this simulation.                    // 67\n\t      quadTree =  createQuadTree(settings),                           // 68\n\t      bounds = createBounds(bodies, settings),                        // 69\n\t      springForce = createSpringForce(settings),                      // 70\n\t      dragForce = createDragForce(settings);                          // 71\n                                                                       // 72\n\t  var totalMovement = 0; // how much movement we made on last step    // 73\n\t  var lastStable = false; // indicates whether system was stable on last step() call\n                                                                       // 75\n\t  var publicApi = {                                                   // 76\n\t    /**                                                               // 77\n\t     * Array of bodies, registered with current simulator             // 78\n\t     *                                                                // 79\n\t     * Note: To add new body, use addBody() method. This property is only\n\t     * exposed for testing/performance purposes.                      // 81\n\t     */                                                               // 82\n\t    bodies: bodies,                                                   // 83\n                                                                       // 84\n\t    /**                                                               // 85\n\t     * Array of springs, registered with current simulator            // 86\n\t     *                                                                // 87\n\t     * Note: To add new spring, use addSpring() method. This property is only\n\t     * exposed for testing/performance purposes.                      // 89\n\t     */                                                               // 90\n\t    springs: springs,                                                 // 91\n                                                                       // 92\n\t    /**                                                               // 93\n\t     * Returns settings with which current simulator was initialized  // 94\n\t     */                                                               // 95\n\t    settings: settings,                                               // 96\n                                                                       // 97\n\t    /**                                                               // 98\n\t     * Performs one step of force simulation.                         // 99\n\t     *                                                                // 100\n\t     * @returns {boolean} true if system is considered stable; False otherwise.\n\t     */                                                               // 102\n\t    step: function () {                                               // 103\n\t      accumulateForces();                                             // 104\n\t      totalMovement = integrate(bodies, settings.timeStep);           // 105\n                                                                       // 106\n\t      bounds.update();                                                // 107\n\t      var stableNow = totalMovement < settings.stableThreshold;       // 108\n\t      if (lastStable !== stableNow) {                                 // 109\n\t        publicApi.fire('stable', stableNow);                          // 110\n\t      }                                                               // 111\n                                                                       // 112\n\t      lastStable = stableNow;                                         // 113\n                                                                       // 114\n\t      return stableNow;                                               // 115\n\t    },                                                                // 116\n                                                                       // 117\n\t    /**                                                               // 118\n\t     * Adds body to the system                                        // 119\n\t     *                                                                // 120\n\t     * @param {ngraph.physics.primitives.Body} body physical body     // 121\n\t     *                                                                // 122\n\t     * @returns {ngraph.physics.primitives.Body} added body           // 123\n\t     */                                                               // 124\n\t    addBody: function (body) {                                        // 125\n\t      if (!body) {                                                    // 126\n\t        throw new Error('Body is required');                          // 127\n\t      }                                                               // 128\n\t      bodies.push(body);                                              // 129\n                                                                       // 130\n\t      return body;                                                    // 131\n\t    },                                                                // 132\n                                                                       // 133\n\t    /**                                                               // 134\n\t     * Adds body to the system at given position                      // 135\n\t     *                                                                // 136\n\t     * @param {Object} pos position of a body                         // 137\n\t     *                                                                // 138\n\t     * @returns {ngraph.physics.primitives.Body} added body           // 139\n\t     */                                                               // 140\n\t    addBodyAt: function (pos) {                                       // 141\n\t      if (!pos) {                                                     // 142\n\t        throw new Error('Body position is required');                 // 143\n\t      }                                                               // 144\n\t      var body = createBody(pos);                                     // 145\n\t      bodies.push(body);                                              // 146\n                                                                       // 147\n\t      return body;                                                    // 148\n\t    },                                                                // 149\n                                                                       // 150\n\t    /**                                                               // 151\n\t     * Removes body from the system                                   // 152\n\t     *                                                                // 153\n\t     * @param {ngraph.physics.primitives.Body} body to remove         // 154\n\t     *                                                                // 155\n\t     * @returns {Boolean} true if body found and removed. falsy otherwise;\n\t     */                                                               // 157\n\t    removeBody: function (body) {                                     // 158\n\t      if (!body) { return; }                                          // 159\n                                                                       // 160\n\t      var idx = bodies.indexOf(body);                                 // 161\n\t      if (idx < 0) { return; }                                        // 162\n                                                                       // 163\n\t      bodies.splice(idx, 1);                                          // 164\n\t      if (bodies.length === 0) {                                      // 165\n\t        bounds.reset();                                               // 166\n\t      }                                                               // 167\n\t      return true;                                                    // 168\n\t    },                                                                // 169\n                                                                       // 170\n\t    /**                                                               // 171\n\t     * Adds a spring to this simulation.                              // 172\n\t     *                                                                // 173\n\t     * @returns {Object} - a handle for a spring. If you want to later remove\n\t     * spring pass it to removeSpring() method.                       // 175\n\t     */                                                               // 176\n\t    addSpring: function (body1, body2, springLength, springWeight, springCoefficient) {\n\t      if (!body1 || !body2) {                                         // 178\n\t        throw new Error('Cannot add null spring to force simulator');\n\t      }                                                               // 180\n                                                                       // 181\n\t      if (typeof springLength !== 'number') {                         // 182\n\t        springLength = -1; // assume global configuration             // 183\n\t      }                                                               // 184\n                                                                       // 185\n\t      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);\n\t      springs.push(spring);                                           // 187\n                                                                       // 188\n\t      // TODO: could mark simulator as dirty.                         // 189\n\t      return spring;                                                  // 190\n\t    },                                                                // 191\n                                                                       // 192\n\t    /**                                                               // 193\n\t     * Returns amount of movement performed on last step() call       // 194\n\t     */                                                               // 195\n\t    getTotalMovement: function () {                                   // 196\n\t      return totalMovement;                                           // 197\n\t    },                                                                // 198\n                                                                       // 199\n\t    /**                                                               // 200\n\t     * Removes spring from the system                                 // 201\n\t     *                                                                // 202\n\t     * @param {Object} spring to remove. Spring is an object returned by addSpring\n\t     *                                                                // 204\n\t     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n\t     */                                                               // 206\n\t    removeSpring: function (spring) {                                 // 207\n\t      if (!spring) { return; }                                        // 208\n\t      var idx = springs.indexOf(spring);                              // 209\n\t      if (idx > -1) {                                                 // 210\n\t        springs.splice(idx, 1);                                       // 211\n\t        return true;                                                  // 212\n\t      }                                                               // 213\n\t    },                                                                // 214\n                                                                       // 215\n\t    getBestNewBodyPosition: function (neighbors) {                    // 216\n\t      return bounds.getBestNewPosition(neighbors);                    // 217\n\t    },                                                                // 218\n                                                                       // 219\n\t    /**                                                               // 220\n\t     * Returns bounding box which covers all bodies                   // 221\n\t     */                                                               // 222\n\t    getBBox: function () {                                            // 223\n\t      return bounds.box;                                              // 224\n\t    },                                                                // 225\n                                                                       // 226\n\t    gravity: function (value) {                                       // 227\n\t      if (value !== undefined) {                                      // 228\n\t        settings.gravity = value;                                     // 229\n\t        quadTree.options({gravity: value});                           // 230\n\t        return this;                                                  // 231\n\t      } else {                                                        // 232\n\t        return settings.gravity;                                      // 233\n\t      }                                                               // 234\n\t    },                                                                // 235\n                                                                       // 236\n\t    theta: function (value) {                                         // 237\n\t      if (value !== undefined) {                                      // 238\n\t        settings.theta = value;                                       // 239\n\t        quadTree.options({theta: value});                             // 240\n\t        return this;                                                  // 241\n\t      } else {                                                        // 242\n\t        return settings.theta;                                        // 243\n\t      }                                                               // 244\n\t    }                                                                 // 245\n\t  };                                                                  // 246\n                                                                       // 247\n\t  // allow settings modification via public API:                      // 248\n\t  expose(settings, publicApi);                                        // 249\n\t  eventify(publicApi);                                                // 250\n                                                                       // 251\n\t  return publicApi;                                                   // 252\n                                                                       // 253\n\t  function accumulateForces() {                                       // 254\n\t    // Accumulate forces acting on bodies.                            // 255\n\t    var body,                                                         // 256\n\t        i = bodies.length;                                            // 257\n                                                                       // 258\n\t    if (i) {                                                          // 259\n\t      // only add bodies if there the array is not empty:             // 260\n\t      quadTree.insertBodies(bodies); // performance: O(n * log n)     // 261\n\t      while (i--) {                                                   // 262\n\t        body = bodies[i];                                             // 263\n\t        // If body is pinned there is no point updating its forces - it should\n\t        // never move:                                                // 265\n\t        if (!body.isPinned) {                                         // 266\n\t          body.force.reset();                                         // 267\n                                                                       // 268\n\t          quadTree.updateBodyForce(body);                             // 269\n\t          dragForce.update(body);                                     // 270\n\t        }                                                             // 271\n\t      }                                                               // 272\n\t    }                                                                 // 273\n                                                                       // 274\n\t    i = springs.length;                                               // 275\n\t    while(i--) {                                                      // 276\n\t      springForce.update(springs[i]);                                 //\n\t    }                                                                 //\n\t  }                                                                   //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 13 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = Spring;                                              // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Represents a physical spring. Spring connects two bodies, has rest length\n\t * stiffness coefficient and optional weight                          // 9\n\t */                                                                   // 10\n\tfunction Spring(fromBody, toBody, length, coeff, weight) {            // 11\n\t    this.from = fromBody;                                             // 12\n\t    this.to = toBody;                                                 // 13\n\t    this.length = length;                                             // 14\n\t    this.coeff = coeff;                                               //\n                                                                       //\n\t    this.weight = typeof weight === 'number' ? weight : 1;            //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 14 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = exposeProperties;                                    // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Augments `target` object with getter/setter functions, which modify settings\n\t *                                                                    // 9\n\t * @example                                                           // 10\n\t *  var target = {};                                                  // 11\n\t *  exposeProperties({ age: 42}, target);                             // 12\n\t *  target.age(); // returns 42                                       // 13\n\t *  target.age(24); // make age 24;                                   // 14\n\t *                                                                    // 15\n\t *  var filteredTarget = {};                                          // 16\n\t *  exposeProperties({ age: 42, name: 'John'}, filteredTarget, ['name']);\n\t *  filteredTarget.name(); // returns 'John'                          // 18\n\t *  filteredTarget.age === undefined; // true                         // 19\n\t */                                                                   // 20\n\tfunction exposeProperties(settings, target, filter) {                 // 21\n\t  var needsFilter = Object.prototype.toString.call(filter) === '[object Array]';\n\t  if (needsFilter) {                                                  // 23\n\t    for (var i = 0; i < filter.length; ++i) {                         // 24\n\t      augment(settings, target, filter[i]);                           // 25\n\t    }                                                                 // 26\n\t  } else {                                                            // 27\n\t    for (var key in settings) {                                       // 28\n\t      augment(settings, target, key);                                 // 29\n\t    }                                                                 // 30\n\t  }                                                                   // 31\n\t}                                                                     // 32\n                                                                       // 33\n\tfunction augment(source, target, key) {                               // 34\n\t  if (source.hasOwnProperty(key)) {                                   // 35\n\t    if (typeof target[key] === 'function') {                          // 36\n\t      // this accessor is already defined. Ignore it                  // 37\n\t      return;                                                         // 38\n\t    }                                                                 // 39\n\t    target[key] = function (value) {                                  // 40\n\t      if (value !== undefined) {                                      // 41\n\t        source[key] = value;                                          // 42\n\t        return target;                                                // 43\n\t      }                                                               // 44\n\t      return source[key];                                             //\n\t    }                                                                 //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 15 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = merge;                                               // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Augments `target` with properties in `options`. Does not override  // 8\n\t * target's properties if they are defined and matches expected type in \n\t * options                                                            // 10\n\t *                                                                    // 11\n\t * @returns {Object} merged object                                    // 12\n\t */                                                                   // 13\n\tfunction merge(target, options) {                                     // 14\n\t  var key;                                                            // 15\n\t  if (!target) { target = {}; }                                       // 16\n\t  if (options) {                                                      // 17\n\t    for (key in options) {                                            // 18\n\t      if (options.hasOwnProperty(key)) {                              // 19\n\t        var targetHasIt = target.hasOwnProperty(key),                 // 20\n\t            optionsValueType = typeof options[key],                   // 21\n\t            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n                                                                       // 23\n\t        if (shouldReplace) {                                          // 24\n\t          target[key] = options[key];                                 // 25\n\t        } else if (optionsValueType === 'object') {                   // 26\n\t          // go deep, don't care about loops here, we are simple API!:\n\t          target[key] = merge(target[key], options[key]);             // 28\n\t        }                                                             // 29\n\t      }                                                               // 30\n\t    }                                                                 // 31\n\t  }                                                                   //\n                                                                       //\n\t  return target;                                                      //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 16 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = function(subject) {                                  // 5\n\t  validateSubject(subject);                                           // 6\n                                                                       // 7\n\t  var eventsStorage = createEventsStorage(subject);                   // 8\n\t  subject.on = eventsStorage.on;                                      // 9\n\t  subject.off = eventsStorage.off;                                    // 10\n\t  subject.fire = eventsStorage.fire;                                  // 11\n\t  return subject;                                                     // 12\n\t};                                                                    // 13\n                                                                       // 14\n\tfunction createEventsStorage(subject) {                               // 15\n\t  // Store all event listeners to this hash. Key is event name, value is array\n\t  // of callback records.                                             // 17\n\t  //                                                                  // 18\n\t  // A callback record consists of callback function and its optional context:\n\t  // { 'eventName' => [{callback: function, ctx: object}] }           // 20\n\t  var registeredEvents = Object.create(null);                         // 21\n                                                                       // 22\n\t  return {                                                            // 23\n\t    on: function (eventName, callback, ctx) {                         // 24\n\t      if (typeof callback !== 'function') {                           // 25\n\t        throw new Error('callback is expected to be a function');     // 26\n\t      }                                                               // 27\n\t      var handlers = registeredEvents[eventName];                     // 28\n\t      if (!handlers) {                                                // 29\n\t        handlers = registeredEvents[eventName] = [];                  // 30\n\t      }                                                               // 31\n\t      handlers.push({callback: callback, ctx: ctx});                  // 32\n                                                                       // 33\n\t      return subject;                                                 // 34\n\t    },                                                                // 35\n                                                                       // 36\n\t    off: function (eventName, callback) {                             // 37\n\t      var wantToRemoveAll = (typeof eventName === 'undefined');       // 38\n\t      if (wantToRemoveAll) {                                          // 39\n\t        // Killing old events storage should be enough in this case:  // 40\n\t        registeredEvents = Object.create(null);                       // 41\n\t        return subject;                                               // 42\n\t      }                                                               // 43\n                                                                       // 44\n\t      if (registeredEvents[eventName]) {                              // 45\n\t        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n\t        if (deleteAllCallbacksForEvent) {                             // 47\n\t          delete registeredEvents[eventName];                         // 48\n\t        } else {                                                      // 49\n\t          var callbacks = registeredEvents[eventName];                // 50\n\t          for (var i = 0; i < callbacks.length; ++i) {                // 51\n\t            if (callbacks[i].callback === callback) {                 // 52\n\t              callbacks.splice(i, 1);                                 // 53\n\t            }                                                         // 54\n\t          }                                                           // 55\n\t        }                                                             // 56\n\t      }                                                               // 57\n                                                                       // 58\n\t      return subject;                                                 // 59\n\t    },                                                                // 60\n                                                                       // 61\n\t    fire: function (eventName) {                                      // 62\n\t      var callbacks = registeredEvents[eventName];                    // 63\n\t      if (!callbacks) {                                               // 64\n\t        return subject;                                               // 65\n\t      }                                                               // 66\n                                                                       // 67\n\t      var fireArguments;                                              // 68\n\t      if (arguments.length > 1) {                                     // 69\n\t        fireArguments = Array.prototype.splice.call(arguments, 1);    // 70\n\t      }                                                               // 71\n\t      for(var i = 0; i < callbacks.length; ++i) {                     // 72\n\t        var callbackInfo = callbacks[i];                              // 73\n\t        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n\t      }                                                               // 75\n                                                                       // 76\n\t      return subject;                                                 // 77\n\t    }                                                                 // 78\n\t  };                                                                  // 79\n\t}                                                                     // 80\n                                                                       // 81\n\tfunction validateSubject(subject) {                                   // 82\n\t  if (!subject) {                                                     // 83\n\t    throw new Error('Eventify cannot use falsy object as events subject');\n\t  }                                                                   // 85\n\t  var reservedWords = ['on', 'fire', 'off'];                          // 86\n\t  for (var i = 0; i < reservedWords.length; ++i) {                    // 87\n\t    if (subject.hasOwnProperty(reservedWords[i])) {                   // 88\n\t      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n\t    }                                                                 //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 17 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * This is Barnes Hut simulation algorithm for 2d case. Implementation\n\t * is highly optimized (avoids recusion and gc pressure)              // 7\n\t *                                                                    // 8\n\t * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n\t */                                                                   // 10\n                                                                       // 11\n\tmodule.exports = function(options) {                                  // 12\n\t  options = options || {};                                            // 13\n\t  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n\t  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n                                                                       // 16\n\t  // we require deterministic randomness here                         // 17\n\t  var random = __webpack_require__(18).random(1984),                  // 18\n\t    Node = __webpack_require__(19),                                   // 19\n\t    InsertStack = __webpack_require__(20),                            // 20\n\t    isSamePosition = __webpack_require__(21);                         // 21\n                                                                       // 22\n\t  var gravity = options.gravity,                                      // 23\n\t    updateQueue = [],                                                 // 24\n\t    insertStack = new InsertStack(),                                  // 25\n\t    theta = options.theta,                                            // 26\n                                                                       // 27\n\t    nodesCache = [],                                                  // 28\n\t    currentInCache = 0,                                               // 29\n\t    newNode = function() {                                            // 30\n\t      // To avoid pressure on GC we reuse nodes.                      // 31\n\t      var node = nodesCache[currentInCache];                          // 32\n\t      if (node) {                                                     // 33\n\t        node.quad0 = null;                                            // 34\n\t        node.quad1 = null;                                            // 35\n\t        node.quad2 = null;                                            // 36\n\t        node.quad3 = null;                                            // 37\n\t        node.body = null;                                             // 38\n\t        node.mass = node.massX = node.massY = 0;                      // 39\n\t        node.left = node.right = node.top = node.bottom = 0;          // 40\n\t      } else {                                                        // 41\n\t        node = new Node();                                            // 42\n\t        nodesCache[currentInCache] = node;                            // 43\n\t      }                                                               // 44\n                                                                       // 45\n\t      ++currentInCache;                                               // 46\n\t      return node;                                                    // 47\n\t    },                                                                // 48\n                                                                       // 49\n\t    root = newNode(),                                                 // 50\n                                                                       // 51\n\t    // Inserts body to the tree                                       // 52\n\t    insert = function(newBody) {                                      // 53\n\t      insertStack.reset();                                            // 54\n\t      insertStack.push(root, newBody);                                // 55\n                                                                       // 56\n\t      while (!insertStack.isEmpty()) {                                // 57\n\t        var stackItem = insertStack.pop(),                            // 58\n\t          node = stackItem.node,                                      // 59\n\t          body = stackItem.body;                                      // 60\n                                                                       // 61\n\t        if (!node.body) {                                             // 62\n\t          // This is internal node. Update the total mass of the node and center-of-mass.\n\t          var x = body.pos.x;                                         // 64\n\t          var y = body.pos.y;                                         // 65\n\t          node.mass = node.mass + body.mass;                          // 66\n\t          node.massX = node.massX + body.mass * x;                    // 67\n\t          node.massY = node.massY + body.mass * y;                    // 68\n                                                                       // 69\n\t          // Recursively insert the body in the appropriate quadrant.\n\t          // But first find the appropriate quadrant.                 // 71\n\t          var quadIdx = 0, // Assume we are in the 0's quad.          // 72\n\t            left = node.left,                                         // 73\n\t            right = (node.right + left) / 2,                          // 74\n\t            top = node.top,                                           // 75\n\t            bottom = (node.bottom + top) / 2;                         // 76\n                                                                       // 77\n\t          if (x > right) { // somewhere in the eastern part.          // 78\n\t            quadIdx = quadIdx + 1;                                    // 79\n\t            var oldLeft = left;                                       // 80\n\t            left = right;                                             // 81\n\t            right = right + (right - oldLeft);                        // 82\n\t          }                                                           // 83\n\t          if (y > bottom) { // and in south.                          // 84\n\t            quadIdx = quadIdx + 2;                                    // 85\n\t            var oldTop = top;                                         // 86\n\t            top = bottom;                                             // 87\n\t            bottom = bottom + (bottom - oldTop);                      // 88\n\t          }                                                           // 89\n                                                                       // 90\n\t          var child = getChild(node, quadIdx);                        // 91\n\t          if (!child) {                                               // 92\n\t            // The node is internal but this quadrant is not taken. Add\n\t            // subnode to it.                                         // 94\n\t            child = newNode();                                        // 95\n\t            child.left = left;                                        // 96\n\t            child.top = top;                                          // 97\n\t            child.right = right;                                      // 98\n\t            child.bottom = bottom;                                    // 99\n\t            child.body = body;                                        // 100\n                                                                       // 101\n\t            setChild(node, quadIdx, child);                           // 102\n\t          } else {                                                    // 103\n\t            // continue searching in this quadrant.                   // 104\n\t            insertStack.push(child, body);                            // 105\n\t          }                                                           // 106\n\t        } else {                                                      // 107\n\t          // We are trying to add to the leaf node.                   // 108\n\t          // We have to convert current leaf into internal node       // 109\n\t          // and continue adding two nodes.                           // 110\n\t          var oldBody = node.body;                                    // 111\n\t          node.body = null; // internal nodes do not cary bodies      // 112\n                                                                       // 113\n\t          if (isSamePosition(oldBody.pos, body.pos)) {                // 114\n\t            // Prevent infinite subdivision by bumping one node       // 115\n\t            // anywhere in this quadrant                              // 116\n\t            var retriesCount = 3;                                     // 117\n\t            do {                                                      // 118\n\t              var offset = random.nextDouble();                       // 119\n\t              var dx = (node.right - node.left) * offset;             // 120\n\t              var dy = (node.bottom - node.top) * offset;             // 121\n                                                                       // 122\n\t              oldBody.pos.x = node.left + dx;                         // 123\n\t              oldBody.pos.y = node.top + dy;                          // 124\n\t              retriesCount -= 1;                                      // 125\n\t              // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n\t            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n                                                                       // 128\n\t            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n\t              // This is very bad, we ran out of precision.           // 130\n\t              // if we do not return from the method we'll get into   // 131\n\t              // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n\t              // Next layout iteration should get larger bounding box in the first step and fix this\n\t              return;                                                 // 134\n\t            }                                                         // 135\n\t          }                                                           // 136\n\t          // Next iteration should subdivide node further.            // 137\n\t          insertStack.push(node, oldBody);                            // 138\n\t          insertStack.push(node, body);                               // 139\n\t        }                                                             // 140\n\t      }                                                               // 141\n\t    },                                                                // 142\n                                                                       // 143\n\t    update = function(sourceBody) {                                   // 144\n\t      var queue = updateQueue,                                        // 145\n\t        v,                                                            // 146\n\t        dx,                                                           // 147\n\t        dy,                                                           // 148\n\t        r, fx = 0,                                                    // 149\n\t        fy = 0,                                                       // 150\n\t        queueLength = 1,                                              // 151\n\t        shiftIdx = 0,                                                 // 152\n\t        pushIdx = 1;                                                  // 153\n                                                                       // 154\n\t      queue[0] = root;                                                // 155\n                                                                       // 156\n\t      while (queueLength) {                                           // 157\n\t        var node = queue[shiftIdx],                                   // 158\n\t          body = node.body;                                           // 159\n                                                                       // 160\n\t        queueLength -= 1;                                             // 161\n\t        shiftIdx += 1;                                                // 162\n\t        var differentBody = (body !== sourceBody);                    // 163\n\t        if (body && differentBody) {                                  // 164\n\t          // If the current node is a leaf node (and it is not source body),\n\t          // calculate the force exerted by the current node on body, and add this\n\t          // amount to body's net force.                              // 167\n\t          dx = body.pos.x - sourceBody.pos.x;                         // 168\n\t          dy = body.pos.y - sourceBody.pos.y;                         // 169\n\t          r = Math.sqrt(dx * dx + dy * dy);                           // 170\n                                                                       // 171\n\t          if (r === 0) {                                              // 172\n\t            // Poor man's protection against zero distance.           // 173\n\t            dx = (random.nextDouble() - 0.5) / 50;                    // 174\n\t            dy = (random.nextDouble() - 0.5) / 50;                    // 175\n\t            r = Math.sqrt(dx * dx + dy * dy);                         // 176\n\t          }                                                           // 177\n                                                                       // 178\n\t          // This is standard gravition force calculation but we divide\n\t          // by r^3 to save two operations when normalizing force vector.\n\t          v = gravity * body.mass * sourceBody.mass / (r * r * r);    // 181\n\t          fx += v * dx;                                               // 182\n\t          fy += v * dy;                                               // 183\n\t        } else if (differentBody) {                                   // 184\n\t          // Otherwise, calculate the ratio s / r,  where s is the width of the region\n\t          // represented by the internal node, and r is the distance between the body\n\t          // and the node's center-of-mass                            // 187\n\t          dx = node.massX / node.mass - sourceBody.pos.x;             // 188\n\t          dy = node.massY / node.mass - sourceBody.pos.y;             // 189\n\t          r = Math.sqrt(dx * dx + dy * dy);                           // 190\n                                                                       // 191\n\t          if (r === 0) {                                              // 192\n\t            // Sorry about code duplucation. I don't want to create many functions\n\t            // right away. Just want to see performance first.        // 194\n\t            dx = (random.nextDouble() - 0.5) / 50;                    // 195\n\t            dy = (random.nextDouble() - 0.5) / 50;                    // 196\n\t            r = Math.sqrt(dx * dx + dy * dy);                         // 197\n\t          }                                                           // 198\n\t          // If s / r < , treat this internal node as a single body, and calculate the\n\t          // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n\t          if ((node.right - node.left) / r < theta) {                 // 201\n\t            // in the if statement above we consider node's width only\n\t            // because the region was squarified during tree creation.\n\t            // Thus there is no difference between using width or height.\n\t            v = gravity * node.mass * sourceBody.mass / (r * r * r);  // 205\n\t            fx += v * dx;                                             // 206\n\t            fy += v * dy;                                             // 207\n\t          } else {                                                    // 208\n\t            // Otherwise, run the procedure recursively on each of the current node's children.\n                                                                       // 210\n\t            // I intentionally unfolded this loop, to save several CPU cycles.\n\t            if (node.quad0) {                                         // 212\n\t              queue[pushIdx] = node.quad0;                            // 213\n\t              queueLength += 1;                                       // 214\n\t              pushIdx += 1;                                           // 215\n\t            }                                                         // 216\n\t            if (node.quad1) {                                         // 217\n\t              queue[pushIdx] = node.quad1;                            // 218\n\t              queueLength += 1;                                       // 219\n\t              pushIdx += 1;                                           // 220\n\t            }                                                         // 221\n\t            if (node.quad2) {                                         // 222\n\t              queue[pushIdx] = node.quad2;                            // 223\n\t              queueLength += 1;                                       // 224\n\t              pushIdx += 1;                                           // 225\n\t            }                                                         // 226\n\t            if (node.quad3) {                                         // 227\n\t              queue[pushIdx] = node.quad3;                            // 228\n\t              queueLength += 1;                                       // 229\n\t              pushIdx += 1;                                           // 230\n\t            }                                                         // 231\n\t          }                                                           // 232\n\t        }                                                             // 233\n\t      }                                                               // 234\n                                                                       // 235\n\t      sourceBody.force.x += fx;                                       // 236\n\t      sourceBody.force.y += fy;                                       // 237\n\t    },                                                                // 238\n                                                                       // 239\n\t    insertBodies = function(bodies) {                                 // 240\n\t      var x1 = Number.MAX_VALUE,                                      // 241\n\t        y1 = Number.MAX_VALUE,                                        // 242\n\t        x2 = Number.MIN_VALUE,                                        // 243\n\t        y2 = Number.MIN_VALUE,                                        // 244\n\t        i,                                                            // 245\n\t        max = bodies.length;                                          // 246\n                                                                       // 247\n\t      // To reduce quad tree depth we are looking for exact bounding box of all particles.\n\t      i = max;                                                        // 249\n\t      while (i--) {                                                   // 250\n\t        var x = bodies[i].pos.x;                                      // 251\n\t        var y = bodies[i].pos.y;                                      // 252\n\t        if (x < x1) {                                                 // 253\n\t          x1 = x;                                                     // 254\n\t        }                                                             // 255\n\t        if (x > x2) {                                                 // 256\n\t          x2 = x;                                                     // 257\n\t        }                                                             // 258\n\t        if (y < y1) {                                                 // 259\n\t          y1 = y;                                                     // 260\n\t        }                                                             // 261\n\t        if (y > y2) {                                                 // 262\n\t          y2 = y;                                                     // 263\n\t        }                                                             // 264\n\t      }                                                               // 265\n                                                                       // 266\n\t      // Squarify the bounds.                                         // 267\n\t      var dx = x2 - x1,                                               // 268\n\t        dy = y2 - y1;                                                 // 269\n\t      if (dx > dy) {                                                  // 270\n\t        y2 = y1 + dx;                                                 // 271\n\t      } else {                                                        // 272\n\t        x2 = x1 + dy;                                                 // 273\n\t      }                                                               // 274\n                                                                       // 275\n\t      currentInCache = 0;                                             // 276\n\t      root = newNode();                                               // 277\n\t      root.left = x1;                                                 // 278\n\t      root.right = x2;                                                // 279\n\t      root.top = y1;                                                  // 280\n\t      root.bottom = y2;                                               // 281\n                                                                       // 282\n\t      i = max - 1;                                                    // 283\n\t      if (i > 0) {                                                    // 284\n\t        root.body = bodies[i];                                        // 285\n\t      }                                                               // 286\n\t      while (i--) {                                                   // 287\n\t        insert(bodies[i], root);                                      // 288\n\t      }                                                               // 289\n\t    };                                                                // 290\n                                                                       // 291\n\t  return {                                                            // 292\n\t    insertBodies: insertBodies,                                       // 293\n\t    updateBodyForce: update,                                          // 294\n\t    options: function(newOptions) {                                   // 295\n\t      if (newOptions) {                                               // 296\n\t        if (typeof newOptions.gravity === 'number') {                 // 297\n\t          gravity = newOptions.gravity;                               // 298\n\t        }                                                             // 299\n\t        if (typeof newOptions.theta === 'number') {                   // 300\n\t          theta = newOptions.theta;                                   // 301\n\t        }                                                             // 302\n                                                                       // 303\n\t        return this;                                                  // 304\n\t      }                                                               // 305\n                                                                       // 306\n\t      return {                                                        // 307\n\t        gravity: gravity,                                             // 308\n\t        theta: theta                                                  // 309\n\t      };                                                              // 310\n\t    }                                                                 // 311\n\t  };                                                                  // 312\n\t};                                                                    // 313\n                                                                       // 314\n\tfunction getChild(node, idx) {                                        // 315\n\t  if (idx === 0) return node.quad0;                                   // 316\n\t  if (idx === 1) return node.quad1;                                   // 317\n\t  if (idx === 2) return node.quad2;                                   // 318\n\t  if (idx === 3) return node.quad3;                                   // 319\n\t  return null;                                                        // 320\n\t}                                                                     // 321\n                                                                       // 322\n\tfunction setChild(node, idx, child) {                                 // 323\n\t  if (idx === 0) node.quad0 = child;                                  // 324\n\t  else if (idx === 1) node.quad1 = child;                             //\n\t  else if (idx === 2) node.quad2 = child;                             //\n\t  else if (idx === 3) node.quad3 = child;                             //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 18 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = {                                                    // 5\n\t  random: random,                                                     // 6\n\t  randomIterator: randomIterator                                      // 7\n\t};                                                                    // 8\n                                                                       // 9\n\t/**                                                                   // 10\n\t * Creates seeded PRNG with two methods:                              // 11\n\t *   next() and nextDouble()                                          // 12\n\t */                                                                   // 13\n\tfunction random(inputSeed) {                                          // 14\n\t  var seed = typeof inputSeed === 'number' ? inputSeed : (+ new Date());\n\t  var randomFunc = function() {                                       // 16\n\t      // Robert Jenkins' 32 bit integer hash function.                // 17\n\t      seed = ((seed + 0x7ed55d16) + (seed << 12))  & 0xffffffff;      // 18\n\t      seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;      // 19\n\t      seed = ((seed + 0x165667b1) + (seed << 5))   & 0xffffffff;      // 20\n\t      seed = ((seed + 0xd3a2646c) ^ (seed << 9))   & 0xffffffff;      // 21\n\t      seed = ((seed + 0xfd7046c5) + (seed << 3))   & 0xffffffff;      // 22\n\t      seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;      // 23\n\t      return (seed & 0xfffffff) / 0x10000000;                         // 24\n\t  };                                                                  // 25\n                                                                       // 26\n\t  return {                                                            // 27\n\t      /**                                                             // 28\n\t       * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n\t       *                                                              // 30\n\t       * @param maxValue Number REQUIRED. Ommitting this number will result in NaN values from PRNG.\n\t       */                                                             // 32\n\t      next : function (maxValue) {                                    // 33\n\t          return Math.floor(randomFunc() * maxValue);                 // 34\n\t      },                                                              // 35\n                                                                       // 36\n\t      /**                                                             // 37\n\t       * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n\t       * This function is the same as Math.random() (except that it could be seeded)\n\t       */                                                             // 40\n\t      nextDouble : function () {                                      // 41\n\t          return randomFunc();                                        // 42\n\t      }                                                               // 43\n\t  };                                                                  // 44\n\t}                                                                     // 45\n                                                                       // 46\n\t/*                                                                    // 47\n\t * Creates iterator over array, which returns items of array in random order\n\t * Time complexity is guaranteed to be O(n);                          // 49\n\t */                                                                   // 50\n\tfunction randomIterator(array, customRandom) {                        // 51\n\t    var localRandom = customRandom || random();                       // 52\n\t    if (typeof localRandom.next !== 'function') {                     // 53\n\t      throw new Error('customRandom does not match expected API: next() function is missing');\n\t    }                                                                 // 55\n                                                                       // 56\n\t    return {                                                          // 57\n\t        forEach : function (callback) {                               // 58\n\t            var i, j, t;                                              // 59\n\t            for (i = array.length - 1; i > 0; --i) {                  // 60\n\t                j = localRandom.next(i + 1); // i inclusive           // 61\n\t                t = array[j];                                         // 62\n\t                array[j] = array[i];                                  // 63\n\t                array[i] = t;                                         // 64\n                                                                       // 65\n\t                callback(t);                                          // 66\n\t            }                                                         // 67\n                                                                       // 68\n\t            if (array.length) {                                       // 69\n\t                callback(array[0]);                                   // 70\n\t            }                                                         // 71\n\t        },                                                            // 72\n                                                                       // 73\n\t        /**                                                           // 74\n\t         * Shuffles array randomly, in place.                         // 75\n\t         */                                                           // 76\n\t        shuffle : function () {                                       // 77\n\t            var i, j, t;                                              // 78\n\t            for (i = array.length - 1; i > 0; --i) {                  // 79\n\t                j = localRandom.next(i + 1); // i inclusive           // 80\n\t                t = array[j];                                         // 81\n\t                array[j] = array[i];                                  // 82\n\t                array[i] = t;                                         // 83\n\t            }                                                         // 84\n                                                                       // 85\n\t            return array;                                             //\n\t        }                                                             //\n\t    };                                                                //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 19 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Internal data structure to represent 2D QuadTree node              // 6\n\t */                                                                   // 7\n\tmodule.exports = function Node() {                                    // 8\n\t  // body stored inside this node. In quad tree only leaf nodes (by construction)\n\t  // contain boides:                                                  // 10\n\t  this.body = null;                                                   // 11\n                                                                       // 12\n\t  // Child nodes are stored in quads. Each quad is presented by number:\n\t  // 0 | 1                                                            // 14\n\t  // -----                                                            // 15\n\t  // 2 | 3                                                            // 16\n\t  this.quad0 = null;                                                  // 17\n\t  this.quad1 = null;                                                  // 18\n\t  this.quad2 = null;                                                  // 19\n\t  this.quad3 = null;                                                  // 20\n                                                                       // 21\n\t  // Total mass of current node                                       // 22\n\t  this.mass = 0;                                                      // 23\n                                                                       // 24\n\t  // Center of mass coordinates                                       // 25\n\t  this.massX = 0;                                                     // 26\n\t  this.massY = 0;                                                     // 27\n                                                                       // 28\n\t  // bounding box coordinates                                         // 29\n\t  this.left = 0;                                                      // 30\n\t  this.top = 0;                                                       //\n\t  this.bottom = 0;                                                    //\n\t  this.right = 0;                                                     //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 20 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = InsertStack;                                         // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Our implmentation of QuadTree is non-recursive to avoid GC hit     // 8\n\t * This data structure represent stack of elements                    // 9\n\t * which we are trying to insert into quad tree.                      // 10\n\t */                                                                   // 11\n\tfunction InsertStack () {                                             // 12\n\t    this.stack = [];                                                  // 13\n\t    this.popIdx = 0;                                                  // 14\n\t}                                                                     // 15\n                                                                       // 16\n\tInsertStack.prototype = {                                             // 17\n\t    isEmpty: function() {                                             // 18\n\t        return this.popIdx === 0;                                     // 19\n\t    },                                                                // 20\n\t    push: function (node, body) {                                     // 21\n\t        var item = this.stack[this.popIdx];                           // 22\n\t        if (!item) {                                                  // 23\n\t            // we are trying to avoid memory pressue: create new element\n\t            // only when absolutely necessary                         // 25\n\t            this.stack[this.popIdx] = new InsertStackElement(node, body);\n\t        } else {                                                      // 27\n\t            item.node = node;                                         // 28\n\t            item.body = body;                                         // 29\n\t        }                                                             // 30\n\t        ++this.popIdx;                                                // 31\n\t    },                                                                // 32\n\t    pop: function () {                                                // 33\n\t        if (this.popIdx > 0) {                                        // 34\n\t            return this.stack[--this.popIdx];                         // 35\n\t        }                                                             // 36\n\t    },                                                                // 37\n\t    reset: function () {                                              // 38\n\t        this.popIdx = 0;                                              // 39\n\t    }                                                                 // 40\n\t};                                                                    // 41\n                                                                       // 42\n\tfunction InsertStackElement(node, body) {                             //\n\t    this.node = node; // QuadTree node                                //\n\t    this.body = body; // physical body which needs to be inserted to node\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 21 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = function isSamePosition(point1, point2) {            // 5\n\t    var dx = Math.abs(point1.x - point2.x);                           // 6\n\t    var dy = Math.abs(point1.y - point2.y);                           //\n                                                                       //\n\t    return (dx < 1e-8 && dy < 1e-8);                                  //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 22 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tmodule.exports = function (bodies, settings) {                        // 5\n\t  var random = __webpack_require__(18).random(42);                    // 6\n\t  var boundingBox =  { x1: 0, y1: 0, x2: 0, y2: 0 };                  // 7\n                                                                       // 8\n\t  return {                                                            // 9\n\t    box: boundingBox,                                                 // 10\n                                                                       // 11\n\t    update: updateBoundingBox,                                        // 12\n                                                                       // 13\n\t    reset : function () {                                             // 14\n\t      boundingBox.x1 = boundingBox.y1 = 0;                            // 15\n\t      boundingBox.x2 = boundingBox.y2 = 0;                            // 16\n\t    },                                                                // 17\n                                                                       // 18\n\t    getBestNewPosition: function (neighbors) {                        // 19\n\t      var graphRect = boundingBox;                                    // 20\n                                                                       // 21\n\t      var baseX = 0, baseY = 0;                                       // 22\n                                                                       // 23\n\t      if (neighbors.length) {                                         // 24\n\t        for (var i = 0; i < neighbors.length; ++i) {                  // 25\n\t          baseX += neighbors[i].pos.x;                                // 26\n\t          baseY += neighbors[i].pos.y;                                // 27\n\t        }                                                             // 28\n                                                                       // 29\n\t        baseX /= neighbors.length;                                    // 30\n\t        baseY /= neighbors.length;                                    // 31\n\t      } else {                                                        // 32\n\t        baseX = (graphRect.x1 + graphRect.x2) / 2;                    // 33\n\t        baseY = (graphRect.y1 + graphRect.y2) / 2;                    // 34\n\t      }                                                               // 35\n                                                                       // 36\n\t      var springLength = settings.springLength;                       // 37\n\t      return {                                                        // 38\n\t        x: baseX + random.next(springLength) - springLength / 2,      // 39\n\t        y: baseY + random.next(springLength) - springLength / 2       // 40\n\t      };                                                              // 41\n\t    }                                                                 // 42\n\t  };                                                                  // 43\n                                                                       // 44\n\t  function updateBoundingBox() {                                      // 45\n\t    var i = bodies.length;                                            // 46\n\t    if (i === 0) { return; } // don't have to wory here.              // 47\n                                                                       // 48\n\t    var x1 = Number.MAX_VALUE,                                        // 49\n\t        y1 = Number.MAX_VALUE,                                        // 50\n\t        x2 = Number.MIN_VALUE,                                        // 51\n\t        y2 = Number.MIN_VALUE;                                        // 52\n                                                                       // 53\n\t    while(i--) {                                                      // 54\n\t      // this is O(n), could it be done faster with quadtree?         // 55\n\t      // how about pinned nodes?                                      // 56\n\t      var body = bodies[i];                                           // 57\n\t      if (body.isPinned) {                                            // 58\n\t        body.pos.x = body.prevPos.x;                                  // 59\n\t        body.pos.y = body.prevPos.y;                                  // 60\n\t      } else {                                                        // 61\n\t        body.prevPos.x = body.pos.x;                                  // 62\n\t        body.prevPos.y = body.pos.y;                                  // 63\n\t      }                                                               // 64\n\t      if (body.pos.x < x1) {                                          // 65\n\t        x1 = body.pos.x;                                              // 66\n\t      }                                                               // 67\n\t      if (body.pos.x > x2) {                                          // 68\n\t        x2 = body.pos.x;                                              // 69\n\t      }                                                               // 70\n\t      if (body.pos.y < y1) {                                          // 71\n\t        y1 = body.pos.y;                                              // 72\n\t      }                                                               // 73\n\t      if (body.pos.y > y2) {                                          // 74\n\t        y2 = body.pos.y;                                              // 75\n\t      }                                                               // 76\n\t    }                                                                 // 77\n                                                                       // 78\n\t    boundingBox.x1 = x1;                                              // 79\n\t    boundingBox.x2 = x2;                                              // 80\n\t    boundingBox.y1 = y1;                                              //\n\t    boundingBox.y2 = y2;                                              //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 23 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Represents drag force, which reduces force value on each step by given\n\t * coefficient.                                                       // 7\n\t *                                                                    // 8\n\t * @param {Object} options for the drag force                         // 9\n\t * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n\t */                                                                   // 11\n\tmodule.exports = function (options) {                                 // 12\n\t  var merge = __webpack_require__(15),                                // 13\n\t      expose = __webpack_require__(14);                               // 14\n                                                                       // 15\n\t  options = merge(options, {                                          // 16\n\t    dragCoeff: 0.02                                                   // 17\n\t  });                                                                 // 18\n                                                                       // 19\n\t  var api = {                                                         // 20\n\t    update : function (body) {                                        // 21\n\t      body.force.x -= options.dragCoeff * body.velocity.x;            // 22\n\t      body.force.y -= options.dragCoeff * body.velocity.y;            // 23\n\t    }                                                                 // 24\n\t  };                                                                  // 25\n                                                                       // 26\n\t  // let easy access to dragCoeff:                                    // 27\n\t  expose(options, api, ['dragCoeff']);                                //\n                                                                       //\n\t  return api;                                                         //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 24 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Represents spring force, which updates forces acting on two bodies, conntected\n\t * by a spring.                                                       // 7\n\t *                                                                    // 8\n\t * @param {Object} options for the spring force                       // 9\n\t * @param {Number=} options.springCoeff spring force coefficient.     // 10\n\t * @param {Number=} options.springLength desired length of a spring at rest.\n\t */                                                                   // 12\n\tmodule.exports = function (options) {                                 // 13\n\t  var merge = __webpack_require__(15);                                // 14\n\t  var random = __webpack_require__(18).random(42);                    // 15\n\t  var expose = __webpack_require__(14);                               // 16\n                                                                       // 17\n\t  options = merge(options, {                                          // 18\n\t    springCoeff: 0.0002,                                              // 19\n\t    springLength: 80                                                  // 20\n\t  });                                                                 // 21\n                                                                       // 22\n\t  var api = {                                                         // 23\n\t    /**                                                               // 24\n\t     * Upsates forces acting on a spring                              // 25\n\t     */                                                               // 26\n\t    update : function (spring) {                                      // 27\n\t      var body1 = spring.from,                                        // 28\n\t          body2 = spring.to,                                          // 29\n\t          length = spring.length < 0 ? options.springLength : spring.length,\n\t          dx = body2.pos.x - body1.pos.x,                             // 31\n\t          dy = body2.pos.y - body1.pos.y,                             // 32\n\t          r = Math.sqrt(dx * dx + dy * dy);                           // 33\n                                                                       // 34\n\t      if (r === 0) {                                                  // 35\n\t          dx = (random.nextDouble() - 0.5) / 50;                      // 36\n\t          dy = (random.nextDouble() - 0.5) / 50;                      // 37\n\t          r = Math.sqrt(dx * dx + dy * dy);                           // 38\n\t      }                                                               // 39\n                                                                       // 40\n\t      var d = r - length;                                             // 41\n\t      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n                                                                       // 43\n\t      body1.force.x += coeff * dx;                                    // 44\n\t      body1.force.y += coeff * dy;                                    // 45\n                                                                       // 46\n\t      body2.force.x -= coeff * dx;                                    // 47\n\t      body2.force.y -= coeff * dy;                                    // 48\n\t    }                                                                 // 49\n\t  };                                                                  // 50\n                                                                       //\n\t  expose(options, api, ['springCoeff', 'springLength']);              //\n\t  return api;                                                         //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 25 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Performs forces integration, using given timestep. Uses Euler method to solve\n\t * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n\t *                                                                    // 8\n\t * @returns {Number} squared distance of total position updates.      // 9\n\t */                                                                   // 10\n                                                                       // 11\n\tmodule.exports = integrate;                                           // 12\n                                                                       // 13\n\tfunction integrate(bodies, timeStep) {                                // 14\n\t  var dx = 0, tx = 0,                                                 // 15\n\t      dy = 0, ty = 0,                                                 // 16\n\t      i,                                                              // 17\n\t      max = bodies.length;                                            // 18\n                                                                       // 19\n\t  if (max === 0) {                                                    // 20\n\t    return 0;                                                         // 21\n\t  }                                                                   // 22\n                                                                       // 23\n\t  for (i = 0; i < max; ++i) {                                         // 24\n\t    var body = bodies[i],                                             // 25\n\t        coeff = timeStep / body.mass;                                 // 26\n                                                                       // 27\n\t    body.velocity.x += coeff * body.force.x;                          // 28\n\t    body.velocity.y += coeff * body.force.y;                          // 29\n\t    var vx = body.velocity.x,                                         // 30\n\t        vy = body.velocity.y,                                         // 31\n\t        v = Math.sqrt(vx * vx + vy * vy);                             // 32\n                                                                       // 33\n\t    if (v > 1) {                                                      // 34\n\t      body.velocity.x = vx / v;                                       // 35\n\t      body.velocity.y = vy / v;                                       // 36\n\t    }                                                                 // 37\n                                                                       // 38\n\t    dx = timeStep * body.velocity.x;                                  // 39\n\t    dy = timeStep * body.velocity.y;                                  // 40\n                                                                       // 41\n\t    body.pos.x += dx;                                                 // 42\n\t    body.pos.y += dy;                                                 // 43\n                                                                       // 44\n\t    tx += Math.abs(dx); ty += Math.abs(dy);                           // 45\n\t  }                                                                   //\n                                                                       //\n\t  return (tx * tx + ty * ty)/max;                                     //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 26 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar physics = __webpack_require__(27);                                // 5\n                                                                       //\n\tmodule.exports = function(pos) {                                      //\n\t  return new physics.Body(pos);                                       //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 27 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = {                                                    // 5\n\t  Body: Body,                                                         // 6\n\t  Vector2d: Vector2d,                                                 // 7\n\t  Body3d: Body3d,                                                     // 8\n\t  Vector3d: Vector3d                                                  // 9\n\t};                                                                    // 10\n                                                                       // 11\n\tfunction Body(x, y) {                                                 // 12\n\t  this.pos = new Vector2d(x, y);                                      // 13\n\t  this.prevPos = new Vector2d(x, y);                                  // 14\n\t  this.force = new Vector2d();                                        // 15\n\t  this.velocity = new Vector2d();                                     // 16\n\t  this.mass = 1;                                                      // 17\n\t}                                                                     // 18\n                                                                       // 19\n\tBody.prototype.setPosition = function (x, y) {                        // 20\n\t  this.prevPos.x = this.pos.x = x;                                    // 21\n\t  this.prevPos.y = this.pos.y = y;                                    // 22\n\t};                                                                    // 23\n                                                                       // 24\n\tfunction Vector2d(x, y) {                                             // 25\n\t  if (x && typeof x !== 'number') {                                   // 26\n\t    // could be another vector                                        // 27\n\t    this.x = typeof x.x === 'number' ? x.x : 0;                       // 28\n\t    this.y = typeof x.y === 'number' ? x.y : 0;                       // 29\n\t  } else {                                                            // 30\n\t    this.x = typeof x === 'number' ? x : 0;                           // 31\n\t    this.y = typeof y === 'number' ? y : 0;                           // 32\n\t  }                                                                   // 33\n\t}                                                                     // 34\n                                                                       // 35\n\tVector2d.prototype.reset = function () {                              // 36\n\t  this.x = this.y = 0;                                                // 37\n\t};                                                                    // 38\n                                                                       // 39\n\tfunction Body3d(x, y, z) {                                            // 40\n\t  this.pos = new Vector3d(x, y, z);                                   // 41\n\t  this.prevPos = new Vector3d(x, y, z);                               // 42\n\t  this.force = new Vector3d();                                        // 43\n\t  this.velocity = new Vector3d();                                     // 44\n\t  this.mass = 1;                                                      // 45\n\t}                                                                     // 46\n                                                                       // 47\n\tBody3d.prototype.setPosition = function (x, y, z) {                   // 48\n\t  this.prevPos.x = this.pos.x = x;                                    // 49\n\t  this.prevPos.y = this.pos.y = y;                                    // 50\n\t  this.prevPos.z = this.pos.z = z;                                    // 51\n\t};                                                                    // 52\n                                                                       // 53\n\tfunction Vector3d(x, y, z) {                                          // 54\n\t  if (x && typeof x !== 'number') {                                   // 55\n\t    // could be another vector                                        // 56\n\t    this.x = typeof x.x === 'number' ? x.x : 0;                       // 57\n\t    this.y = typeof x.y === 'number' ? x.y : 0;                       // 58\n\t    this.z = typeof x.z === 'number' ? x.z : 0;                       // 59\n\t  } else {                                                            // 60\n\t    this.x = typeof x === 'number' ? x : 0;                           // 61\n\t    this.y = typeof y === 'number' ? y : 0;                           // 62\n\t    this.z = typeof z === 'number' ? z : 0;                           // 63\n\t  }                                                                   // 64\n\t};                                                                    // 65\n                                                                       //\n\tVector3d.prototype.reset = function () {                              //\n\t  this.x = this.y = this.z = 0;                                       //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 28 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * This is Barnes Hut simulation algorithm for 3d case. Implementation\n\t * is highly optimized (avoids recusion and gc pressure)              // 7\n\t *                                                                    // 8\n\t * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n\t *                                                                    // 10\n\t * NOTE: This module duplicates a lot of code from 2d case. Primary reason for\n\t * this is performance. Every time I tried to abstract away vector operations\n\t * I had negative impact on performance. So in this case I'm scarifying code\n\t * reuse in favor of speed                                            // 14\n\t */                                                                   // 15\n                                                                       // 16\n\tmodule.exports = function(options) {                                  // 17\n\t  options = options || {};                                            // 18\n\t  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n\t  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n                                                                       // 21\n\t  // we require deterministic randomness here                         // 22\n\t  var random = __webpack_require__(18).random(1984),                  // 23\n\t    Node = __webpack_require__(29),                                   // 24\n\t    InsertStack = __webpack_require__(30),                            // 25\n\t    isSamePosition = __webpack_require__(31);                         // 26\n                                                                       // 27\n\t  var gravity = options.gravity,                                      // 28\n\t    updateQueue = [],                                                 // 29\n\t    insertStack = new InsertStack(),                                  // 30\n\t    theta = options.theta,                                            // 31\n                                                                       // 32\n\t    nodesCache = [],                                                  // 33\n\t    currentInCache = 0,                                               // 34\n\t    newNode = function() {                                            // 35\n\t      // To avoid pressure on GC we reuse nodes.                      // 36\n\t      var node = nodesCache[currentInCache];                          // 37\n\t      if (node) {                                                     // 38\n\t        node.quad0 = null;                                            // 39\n\t        node.quad4 = null;                                            // 40\n\t        node.quad1 = null;                                            // 41\n\t        node.quad5 = null;                                            // 42\n\t        node.quad2 = null;                                            // 43\n\t        node.quad6 = null;                                            // 44\n\t        node.quad3 = null;                                            // 45\n\t        node.quad7 = null;                                            // 46\n\t        node.body = null;                                             // 47\n\t        node.mass = node.massX = node.massY = node.massZ = 0;         // 48\n\t        node.left = node.right = node.top = node.bottom = node.front = node.back = 0;\n\t      } else {                                                        // 50\n\t        node = new Node();                                            // 51\n\t        nodesCache[currentInCache] = node;                            // 52\n\t      }                                                               // 53\n                                                                       // 54\n\t      ++currentInCache;                                               // 55\n\t      return node;                                                    // 56\n\t    },                                                                // 57\n                                                                       // 58\n\t    root = newNode(),                                                 // 59\n                                                                       // 60\n\t    // Inserts body to the tree                                       // 61\n\t    insert = function(newBody) {                                      // 62\n\t      insertStack.reset();                                            // 63\n\t      insertStack.push(root, newBody);                                // 64\n                                                                       // 65\n\t      while (!insertStack.isEmpty()) {                                // 66\n\t        var stackItem = insertStack.pop(),                            // 67\n\t          node = stackItem.node,                                      // 68\n\t          body = stackItem.body;                                      // 69\n                                                                       // 70\n\t        if (!node.body) {                                             // 71\n\t          // This is internal node. Update the total mass of the node and center-of-mass.\n\t          var x = body.pos.x;                                         // 73\n\t          var y = body.pos.y;                                         // 74\n\t          var z = body.pos.z;                                         // 75\n\t          node.mass += body.mass;                                     // 76\n\t          node.massX += body.mass * x;                                // 77\n\t          node.massY += body.mass * y;                                // 78\n\t          node.massZ += body.mass * z;                                // 79\n                                                                       // 80\n\t          // Recursively insert the body in the appropriate quadrant.\n\t          // But first find the appropriate quadrant.                 // 82\n\t          var quadIdx = 0, // Assume we are in the 0's quad.          // 83\n\t            left = node.left,                                         // 84\n\t            right = (node.right + left) / 2,                          // 85\n\t            top = node.top,                                           // 86\n\t            bottom = (node.bottom + top) / 2,                         // 87\n\t            back = node.back,                                         // 88\n\t            front = (node.front + back) / 2;                          // 89\n                                                                       // 90\n\t          if (x > right) { // somewhere in the eastern part.          // 91\n\t            quadIdx += 1;                                             // 92\n\t            var oldLeft = left;                                       // 93\n\t            left = right;                                             // 94\n\t            right = right + (right - oldLeft);                        // 95\n\t          }                                                           // 96\n\t          if (y > bottom) { // and in south.                          // 97\n\t            quadIdx += 2;                                             // 98\n\t            var oldTop = top;                                         // 99\n\t            top = bottom;                                             // 100\n\t            bottom = bottom + (bottom - oldTop);                      // 101\n\t          }                                                           // 102\n\t          if (z > front) { // and in frontal part                     // 103\n\t            quadIdx += 4;                                             // 104\n\t            var oldBack = back;                                       // 105\n\t            back = front;                                             // 106\n\t            front = back + (back - oldBack);                          // 107\n\t          }                                                           // 108\n                                                                       // 109\n\t          var child = getChild(node, quadIdx);                        // 110\n\t          if (!child) {                                               // 111\n\t            // The node is internal but this quadrant is not taken. Add subnode to it.\n\t            child = newNode();                                        // 113\n\t            child.left = left;                                        // 114\n\t            child.top = top;                                          // 115\n\t            child.right = right;                                      // 116\n\t            child.bottom = bottom;                                    // 117\n\t            child.back = back;                                        // 118\n\t            child.front = front;                                      // 119\n\t            child.body = body;                                        // 120\n                                                                       // 121\n\t            setChild(node, quadIdx, child);                           // 122\n\t          } else {                                                    // 123\n\t            // continue searching in this quadrant.                   // 124\n\t            insertStack.push(child, body);                            // 125\n\t          }                                                           // 126\n\t        } else {                                                      // 127\n\t          // We are trying to add to the leaf node.                   // 128\n\t          // We have to convert current leaf into internal node       // 129\n\t          // and continue adding two nodes.                           // 130\n\t          var oldBody = node.body;                                    // 131\n\t          node.body = null; // internal nodes do not carry bodies     // 132\n                                                                       // 133\n\t          if (isSamePosition(oldBody.pos, body.pos)) {                // 134\n\t            // Prevent infinite subdivision by bumping one node       // 135\n\t            // anywhere in this quadrant                              // 136\n\t            var retriesCount = 3;                                     // 137\n\t            do {                                                      // 138\n\t              var offset = random.nextDouble();                       // 139\n\t              var dx = (node.right - node.left) * offset;             // 140\n\t              var dy = (node.bottom - node.top) * offset;             // 141\n\t              var dz = (node.front - node.back) * offset;             // 142\n                                                                       // 143\n\t              oldBody.pos.x = node.left + dx;                         // 144\n\t              oldBody.pos.y = node.top + dy;                          // 145\n\t              oldBody.pos.z = node.back + dz;                         // 146\n\t              retriesCount -= 1;                                      // 147\n\t              // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n\t            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n                                                                       // 150\n\t            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n\t              // This is very bad, we ran out of precision.           // 152\n\t              // if we do not return from the method we'll get into   // 153\n\t              // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n\t              // Next layout iteration should get larger bounding box in the first step and fix this\n\t              return;                                                 // 156\n\t            }                                                         // 157\n\t          }                                                           // 158\n\t          // Next iteration should subdivide node further.            // 159\n\t          insertStack.push(node, oldBody);                            // 160\n\t          insertStack.push(node, body);                               // 161\n\t        }                                                             // 162\n\t      }                                                               // 163\n\t    },                                                                // 164\n                                                                       // 165\n\t    update = function(sourceBody) {                                   // 166\n\t      var queue = updateQueue,                                        // 167\n\t        v,                                                            // 168\n\t        dx, dy, dz,                                                   // 169\n\t        r, fx = 0,                                                    // 170\n\t        fy = 0,                                                       // 171\n\t        fz = 0,                                                       // 172\n\t        queueLength = 1,                                              // 173\n\t        shiftIdx = 0,                                                 // 174\n\t        pushIdx = 1;                                                  // 175\n                                                                       // 176\n\t      queue[0] = root;                                                // 177\n                                                                       // 178\n\t      while (queueLength) {                                           // 179\n\t        var node = queue[shiftIdx],                                   // 180\n\t          body = node.body;                                           // 181\n                                                                       // 182\n\t        queueLength -= 1;                                             // 183\n\t        shiftIdx += 1;                                                // 184\n\t        var differentBody = (body !== sourceBody);                    // 185\n\t        if (body && differentBody) {                                  // 186\n\t          // If the current node is a leaf node (and it is not source body),\n\t          // calculate the force exerted by the current node on body, and add this\n\t          // amount to body's net force.                              // 189\n\t          dx = body.pos.x - sourceBody.pos.x;                         // 190\n\t          dy = body.pos.y - sourceBody.pos.y;                         // 191\n\t          dz = body.pos.z - sourceBody.pos.z;                         // 192\n\t          r = Math.sqrt(dx * dx + dy * dy + dz * dz);                 // 193\n                                                                       // 194\n\t          if (r === 0) {                                              // 195\n\t            // Poor man's protection against zero distance.           // 196\n\t            dx = (random.nextDouble() - 0.5) / 50;                    // 197\n\t            dy = (random.nextDouble() - 0.5) / 50;                    // 198\n\t            dz = (random.nextDouble() - 0.5) / 50;                    // 199\n\t            r = Math.sqrt(dx * dx + dy * dy + dz * dz);               // 200\n\t          }                                                           // 201\n                                                                       // 202\n\t          // This is standard gravitation force calculation but we divide\n\t          // by r^3 to save two operations when normalizing force vector.\n\t          v = gravity * body.mass * sourceBody.mass / (r * r * r);    // 205\n\t          fx += v * dx;                                               // 206\n\t          fy += v * dy;                                               // 207\n\t          fz += v * dz;                                               // 208\n\t        } else if (differentBody) {                                   // 209\n\t          // Otherwise, calculate the ratio s / r,  where s is the width of the region\n\t          // represented by the internal node, and r is the distance between the body\n\t          // and the node's center-of-mass                            // 212\n\t          dx = node.massX / node.mass - sourceBody.pos.x;             // 213\n\t          dy = node.massY / node.mass - sourceBody.pos.y;             // 214\n\t          dz = node.massZ / node.mass - sourceBody.pos.z;             // 215\n                                                                       // 216\n\t          r = Math.sqrt(dx * dx + dy * dy + dz * dz);                 // 217\n                                                                       // 218\n\t          if (r === 0) {                                              // 219\n\t            // Sorry about code duplication. I don't want to create many functions\n\t            // right away. Just want to see performance first.        // 221\n\t            dx = (random.nextDouble() - 0.5) / 50;                    // 222\n\t            dy = (random.nextDouble() - 0.5) / 50;                    // 223\n\t            dz = (random.nextDouble() - 0.5) / 50;                    // 224\n\t            r = Math.sqrt(dx * dx + dy * dy + dz * dz);               // 225\n\t          }                                                           // 226\n                                                                       // 227\n\t          // If s / r < , treat this internal node as a single body, and calculate the\n\t          // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n\t          if ((node.right - node.left) / r < theta) {                 // 230\n\t            // in the if statement above we consider node's width only\n\t            // because the region was squarified during tree creation.\n\t            // Thus there is no difference between using width or height.\n\t            v = gravity * node.mass * sourceBody.mass / (r * r * r);  // 234\n\t            fx += v * dx;                                             // 235\n\t            fy += v * dy;                                             // 236\n\t            fz += v * dz;                                             // 237\n\t          } else {                                                    // 238\n\t            // Otherwise, run the procedure recursively on each of the current node's children.\n                                                                       // 240\n\t            // I intentionally unfolded this loop, to save several CPU cycles.\n\t            if (node.quad0) {                                         // 242\n\t              queue[pushIdx] = node.quad0;                            // 243\n\t              queueLength += 1;                                       // 244\n\t              pushIdx += 1;                                           // 245\n\t            }                                                         // 246\n\t            if (node.quad1) {                                         // 247\n\t              queue[pushIdx] = node.quad1;                            // 248\n\t              queueLength += 1;                                       // 249\n\t              pushIdx += 1;                                           // 250\n\t            }                                                         // 251\n\t            if (node.quad2) {                                         // 252\n\t              queue[pushIdx] = node.quad2;                            // 253\n\t              queueLength += 1;                                       // 254\n\t              pushIdx += 1;                                           // 255\n\t            }                                                         // 256\n\t            if (node.quad3) {                                         // 257\n\t              queue[pushIdx] = node.quad3;                            // 258\n\t              queueLength += 1;                                       // 259\n\t              pushIdx += 1;                                           // 260\n\t            }                                                         // 261\n\t            if (node.quad4) {                                         // 262\n\t              queue[pushIdx] = node.quad4;                            // 263\n\t              queueLength += 1;                                       // 264\n\t              pushIdx += 1;                                           // 265\n\t            }                                                         // 266\n\t            if (node.quad5) {                                         // 267\n\t              queue[pushIdx] = node.quad5;                            // 268\n\t              queueLength += 1;                                       // 269\n\t              pushIdx += 1;                                           // 270\n\t            }                                                         // 271\n\t            if (node.quad6) {                                         // 272\n\t              queue[pushIdx] = node.quad6;                            // 273\n\t              queueLength += 1;                                       // 274\n\t              pushIdx += 1;                                           // 275\n\t            }                                                         // 276\n\t            if (node.quad7) {                                         // 277\n\t              queue[pushIdx] = node.quad7;                            // 278\n\t              queueLength += 1;                                       // 279\n\t              pushIdx += 1;                                           // 280\n\t            }                                                         // 281\n\t          }                                                           // 282\n\t        }                                                             // 283\n\t      }                                                               // 284\n                                                                       // 285\n\t      sourceBody.force.x += fx;                                       // 286\n\t      sourceBody.force.y += fy;                                       // 287\n\t      sourceBody.force.z += fz;                                       // 288\n\t    },                                                                // 289\n                                                                       // 290\n\t    insertBodies = function(bodies) {                                 // 291\n\t      var x1 = Number.MAX_VALUE,                                      // 292\n\t        y1 = Number.MAX_VALUE,                                        // 293\n\t        z1 = Number.MAX_VALUE,                                        // 294\n\t        x2 = Number.MIN_VALUE,                                        // 295\n\t        y2 = Number.MIN_VALUE,                                        // 296\n\t        z2 = Number.MIN_VALUE,                                        // 297\n\t        i,                                                            // 298\n\t        max = bodies.length;                                          // 299\n                                                                       // 300\n\t      // To reduce quad tree depth we are looking for exact bounding box of all particles.\n\t      i = max;                                                        // 302\n\t      while (i--) {                                                   // 303\n\t        var pos = bodies[i].pos;                                      // 304\n\t        var x = pos.x;                                                // 305\n\t        var y = pos.y;                                                // 306\n\t        var z = pos.z;                                                // 307\n\t        if (x < x1) {                                                 // 308\n\t          x1 = x;                                                     // 309\n\t        }                                                             // 310\n\t        if (x > x2) {                                                 // 311\n\t          x2 = x;                                                     // 312\n\t        }                                                             // 313\n\t        if (y < y1) {                                                 // 314\n\t          y1 = y;                                                     // 315\n\t        }                                                             // 316\n\t        if (y > y2) {                                                 // 317\n\t          y2 = y;                                                     // 318\n\t        }                                                             // 319\n\t        if (z < z1) {                                                 // 320\n\t          z1 = z;                                                     // 321\n\t        }                                                             // 322\n\t        if (z > z2) {                                                 // 323\n\t          z2 = z;                                                     // 324\n\t        }                                                             // 325\n\t      }                                                               // 326\n                                                                       // 327\n\t      // Squarify the bounds.                                         // 328\n\t      var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));    // 329\n                                                                       // 330\n\t      x2 = x1 + maxSide;                                              // 331\n\t      y2 = y1 + maxSide;                                              // 332\n\t      z2 = z1 + maxSide;                                              // 333\n                                                                       // 334\n\t      currentInCache = 0;                                             // 335\n\t      root = newNode();                                               // 336\n\t      root.left = x1;                                                 // 337\n\t      root.right = x2;                                                // 338\n\t      root.top = y1;                                                  // 339\n\t      root.bottom = y2;                                               // 340\n\t      root.back = z1;                                                 // 341\n\t      root.front = z2;                                                // 342\n                                                                       // 343\n\t      i = max - 1;                                                    // 344\n\t      if (i > 0) {                                                    // 345\n\t        root.body = bodies[i];                                        // 346\n\t      }                                                               // 347\n\t      while (i--) {                                                   // 348\n\t        insert(bodies[i], root);                                      // 349\n\t      }                                                               // 350\n\t    };                                                                // 351\n                                                                       // 352\n\t  return {                                                            // 353\n\t    insertBodies: insertBodies,                                       // 354\n\t    updateBodyForce: update,                                          // 355\n\t    options: function(newOptions) {                                   // 356\n\t      if (newOptions) {                                               // 357\n\t        if (typeof newOptions.gravity === 'number') {                 // 358\n\t          gravity = newOptions.gravity;                               // 359\n\t        }                                                             // 360\n\t        if (typeof newOptions.theta === 'number') {                   // 361\n\t          theta = newOptions.theta;                                   // 362\n\t        }                                                             // 363\n                                                                       // 364\n\t        return this;                                                  // 365\n\t      }                                                               // 366\n                                                                       // 367\n\t      return {                                                        // 368\n\t        gravity: gravity,                                             // 369\n\t        theta: theta                                                  // 370\n\t      };                                                              // 371\n\t    }                                                                 // 372\n\t  };                                                                  // 373\n\t};                                                                    // 374\n                                                                       // 375\n\tfunction getChild(node, idx) {                                        // 376\n\t  if (idx === 0) return node.quad0;                                   // 377\n\t  if (idx === 1) return node.quad1;                                   // 378\n\t  if (idx === 2) return node.quad2;                                   // 379\n\t  if (idx === 3) return node.quad3;                                   // 380\n\t  if (idx === 4) return node.quad4;                                   // 381\n\t  if (idx === 5) return node.quad5;                                   // 382\n\t  if (idx === 6) return node.quad6;                                   // 383\n\t  if (idx === 7) return node.quad7;                                   // 384\n\t  return null;                                                        // 385\n\t}                                                                     // 386\n                                                                       // 387\n\tfunction setChild(node, idx, child) {                                 // 388\n\t  if (idx === 0) node.quad0 = child;                                  // 389\n\t  else if (idx === 1) node.quad1 = child;                             // 390\n\t  else if (idx === 2) node.quad2 = child;                             // 391\n\t  else if (idx === 3) node.quad3 = child;                             // 392\n\t  else if (idx === 4) node.quad4 = child;                             // 393\n\t  else if (idx === 5) node.quad5 = child;                             //\n\t  else if (idx === 6) node.quad6 = child;                             //\n\t  else if (idx === 7) node.quad7 = child;                             //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 29 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Internal data structure to represent 3D QuadTree node              // 6\n\t */                                                                   // 7\n\tmodule.exports = function Node() {                                    // 8\n\t  // body stored inside this node. In quad tree only leaf nodes (by construction)\n\t  // contain boides:                                                  // 10\n\t  this.body = null;                                                   // 11\n                                                                       // 12\n\t  // Child nodes are stored in quads. Each quad is presented by number:\n\t  // Behind Z median:                                                 // 14\n\t  // 0 | 1                                                            // 15\n\t  // -----                                                            // 16\n\t  // 2 | 3                                                            // 17\n\t  // In front of Z median:                                            // 18\n\t  // 4 | 5                                                            // 19\n\t  // -----                                                            // 20\n\t  // 6 | 7                                                            // 21\n\t  this.quad0 = null;                                                  // 22\n\t  this.quad1 = null;                                                  // 23\n\t  this.quad2 = null;                                                  // 24\n\t  this.quad3 = null;                                                  // 25\n\t  this.quad4 = null;                                                  // 26\n\t  this.quad5 = null;                                                  // 27\n\t  this.quad6 = null;                                                  // 28\n\t  this.quad7 = null;                                                  // 29\n                                                                       // 30\n\t  // Total mass of current node                                       // 31\n\t  this.mass = 0;                                                      // 32\n                                                                       // 33\n\t  // Center of mass coordinates                                       // 34\n\t  this.massX = 0;                                                     // 35\n\t  this.massY = 0;                                                     // 36\n\t  this.massZ = 0;                                                     // 37\n                                                                       // 38\n\t  // bounding box coordinates                                         // 39\n\t  this.left = 0;                                                      // 40\n\t  this.top = 0;                                                       // 41\n\t  this.bottom = 0;                                                    // 42\n\t  this.right = 0;                                                     //\n\t  this.front = 0;                                                     //\n\t  this.back = 0;                                                      //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 30 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = InsertStack;                                         // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Our implementation of QuadTree is non-recursive to avoid GC hit    // 8\n\t * This data structure represent stack of elements                    // 9\n\t * which we are trying to insert into quad tree.                      // 10\n\t */                                                                   // 11\n\tfunction InsertStack () {                                             // 12\n\t    this.stack = [];                                                  // 13\n\t    this.popIdx = 0;                                                  // 14\n\t}                                                                     // 15\n                                                                       // 16\n\tInsertStack.prototype = {                                             // 17\n\t    isEmpty: function() {                                             // 18\n\t        return this.popIdx === 0;                                     // 19\n\t    },                                                                // 20\n\t    push: function (node, body) {                                     // 21\n\t        var item = this.stack[this.popIdx];                           // 22\n\t        if (!item) {                                                  // 23\n\t            // we are trying to avoid memory pressure: create new element\n\t            // only when absolutely necessary                         // 25\n\t            this.stack[this.popIdx] = new InsertStackElement(node, body);\n\t        } else {                                                      // 27\n\t            item.node = node;                                         // 28\n\t            item.body = body;                                         // 29\n\t        }                                                             // 30\n\t        ++this.popIdx;                                                // 31\n\t    },                                                                // 32\n\t    pop: function () {                                                // 33\n\t        if (this.popIdx > 0) {                                        // 34\n\t            return this.stack[--this.popIdx];                         // 35\n\t        }                                                             // 36\n\t    },                                                                // 37\n\t    reset: function () {                                              // 38\n\t        this.popIdx = 0;                                              // 39\n\t    }                                                                 // 40\n\t};                                                                    // 41\n                                                                       // 42\n\tfunction InsertStackElement(node, body) {                             //\n\t    this.node = node; // QuadTree node                                //\n\t    this.body = body; // physical body which needs to be inserted to node\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 31 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = function isSamePosition(point1, point2) {            // 5\n\t    var dx = Math.abs(point1.x - point2.x);                           // 6\n\t    var dy = Math.abs(point1.y - point2.y);                           // 7\n\t    var dz = Math.abs(point1.z - point2.z);                           //\n                                                                       //\n\t    return (dx < 1e-8 && dy < 1e-8 && dz < 1e-8);                     //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 32 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tmodule.exports = function (bodies, settings) {                        // 5\n\t  var random = __webpack_require__(18).random(42);                    // 6\n\t  var boundingBox =  { x1: 0, y1: 0, z1: 0, x2: 0, y2: 0, z2: 0 };    // 7\n                                                                       // 8\n\t  return {                                                            // 9\n\t    box: boundingBox,                                                 // 10\n                                                                       // 11\n\t    update: updateBoundingBox,                                        // 12\n                                                                       // 13\n\t    reset : function () {                                             // 14\n\t      boundingBox.x1 = boundingBox.y1 = 0;                            // 15\n\t      boundingBox.x2 = boundingBox.y2 = 0;                            // 16\n\t      boundingBox.z1 = boundingBox.z2 = 0;                            // 17\n\t    },                                                                // 18\n                                                                       // 19\n\t    getBestNewPosition: function (neighbors) {                        // 20\n\t      var graphRect = boundingBox;                                    // 21\n                                                                       // 22\n\t      var baseX = 0, baseY = 0, baseZ = 0;                            // 23\n                                                                       // 24\n\t      if (neighbors.length) {                                         // 25\n\t        for (var i = 0; i < neighbors.length; ++i) {                  // 26\n\t          baseX += neighbors[i].pos.x;                                // 27\n\t          baseY += neighbors[i].pos.y;                                // 28\n\t          baseZ += neighbors[i].pos.z;                                // 29\n\t        }                                                             // 30\n                                                                       // 31\n\t        baseX /= neighbors.length;                                    // 32\n\t        baseY /= neighbors.length;                                    // 33\n\t        baseZ /= neighbors.length;                                    // 34\n\t      } else {                                                        // 35\n\t        baseX = (graphRect.x1 + graphRect.x2) / 2;                    // 36\n\t        baseY = (graphRect.y1 + graphRect.y2) / 2;                    // 37\n\t        baseZ = (graphRect.z1 + graphRect.z2) / 2;                    // 38\n\t      }                                                               // 39\n                                                                       // 40\n\t      var springLength = settings.springLength;                       // 41\n\t      return {                                                        // 42\n\t        x: baseX + random.next(springLength) - springLength / 2,      // 43\n\t        y: baseY + random.next(springLength) - springLength / 2,      // 44\n\t        z: baseZ + random.next(springLength) - springLength / 2       // 45\n\t      };                                                              // 46\n\t    }                                                                 // 47\n\t  };                                                                  // 48\n                                                                       // 49\n\t  function updateBoundingBox() {                                      // 50\n\t    var i = bodies.length;                                            // 51\n\t    if (i === 0) { return; } // don't have to wory here.              // 52\n                                                                       // 53\n\t    var x1 = Number.MAX_VALUE,                                        // 54\n\t        y1 = Number.MAX_VALUE,                                        // 55\n\t        z1 = Number.MAX_VALUE,                                        // 56\n\t        x2 = Number.MIN_VALUE,                                        // 57\n\t        y2 = Number.MIN_VALUE,                                        // 58\n\t        z2 = Number.MIN_VALUE;                                        // 59\n                                                                       // 60\n\t    while(i--) {                                                      // 61\n\t      // this is O(n), could it be done faster with quadtree?         // 62\n\t      // how about pinned nodes?                                      // 63\n\t      var body = bodies[i];                                           // 64\n\t      if (body.isPinned) {                                            // 65\n\t        body.pos.x = body.prevPos.x;                                  // 66\n\t        body.pos.y = body.prevPos.y;                                  // 67\n\t        body.pos.z = body.prevPos.z;                                  // 68\n\t      } else {                                                        // 69\n\t        body.prevPos.x = body.pos.x;                                  // 70\n\t        body.prevPos.y = body.pos.y;                                  // 71\n\t        body.prevPos.z = body.pos.z;                                  // 72\n\t      }                                                               // 73\n\t      if (body.pos.x < x1) {                                          // 74\n\t        x1 = body.pos.x;                                              // 75\n\t      }                                                               // 76\n\t      if (body.pos.x > x2) {                                          // 77\n\t        x2 = body.pos.x;                                              // 78\n\t      }                                                               // 79\n\t      if (body.pos.y < y1) {                                          // 80\n\t        y1 = body.pos.y;                                              // 81\n\t      }                                                               // 82\n\t      if (body.pos.y > y2) {                                          // 83\n\t        y2 = body.pos.y;                                              // 84\n\t      }                                                               // 85\n\t      if (body.pos.z < z1) {                                          // 86\n\t        z1 = body.pos.z;                                              // 87\n\t      }                                                               // 88\n\t      if (body.pos.z > z2) {                                          // 89\n\t        z2 = body.pos.z;                                              // 90\n\t      }                                                               // 91\n\t    }                                                                 // 92\n                                                                       // 93\n\t    boundingBox.x1 = x1;                                              // 94\n\t    boundingBox.x2 = x2;                                              // 95\n\t    boundingBox.y1 = y1;                                              // 96\n\t    boundingBox.y2 = y2;                                              // 97\n\t    boundingBox.z1 = z1;                                              //\n\t    boundingBox.z2 = z2;                                              //\n\t  }                                                                   //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 33 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Represents 3d drag force, which reduces force value on each step by given\n\t * coefficient.                                                       // 7\n\t *                                                                    // 8\n\t * @param {Object} options for the drag force                         // 9\n\t * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n\t */                                                                   // 11\n\tmodule.exports = function (options) {                                 // 12\n\t  var merge = __webpack_require__(15),                                // 13\n\t      expose = __webpack_require__(14);                               // 14\n                                                                       // 15\n\t  options = merge(options, {                                          // 16\n\t    dragCoeff: 0.02                                                   // 17\n\t  });                                                                 // 18\n                                                                       // 19\n\t  var api = {                                                         // 20\n\t    update : function (body) {                                        // 21\n\t      body.force.x -= options.dragCoeff * body.velocity.x;            // 22\n\t      body.force.y -= options.dragCoeff * body.velocity.y;            // 23\n\t      body.force.z -= options.dragCoeff * body.velocity.z;            // 24\n\t    }                                                                 // 25\n\t  };                                                                  // 26\n                                                                       // 27\n\t  // let easy access to dragCoeff:                                    // 28\n\t  expose(options, api, ['dragCoeff']);                                //\n                                                                       //\n\t  return api;                                                         //\n\t};                                                                    //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 34 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Represents 3d spring force, which updates forces acting on two bodies, conntected\n\t * by a spring.                                                       // 7\n\t *                                                                    // 8\n\t * @param {Object} options for the spring force                       // 9\n\t * @param {Number=} options.springCoeff spring force coefficient.     // 10\n\t * @param {Number=} options.springLength desired length of a spring at rest.\n\t */                                                                   // 12\n\tmodule.exports = function (options) {                                 // 13\n\t  var merge = __webpack_require__(15);                                // 14\n\t  var random = __webpack_require__(18).random(42);                    // 15\n\t  var expose = __webpack_require__(14);                               // 16\n                                                                       // 17\n\t  options = merge(options, {                                          // 18\n\t    springCoeff: 0.0002,                                              // 19\n\t    springLength: 80                                                  // 20\n\t  });                                                                 // 21\n                                                                       // 22\n\t  var api = {                                                         // 23\n\t    /**                                                               // 24\n\t     * Upsates forces acting on a spring                              // 25\n\t     */                                                               // 26\n\t    update : function (spring) {                                      // 27\n\t      var body1 = spring.from,                                        // 28\n\t          body2 = spring.to,                                          // 29\n\t          length = spring.length < 0 ? options.springLength : spring.length,\n\t          dx = body2.pos.x - body1.pos.x,                             // 31\n\t          dy = body2.pos.y - body1.pos.y,                             // 32\n\t          dz = body2.pos.z - body1.pos.z,                             // 33\n\t          r = Math.sqrt(dx * dx + dy * dy + dz * dz);                 // 34\n                                                                       // 35\n\t      if (r === 0) {                                                  // 36\n\t          dx = (random.nextDouble() - 0.5) / 50;                      // 37\n\t          dy = (random.nextDouble() - 0.5) / 50;                      // 38\n\t          dz = (random.nextDouble() - 0.5) / 50;                      // 39\n\t          r = Math.sqrt(dx * dx + dy * dy + dz * dz);                 // 40\n\t      }                                                               // 41\n                                                                       // 42\n\t      var d = r - length;                                             // 43\n\t      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n                                                                       // 45\n\t      body1.force.x += coeff * dx;                                    // 46\n\t      body1.force.y += coeff * dy;                                    // 47\n\t      body1.force.z += coeff * dz;                                    // 48\n                                                                       // 49\n\t      body2.force.x -= coeff * dx;                                    // 50\n\t      body2.force.y -= coeff * dy;                                    // 51\n\t      body2.force.z -= coeff * dz;                                    // 52\n\t    }                                                                 // 53\n\t  };                                                                  // 54\n                                                                       //\n\t  expose(options, api, ['springCoeff', 'springLength']);              //\n\t  return api;                                                         //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 35 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Performs 3d forces integration, using given timestep. Uses Euler method to solve\n\t * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n\t *                                                                    // 8\n\t * @returns {Number} squared distance of total position updates.      // 9\n\t */                                                                   // 10\n                                                                       // 11\n\tmodule.exports = integrate;                                           // 12\n                                                                       // 13\n\tfunction integrate(bodies, timeStep) {                                // 14\n\t  var dx = 0, tx = 0,                                                 // 15\n\t      dy = 0, ty = 0,                                                 // 16\n\t      dz = 0, tz = 0,                                                 // 17\n\t      i,                                                              // 18\n\t      max = bodies.length;                                            // 19\n                                                                       // 20\n\t  for (i = 0; i < max; ++i) {                                         // 21\n\t    var body = bodies[i],                                             // 22\n\t        coeff = timeStep / body.mass;                                 // 23\n                                                                       // 24\n\t    body.velocity.x += coeff * body.force.x;                          // 25\n\t    body.velocity.y += coeff * body.force.y;                          // 26\n\t    body.velocity.z += coeff * body.force.z;                          // 27\n                                                                       // 28\n\t    var vx = body.velocity.x,                                         // 29\n\t        vy = body.velocity.y,                                         // 30\n\t        vz = body.velocity.z,                                         // 31\n\t        v = Math.sqrt(vx * vx + vy * vy + vz * vz);                   // 32\n                                                                       // 33\n\t    if (v > 1) {                                                      // 34\n\t      body.velocity.x = vx / v;                                       // 35\n\t      body.velocity.y = vy / v;                                       // 36\n\t      body.velocity.z = vz / v;                                       // 37\n\t    }                                                                 // 38\n                                                                       // 39\n\t    dx = timeStep * body.velocity.x;                                  // 40\n\t    dy = timeStep * body.velocity.y;                                  // 41\n\t    dz = timeStep * body.velocity.z;                                  // 42\n                                                                       // 43\n\t    body.pos.x += dx;                                                 // 44\n\t    body.pos.y += dy;                                                 // 45\n\t    body.pos.z += dz;                                                 // 46\n                                                                       // 47\n\t    tx += Math.abs(dx); ty += Math.abs(dy); tz += Math.abs(dz);       // 48\n\t  }                                                                   //\n                                                                       //\n\t  return (tx * tx + ty * ty + tz * tz)/bodies.length;                 //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 36 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar physics = __webpack_require__(27);                                // 5\n                                                                       //\n\tmodule.exports = function(pos) {                                      //\n\t  return new physics.Body3d(pos);                                     //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 37 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar merge = __webpack_require__(15);                                  // 5\n\tvar fs = __webpack_require__(8);                                      // 6\n\tvar path = __webpack_require__(7);                                    // 7\n\tvar mkdirp = __webpack_require__(9);                                  // 8\n\tmodule.exports = save;                                                // 9\n                                                                       // 10\n\tfunction save(graph, options) {                                       // 11\n\t  options = merge(options, {                                          // 12\n\t    outDir: '.',                                                      // 13\n\t    labels: 'labels.json',                                            // 14\n\t    meta: 'meta.json',                                                // 15\n\t    links: 'links.bin'                                                // 16\n\t  });                                                                 // 17\n                                                                       // 18\n\t  fixPaths();                                                         // 19\n                                                                       // 20\n\t  var labels = __webpack_require__(38)(graph);                        // 21\n\t  saveLabels(labels);                                                 // 22\n\t  labels = labels.map(function(label) {                               // 23\n\t    return label.id;                                                  // 24\n\t  });                                                                 // 25\n                                                                       // 26\n\t  var linksBuffer = __webpack_require__(39)(graph, labels);           // 27\n\t  fs.writeFileSync(options.links, linksBuffer);                       // 28\n\t  console.log(graph.getLinksCount() + ' links saved to ' + options.links);\n                                                                       // 30\n\t  saveMeta();                                                         // 31\n                                                                       // 32\n\t  function fixPaths() {                                               // 33\n\t    if (!fs.existsSync(options.outDir)) {                             // 34\n\t      mkdirp.sync(options.outDir);                                    // 35\n\t    }                                                                 // 36\n\t    options.labels = path.join(options.outDir, options.labels);       // 37\n\t    options.meta = path.join(options.outDir, options.meta);           // 38\n\t    options.links = path.join(options.outDir, options.links);         // 39\n\t  }                                                                   // 40\n                                                                       // 41\n\t  function saveMeta() {                                               // 42\n\t    var meta = getMetaInfo();                                         // 43\n\t    fs.writeFileSync(options.meta, JSON.stringify(meta), 'utf8');     // 44\n\t    console.log('Meta information saved to ' + options.meta);         // 45\n\t  }                                                                   // 46\n                                                                       // 47\n\t  function getMetaInfo() {                                            // 48\n\t    return {                                                          // 49\n\t      date: +new Date(),                                              // 50\n\t      nodeCount: graph.getNodesCount(),                               // 51\n\t      linkCount: graph.getLinksCount(),                               // 52\n\t      nodeFile: options.labels,                                       // 53\n\t      linkFile: options.links                                         // 54\n\t    };                                                                // 55\n\t  }                                                                   // 56\n                                                                       // 57\n\t  function saveLabels(labels) {                                       // 58\n\t    fs.writeFileSync(options.labels, JSON.stringify(labels), 'utf8');\n\t    console.log(labels.length + ' ids saved to ' + options.labels);   //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 38 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * Gets all labels (i.e. node ids) as array, sorted in the `forEachNode()` order\n\t */                                                                   // 7\n\tmodule.exports = getLabels;                                           // 8\n                                                                       // 9\n\tfunction getLabels(graph) {                                           // 10\n\t  var labels = [];                                                    // 11\n\t  graph.forEachNode(saveNode);                                        // 12\n                                                                       // 13\n\t  return labels;                                                      // 14\n                                                                       // 15\n\t  function saveNode(node) {                                           //\n\t    labels.push({id: node.id, data: node.data});                      //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 39 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = getLinksBuffer;                                      // 5\n                                                                       // 6\n\tfunction getLinksBuffer(graph, labels) {                              // 7\n\t  var nodeMap = Object.create(null);                                  // 8\n                                                                       // 9\n\t  labels.forEach(function(element, i) {                               // 10\n\t    // +1 to avoid 0 uncertainty                                      // 11\n\t    nodeMap[element] = i + 1;                                         // 12\n\t  });                                                                 // 13\n                                                                       // 14\n\t  var linksCount = graph.getLinksCount();                             // 15\n\t  var buf = new Buffer((labels.length + linksCount) * 4);             // 16\n\t  var idx = 0;                                                        // 17\n                                                                       // 18\n\t  graph.forEachNode(function(node) {                                  // 19\n\t    var startWriten = false;                                          // 20\n\t    var start = nodeMap[node.id];                                     // 21\n\t    graph.forEachLinkedNode(node.id, saveLink, true);                 // 22\n                                                                       // 23\n\t    function saveLink(node) {                                         // 24\n\t      if (!startWriten) {                                             // 25\n\t        startWriten = true;                                           // 26\n\t        buf.writeInt32LE(-start, idx);                                // 27\n\t        idx += 4;                                                     // 28\n\t      }                                                               // 29\n\t      var other = nodeMap[node.id];                                   // 30\n                                                                       // 31\n\t      buf.writeInt32LE(other, idx);                                   // 32\n\t      idx += 4;                                                       // 33\n\t    }                                                                 // 34\n\t  });                                                                 //\n                                                                       //\n\t  return buf.slice(0, idx);                                           //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 40 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\t/*                                                                    // 7\n\tCopyright (c) 2011, Chris Umbel                                       // 8\n                                                                       // 9\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:              // 15\n                                                                       // 16\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.                   // 18\n                                                                       // 19\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.                                                         // 26\n\t*/                                                                    // 27\n                                                                       // 28\n\tvar IndexFile = __webpack_require__(41),                              // 29\n\t    DataFile = __webpack_require__(44);                               // 30\n                                                                       // 31\n\tfunction pushResults(data, results, offsets, callback) {              // 32\n\t  var wordnet = this;                                                 // 33\n                                                                       // 34\n\t  if (offsets.length == 0) {                                          // 35\n\t    callback(results);                                                // 36\n\t  } else {                                                            // 37\n\t    data.get(offsets.pop(), function (record) {                       // 38\n\t      results.push(record);                                           // 39\n\t      wordnet.pushResults(data, results, offsets, callback);          // 40\n\t    });                                                               // 41\n\t  }                                                                   // 42\n\t}                                                                     // 43\n                                                                       // 44\n\tfunction lookupFromFiles(files, results, word, callback) {            // 45\n\t  var wordnet = this;                                                 // 46\n                                                                       // 47\n\t  if (files.length == 0) callback(results);else {                     // 48\n\t    var file = files.pop();                                           // 49\n                                                                       // 50\n\t    file.index.lookup(word, function (record) {                       // 51\n\t      if (record) {                                                   // 52\n\t        wordnet.pushResults(file.data, results, record.synsetOffset, function () {\n\t          wordnet.lookupFromFiles(files, results, word, callback);    // 54\n\t        });                                                           // 55\n\t      } else {                                                        // 56\n\t        wordnet.lookupFromFiles(files, results, word, callback);      // 57\n\t      }                                                               // 58\n\t    });                                                               // 59\n\t  }                                                                   // 60\n\t}                                                                     // 61\n                                                                       // 62\n\tfunction lookup(word, callback) {                                     // 63\n\t  word = word.toLowerCase().replace(/\\s+/g, '_');                     // 64\n                                                                       // 65\n\t  this.lookupFromFiles([{ index: this.nounIndex, data: this.nounData }, { index: this.verbIndex, data: this.verbData }, { index: this.adjIndex, data: this.adjData }, { index: this.advIndex, data: this.advData }], [], word, callback);\n\t}                                                                     // 67\n                                                                       // 68\n\tfunction get(synsetOffset, pos, callback) {                           // 69\n\t  var dataFile = this.getDataFile(pos);                               // 70\n\t  var wordnet = this;                                                 // 71\n                                                                       // 72\n\t  dataFile.get(synsetOffset, function (result) {                      // 73\n\t    callback(result);                                                 // 74\n\t  });                                                                 // 75\n\t}                                                                     // 76\n                                                                       // 77\n\tfunction getDataFile(pos) {                                           // 78\n\t  switch (pos) {                                                      // 79\n\t    case 'n':                                                         // 80\n\t      return this.nounData;                                           // 81\n\t    case 'v':                                                         // 82\n\t      return this.verbData;                                           // 83\n\t    case 'a':case 's':                                                // 84\n\t      return this.adjData;                                            // 85\n\t    case 'r':                                                         // 86\n\t      return this.advData;                                            // 87\n\t  }                                                                   // 88\n\t}                                                                     // 89\n                                                                       // 90\n\tfunction loadSynonyms(synonyms, results, ptrs, callback) {            // 91\n\t  var wordnet = this;                                                 // 92\n                                                                       // 93\n\t  if (ptrs.length > 0) {                                              // 94\n\t    var ptr = ptrs.pop();                                             // 95\n                                                                       // 96\n\t    this.get(ptr.synsetOffset, ptr.pos, function (result) {           // 97\n\t      synonyms.push(result);                                          // 98\n\t      wordnet.loadSynonyms(synonyms, results, ptrs, callback);        // 99\n\t    });                                                               // 100\n\t  } else {                                                            // 101\n\t    wordnet.loadResultSynonyms(synonyms, results, callback);          // 102\n\t  }                                                                   // 103\n\t}                                                                     // 104\n                                                                       // 105\n\tfunction loadResultSynonyms(synonyms, results, callback) {            // 106\n\t  var wordnet = this;                                                 // 107\n                                                                       // 108\n\t  if (results.length > 0) {                                           // 109\n\t    var result = results.pop();                                       // 110\n\t    wordnet.loadSynonyms(synonyms, results, result.ptrs, callback);   // 111\n\t  } else callback(synonyms);                                          // 112\n\t}                                                                     // 113\n                                                                       // 114\n\tfunction lookupSynonyms(word, callback) {                             // 115\n\t  var wordnet = this;                                                 // 116\n                                                                       // 117\n\t  wordnet.lookup(word, function (results) {                           // 118\n\t    wordnet.loadResultSynonyms([], results, callback);                // 119\n\t  });                                                                 // 120\n\t}                                                                     // 121\n                                                                       // 122\n\tfunction getSynonyms() {                                              // 123\n\t  var wordnet = this;                                                 // 124\n\t  var callback = arguments[2] ? arguments[2] : arguments[1];          // 125\n\t  var pos = arguments[0].pos ? arguments[0].pos : arguments[1];       // 126\n\t  var synsetOffset = arguments[0].synsetOffset ? arguments[0].synsetOffset : arguments[0];\n                                                                       // 128\n\t  this.get(synsetOffset, pos, function (result) {                     // 129\n\t    wordnet.loadSynonyms([], [], result.ptrs, callback);              // 130\n\t  });                                                                 // 131\n\t}                                                                     // 132\n                                                                       // 133\n\tfunction WordNet(dataDir) {                                           // 134\n                                                                       // 135\n\t  if (!dataDir) {                                                     // 136\n\t    try {                                                             // 137\n\t      var WNdb = __webpack_require__(45);                             // 138\n\t    } catch (e) {                                                     // 139\n\t      console.error(\"Please 'npm install wordnet-db' before using WordNet module or specify a dict directory.\");\n\t      throw e;                                                        // 141\n\t    }                                                                 // 142\n\t    dataDir = WNdb.path;                                              // 143\n\t  }                                                                   // 144\n                                                                       // 145\n\t  this.nounIndex = new IndexFile(dataDir, 'noun');                    // 146\n\t  this.verbIndex = new IndexFile(dataDir, 'verb');                    // 147\n\t  this.adjIndex = new IndexFile(dataDir, 'adj');                      // 148\n\t  this.advIndex = new IndexFile(dataDir, 'adv');                      // 149\n                                                                       // 150\n\t  this.nounData = new DataFile(dataDir, 'noun');                      // 151\n\t  this.verbData = new DataFile(dataDir, 'verb');                      // 152\n\t  this.adjData = new DataFile(dataDir, 'adj');                        // 153\n\t  this.advData = new DataFile(dataDir, 'adv');                        // 154\n                                                                       // 155\n\t  this.get = get;                                                     // 156\n\t  this.lookup = lookup;                                               // 157\n\t  this.lookupFromFiles = lookupFromFiles;                             // 158\n\t  this.pushResults = pushResults;                                     // 159\n\t  this.loadResultSynonyms = loadResultSynonyms;                       // 160\n\t  this.loadSynonyms = loadSynonyms;                                   // 161\n\t  this.lookupSynonyms = lookupSynonyms;                               // 162\n\t  this.getSynonyms = getSynonyms;                                     // 163\n\t  this.getDataFile = getDataFile;                                     //\n\t}                                                                     //\n                                                                       //\n\tmodule.exports = WordNet;                                             //\n                                                                       //\n/***/ },                                                               // 1\n/* 41 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\t/*                                                                    // 7\n\tCopyright (c) 2011, Chris Umbel                                       // 8\n                                                                       // 9\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:              // 15\n                                                                       // 16\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.                   // 18\n                                                                       // 19\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.                                                         // 26\n\t*/                                                                    // 27\n                                                                       // 28\n\tvar WordNetFile = __webpack_require__(42),                            // 29\n\t    fs = __webpack_require__(8),                                      // 30\n\t    util = __webpack_require__(43);                                   // 31\n                                                                       // 32\n\tfunction getFileSize(path) {                                          // 33\n\t  var stat = fs.statSync(path);                                       // 34\n\t  return stat.size;                                                   // 35\n\t}                                                                     // 36\n                                                                       // 37\n\tfunction findPrevEOL(fd, pos, callback) {                             // 38\n\t  var buff = new Buffer(1024);                                        // 39\n\t  if (pos == 0) callback(0);else {                                    // 40\n\t    fs.read(fd, buff, 0, 1, pos, function (err, count) {              // 41\n\t      if (buff[0] == 10) callback(pos + 1);else findPrevEOL(fd, pos - 1, callback);\n\t    });                                                               // 43\n\t  }                                                                   // 44\n\t}                                                                     // 45\n                                                                       // 46\n\tfunction readLine(fd, pos, callback) {                                // 47\n\t  var buff = new Buffer(1024);                                        // 48\n\t  findPrevEOL(fd, pos, function (pos) {                               // 49\n\t    WordNetFile.appendLineChar(fd, pos, 0, buff, callback);           // 50\n\t  });                                                                 // 51\n\t}                                                                     // 52\n                                                                       // 53\n\tfunction miss(callback) {                                             // 54\n\t  callback({ status: 'miss' });                                       // 55\n\t}                                                                     // 56\n                                                                       // 57\n\tfunction findAt(fd, size, pos, lastPos, adjustment, searchKey, callback, lastKey) {\n\t  if (lastPos == pos || pos >= size) {                                // 59\n\t    miss(callback);                                                   // 60\n\t  } else {                                                            // 61\n\t    readLine(fd, pos, function (line) {                               // 62\n\t      var tokens = line.split(/\\s+/);                                 // 63\n\t      var key = tokens[0];                                            // 64\n                                                                       // 65\n\t      if (key == searchKey) {                                         // 66\n\t        callback({ status: 'hit', key: key, 'line': line, tokens: tokens });\n\t      } else if (adjustment == 1 || key == lastKey) {                 // 68\n\t        miss(callback);                                               // 69\n\t      } else {                                                        // 70\n\t        adjustment = Math.ceil(adjustment * 0.5);                     // 71\n                                                                       // 72\n\t        if (key < searchKey) {                                        // 73\n\t          findAt(fd, size, pos + adjustment, pos, adjustment, searchKey, callback, key);\n\t        } else {                                                      // 75\n\t          findAt(fd, size, pos - adjustment, pos, adjustment, searchKey, callback, key);\n\t        }                                                             // 77\n\t      }                                                               // 78\n\t    });                                                               // 79\n\t  }                                                                   // 80\n\t}                                                                     // 81\n                                                                       // 82\n\tfunction find(searchKey, callback) {                                  // 83\n\t  var indexFile = this;                                               // 84\n                                                                       // 85\n\t  indexFile.open(function (err, fd, done) {                           // 86\n\t    if (err) {                                                        // 87\n\t      console.log(err);                                               // 88\n\t    } else {                                                          // 89\n\t      var size = getFileSize(indexFile.filePath) - 1;                 // 90\n\t      var pos = Math.ceil(size / 2);                                  // 91\n\t      findAt(fd, size, pos, null, pos, searchKey, function (result) {\n\t        callback(result);done();                                      // 93\n\t      });                                                             // 94\n\t    }                                                                 // 95\n\t  });                                                                 // 96\n\t}                                                                     // 97\n                                                                       // 98\n\tfunction lookupFromFile(word, callback) {                             // 99\n\t  this.find(word, function (record) {                                 // 100\n\t    var indexRecord = null;                                           // 101\n                                                                       // 102\n\t    if (record.status == 'hit') {                                     // 103\n\t      var ptrs = [],                                                  // 104\n\t          offsets = [];                                               // 105\n                                                                       // 106\n\t      for (var i = 0; i < parseInt(record.tokens[3]); i++) {          // 107\n\t        ptrs.push(record.tokens[i]);                                  // 108\n\t      }for (var i = 0; i < parseInt(record.tokens[2]); i++) {         // 109\n\t        offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));\n\t      }indexRecord = {                                                // 111\n\t        lemma: record.tokens[0],                                      // 112\n\t        pos: record.tokens[1],                                        // 113\n\t        ptrSymbol: ptrs,                                              // 114\n\t        senseCnt: parseInt(record.tokens[ptrs.length + 4], 10),       // 115\n\t        tagsenseCnt: parseInt(record.tokens[ptrs.length + 5], 10),    // 116\n\t        synsetOffset: offsets                                         // 117\n\t      };                                                              // 118\n\t    }                                                                 // 119\n                                                                       // 120\n\t    callback(indexRecord);                                            // 121\n\t  });                                                                 // 122\n\t}                                                                     // 123\n                                                                       // 124\n\tfunction lookup(word, callback) {                                     // 125\n\t  this.lookupFromFile(word, callback);                                // 126\n\t}                                                                     // 127\n                                                                       // 128\n\tvar IndexFile = function IndexFile(dataDir, name) {                   // 129\n\t  WordNetFile.call(this, dataDir, 'index.' + name);                   // 130\n\t};                                                                    // 131\n                                                                       // 132\n\tutil.inherits(IndexFile, WordNetFile);                                // 133\n                                                                       // 134\n\tIndexFile.prototype.lookupFromFile = lookupFromFile;                  // 135\n\tIndexFile.prototype.lookup = lookup;                                  // 136\n\tIndexFile.prototype.find = find;                                      // 137\n                                                                       //\n\tIndexFile.prototype._findAt = findAt;                                 //\n                                                                       //\n\tmodule.exports = IndexFile;                                           //\n                                                                       //\n/***/ },                                                               // 1\n/* 42 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\t/*                                                                    // 7\n\tCopyright (c) 2011, Chris Umbel                                       // 8\n                                                                       // 9\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:              // 15\n                                                                       // 16\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.                   // 18\n                                                                       // 19\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.                                                         // 26\n\t*/                                                                    // 27\n                                                                       // 28\n\tvar fs = __webpack_require__(8),                                      // 29\n\t    path = __webpack_require__(7),                                    // 30\n\t    util = __webpack_require__(43);                                   // 31\n                                                                       // 32\n\tfunction appendLineChar(fd, pos, buffPos, buff, callback) {           // 33\n\t  if (buffPos >= buff.length) {                                       // 34\n\t    var newBuff = new Buffer(buff.length * 2);                        // 35\n\t    buff.copy(newBuff, 0, 0, buff.length);                            // 36\n\t    buff = newBuff;                                                   // 37\n\t  }                                                                   // 38\n                                                                       // 39\n\t  fs.read(fd, buff, buffPos, 1, pos, function (err, count) {          // 40\n\t    if (err) console.log(err);else {                                  // 41\n\t      if (buff[buffPos] == 10 || buffPos == buff.length) callback(buff.slice(0, buffPos).toString('UTF-8'));else {\n\t        appendLineChar(fd, pos + 1, buffPos + 1, buff, callback);     // 43\n\t      }                                                               // 44\n\t    }                                                                 // 45\n\t  });                                                                 // 46\n\t}                                                                     // 47\n                                                                       // 48\n\tfunction open(callback) {                                             // 49\n\t  var filePath = this.filePath;                                       // 50\n                                                                       // 51\n\t  fs.open(filePath, 'r', null, function (err, fd) {                   // 52\n\t    if (err) {                                                        // 53\n\t      console.log('Unable to open %s', filePath);                     // 54\n\t      return;                                                         // 55\n\t    }                                                                 // 56\n\t    callback(err, fd, function () {                                   // 57\n\t      fs.close(fd);                                                   // 58\n\t    });                                                               // 59\n\t  });                                                                 // 60\n\t}                                                                     // 61\n                                                                       // 62\n\tvar WordNetFile = function WordNetFile(dataDir, fileName) {           // 63\n\t  this.dataDir = dataDir;                                             // 64\n\t  this.fileName = fileName;                                           // 65\n\t  this.filePath = __webpack_require__(7).join(this.dataDir, this.fileName);\n\t};                                                                    // 67\n                                                                       // 68\n\tWordNetFile.prototype.open = open;                                    //\n\tWordNetFile.appendLineChar = appendLineChar;                          //\n                                                                       //\n\tmodule.exports = WordNetFile;                                         //\n                                                                       //\n/***/ },                                                               //\n/* 43 */                                                               //\n/***/ function(module, exports) {                                      //\n                                                                       //\n\tmodule.exports = require(\"util\");                                     //\n                                                                       //\n/***/ },                                                               // 1\n/* 44 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t'use strict';                                                         // 5\n                                                                       // 6\n\t/*                                                                    // 7\n\tCopyright (c) 2011, Chris Umbel                                       // 8\n                                                                       // 9\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:              // 15\n                                                                       // 16\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.                   // 18\n                                                                       // 19\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.                                                         // 26\n\t*/                                                                    // 27\n                                                                       // 28\n\tvar WordNetFile = __webpack_require__(42),                            // 29\n\t    fs = __webpack_require__(8),                                      // 30\n\t    util = __webpack_require__(43);                                   // 31\n                                                                       // 32\n\tfunction get(location, callback) {                                    // 33\n\t  var buff = new Buffer(4096);                                        // 34\n                                                                       // 35\n\t  this.open(function (err, fd, done) {                                // 36\n\t    WordNetFile.appendLineChar(fd, location, 0, buff, function (line) {\n\t      done();                                                         // 38\n\t      var data = line.split('| ');                                    // 39\n\t      var tokens = data[0].split(/\\s+/);                              // 40\n\t      var ptrs = [];                                                  // 41\n\t      var wCnt = parseInt(tokens[3], 16);                             // 42\n\t      var synonyms = [];                                              // 43\n                                                                       // 44\n\t      for (var i = 0; i < wCnt; i++) {                                // 45\n\t        synonyms.push(tokens[4 + i * 2]);                             // 46\n\t      }                                                               // 47\n                                                                       // 48\n\t      var ptrOffset = (wCnt - 1) * 2 + 6;                             // 49\n\t      for (var i = 0; i < parseInt(tokens[ptrOffset], 10); i++) {     // 50\n\t        ptrs.push({                                                   // 51\n\t          pointerSymbol: tokens[ptrOffset + 1 + i * 4],               // 52\n\t          synsetOffset: parseInt(tokens[ptrOffset + 2 + i * 4], 10),  // 53\n\t          pos: tokens[ptrOffset + 3 + i * 4],                         // 54\n\t          sourceTarget: tokens[ptrOffset + 4 + i * 4]                 // 55\n\t        });                                                           // 56\n\t      }                                                               // 57\n                                                                       // 58\n\t      // break \"gloss\" into definition vs. examples                   // 59\n\t      var glossArray = data[1].split(\"; \");                           // 60\n\t      var definition = glossArray[0];                                 // 61\n\t      var examples = glossArray.slice(1);                             // 62\n                                                                       // 63\n\t      for (var k = 0; k < examples.length; k++) {                     // 64\n\t        examples[k] = examples[k].replace(/\\\"/g, '').replace(/\\s\\s+/g, '');\n\t      }                                                               // 66\n                                                                       // 67\n\t      callback({                                                      // 68\n\t        synsetOffset: parseInt(tokens[0], 10),                        // 69\n\t        lexFilenum: parseInt(tokens[1], 10),                          // 70\n\t        pos: tokens[2],                                               // 71\n\t        wCnt: wCnt,                                                   // 72\n\t        lemma: tokens[4],                                             // 73\n\t        synonyms: synonyms,                                           // 74\n\t        lexId: tokens[5],                                             // 75\n\t        ptrs: ptrs,                                                   // 76\n\t        gloss: data[1],                                               // 77\n\t        def: definition,                                              // 78\n\t        exp: examples                                                 // 79\n\t      });                                                             // 80\n\t    });                                                               // 81\n\t  });                                                                 // 82\n\t}                                                                     // 83\n                                                                       // 84\n\tvar DataFile = function DataFile(dataDir, name) {                     // 85\n\t  WordNetFile.call(this, dataDir, 'data.' + name);                    // 86\n\t};                                                                    // 87\n                                                                       // 88\n\tutil.inherits(DataFile, WordNetFile);                                 //\n\tDataFile.prototype.get = get;                                         //\n                                                                       //\n\tmodule.exports = DataFile;                                            //\n                                                                       //\n/***/ },                                                               // 1\n/* 45 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/* WEBPACK VAR INJECTION */(function(__dirname) {                     // 5\n\texports.version = \"3.1\";\t// this is the WordNet DB version            // 6\n\texports.path = __webpack_require__(7).join(__dirname, \"dict\");        //\n\texports.files = __webpack_require__(8).readdirSync(exports.path);     //\n                                                                       //\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"node_modules/wordnet-db\"))\n                                                                       //\n/***/ },                                                               // 1\n/* 46 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\t/**                                                                   // 5\n\t * @fileOverview Contains definition of the core graph object.        // 6\n\t */                                                                   // 7\n                                                                       // 8\n\t/**                                                                   // 9\n\t * @example                                                           // 10\n\t *  var graph = require('ngraph.graph')();                            // 11\n\t *  graph.addNode(1);     // graph has one node.                      // 12\n\t *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n\t *                                                                    // 14\n\t */                                                                   // 15\n\tmodule.exports = createGraph;                                         // 16\n                                                                       // 17\n\tvar eventify = __webpack_require__(16);                               // 18\n                                                                       // 19\n\t/**                                                                   // 20\n\t * Creates a new graph                                                // 21\n\t */                                                                   // 22\n\tfunction createGraph(options) {                                       // 23\n\t  // Graph structure is maintained as dictionary of nodes             // 24\n\t  // and array of links. Each node has 'links' property which         // 25\n\t  // hold all links related to that node. And general links           // 26\n\t  // array is used to speed up all links enumeration. This is inefficient\n\t  // in terms of memory, but simplifies coding.                       // 28\n\t  options = options || {};                                            // 29\n\t  if (options.uniqueLinkId === undefined) {                           // 30\n\t    // Request each link id to be unique between same nodes. This negatively\n\t    // impacts `addLink()` performance (O(n), where n - number of edges of each\n\t    // vertex), but makes operations with multigraphs more accessible.\n\t    options.uniqueLinkId = true;                                      // 34\n\t  }                                                                   // 35\n                                                                       // 36\n\t  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n\t    links = [],                                                       // 38\n\t    // Hash of multi-edges. Used to track ids of edges between same nodes\n\t    multiEdges = {},                                                  // 40\n\t    nodesCount = 0,                                                   // 41\n\t    suspendEvents = 0,                                                // 42\n                                                                       // 43\n\t    forEachNode = createNodeIterator(),                               // 44\n\t    createLink = options.uniqueLinkId ? createUniqueLink : createSingleLink,\n                                                                       // 46\n\t    // Our graph API provides means to listen to graph changes. Users can subscribe\n\t    // to be notified about changes in the graph by using `on` method. However\n\t    // in some cases they don't use it. To avoid unnecessary memory consumption\n\t    // we will not record graph changes until we have at least one subscriber.\n\t    // Code below supports this optimization.                         // 51\n\t    //                                                                // 52\n\t    // Accumulates all changes made during graph updates.             // 53\n\t    // Each change element contains:                                  // 54\n\t    //  changeType - one of the strings: 'add', 'remove' or 'update';\n\t    //  node - if change is related to node this property is set to changed graph's node;\n\t    //  link - if change is related to link this property is set to changed graph's link;\n\t    changes = [],                                                     // 58\n\t    recordLinkChange = noop,                                          // 59\n\t    recordNodeChange = noop,                                          // 60\n\t    enterModification = noop,                                         // 61\n\t    exitModification = noop;                                          // 62\n                                                                       // 63\n\t  // this is our public API:                                          // 64\n\t  var graphPart = {                                                   // 65\n\t    /**                                                               // 66\n\t     * Adds node to the graph. If node with given id already exists in the graph\n\t     * its data is extended with whatever comes in 'data' argument.   // 68\n\t     *                                                                // 69\n\t     * @param nodeId the node's identifier. A string or number is preferred.\n\t     * @param [data] additional data for the node being added. If node already\n\t     *   exists its data object is augmented with the new one.        // 72\n\t     *                                                                // 73\n\t     * @return {node} The newly added node or node with given id if it already exists.\n\t     */                                                               // 75\n\t    addNode: addNode,                                                 // 76\n                                                                       // 77\n\t    /**                                                               // 78\n\t     * Adds a link to the graph. The function always create a new     // 79\n\t     * link between two nodes. If one of the nodes does not exists    // 80\n\t     * a new node is created.                                         // 81\n\t     *                                                                // 82\n\t     * @param fromId link start node id;                              // 83\n\t     * @param toId link end node id;                                  // 84\n\t     * @param [data] additional data to be set on the new link;       // 85\n\t     *                                                                // 86\n\t     * @return {link} The newly created link                          // 87\n\t     */                                                               // 88\n\t    addLink: addLink,                                                 // 89\n                                                                       // 90\n\t    /**                                                               // 91\n\t     * Removes link from the graph. If link does not exist does nothing.\n\t     *                                                                // 93\n\t     * @param link - object returned by addLink() or getLinks() methods.\n\t     *                                                                // 95\n\t     * @returns true if link was removed; false otherwise.            // 96\n\t     */                                                               // 97\n\t    removeLink: removeLink,                                           // 98\n                                                                       // 99\n\t    /**                                                               // 100\n\t     * Removes node with given id from the graph. If node does not exist in the graph\n\t     * does nothing.                                                  // 102\n\t     *                                                                // 103\n\t     * @param nodeId node's identifier passed to addNode() function.  // 104\n\t     *                                                                // 105\n\t     * @returns true if node was removed; false otherwise.            // 106\n\t     */                                                               // 107\n\t    removeNode: removeNode,                                           // 108\n                                                                       // 109\n\t    /**                                                               // 110\n\t     * Gets node with given identifier. If node does not exist undefined value is returned.\n\t     *                                                                // 112\n\t     * @param nodeId requested node identifier;                       // 113\n\t     *                                                                // 114\n\t     * @return {node} in with requested identifier or undefined if no such node exists.\n\t     */                                                               // 116\n\t    getNode: getNode,                                                 // 117\n                                                                       // 118\n\t    /**                                                               // 119\n\t     * Gets number of nodes in this graph.                            // 120\n\t     *                                                                // 121\n\t     * @return number of nodes in the graph.                          // 122\n\t     */                                                               // 123\n\t    getNodesCount: function() {                                       // 124\n\t      return nodesCount;                                              // 125\n\t    },                                                                // 126\n                                                                       // 127\n\t    /**                                                               // 128\n\t     * Gets total number of links in the graph.                       // 129\n\t     */                                                               // 130\n\t    getLinksCount: function() {                                       // 131\n\t      return links.length;                                            // 132\n\t    },                                                                // 133\n                                                                       // 134\n\t    /**                                                               // 135\n\t     * Gets all links (inbound and outbound) from the node with given id.\n\t     * If node with given id is not found null is returned.           // 137\n\t     *                                                                // 138\n\t     * @param nodeId requested node identifier.                       // 139\n\t     *                                                                // 140\n\t     * @return Array of links from and to requested node if such node exists;\n\t     *   otherwise null is returned.                                  // 142\n\t     */                                                               // 143\n\t    getLinks: getLinks,                                               // 144\n                                                                       // 145\n\t    /**                                                               // 146\n\t     * Invokes callback on each node of the graph.                    // 147\n\t     *                                                                // 148\n\t     * @param {Function(node)} callback Function to be invoked. The function\n\t     *   is passed one argument: visited node.                        // 150\n\t     */                                                               // 151\n\t    forEachNode: forEachNode,                                         // 152\n                                                                       // 153\n\t    /**                                                               // 154\n\t     * Invokes callback on every linked (adjacent) node to the given one.\n\t     *                                                                // 156\n\t     * @param nodeId Identifier of the requested node.                // 157\n\t     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n\t     *   The function is passed two parameters: adjacent node and link object itself.\n\t     * @param oriented if true graph treated as oriented.             // 160\n\t     */                                                               // 161\n\t    forEachLinkedNode: forEachLinkedNode,                             // 162\n                                                                       // 163\n\t    /**                                                               // 164\n\t     * Enumerates all links in the graph                              // 165\n\t     *                                                                // 166\n\t     * @param {Function(link)} callback Function to be called on all links in the graph.\n\t     *   The function is passed one parameter: graph's link object.   // 168\n\t     *                                                                // 169\n\t     * Link object contains at least the following fields:            // 170\n\t     *  fromId - node id where link starts;                           // 171\n\t     *  toId - node id where link ends,                               // 172\n\t     *  data - additional data passed to graph.addLink() method.      // 173\n\t     */                                                               // 174\n\t    forEachLink: forEachLink,                                         // 175\n                                                                       // 176\n\t    /**                                                               // 177\n\t     * Suspend all notifications about graph changes until            // 178\n\t     * endUpdate is called.                                           // 179\n\t     */                                                               // 180\n\t    beginUpdate: enterModification,                                   // 181\n                                                                       // 182\n\t    /**                                                               // 183\n\t     * Resumes all notifications about graph changes and fires        // 184\n\t     * graph 'changed' event in case there are any pending changes.   // 185\n\t     */                                                               // 186\n\t    endUpdate: exitModification,                                      // 187\n                                                                       // 188\n\t    /**                                                               // 189\n\t     * Removes all nodes and links from the graph.                    // 190\n\t     */                                                               // 191\n\t    clear: clear,                                                     // 192\n                                                                       // 193\n\t    /**                                                               // 194\n\t     * Detects whether there is a link between two nodes.             // 195\n\t     * Operation complexity is O(n) where n - number of links of a node.\n\t     * NOTE: this function is synonim for getLink()                   // 197\n\t     *                                                                // 198\n\t     * @returns link if there is one. null otherwise.                 // 199\n\t     */                                                               // 200\n\t    hasLink: getLink,                                                 // 201\n                                                                       // 202\n\t    /**                                                               // 203\n\t     * Gets an edge between two nodes.                                // 204\n\t     * Operation complexity is O(n) where n - number of links of a node.\n\t     *                                                                // 206\n\t     * @param {string} fromId link start identifier                   // 207\n\t     * @param {string} toId link end identifier                       // 208\n\t     *                                                                // 209\n\t     * @returns link if there is one. null otherwise.                 // 210\n\t     */                                                               // 211\n\t    getLink: getLink                                                  // 212\n\t  };                                                                  // 213\n                                                                       // 214\n\t  // this will add `on()` and `fire()` methods.                       // 215\n\t  eventify(graphPart);                                                // 216\n                                                                       // 217\n\t  monitorSubscribers();                                               // 218\n                                                                       // 219\n\t  return graphPart;                                                   // 220\n                                                                       // 221\n\t  function monitorSubscribers() {                                     // 222\n\t    var realOn = graphPart.on;                                        // 223\n                                                                       // 224\n\t    // replace real `on` with our temporary on, which will trigger change\n\t    // modification monitoring:                                       // 226\n\t    graphPart.on = on;                                                // 227\n                                                                       // 228\n\t    function on() {                                                   // 229\n\t      // now it's time to start tracking stuff:                       // 230\n\t      graphPart.beginUpdate = enterModification = enterModificationReal;\n\t      graphPart.endUpdate = exitModification = exitModificationReal;  // 232\n\t      recordLinkChange = recordLinkChangeReal;                        // 233\n\t      recordNodeChange = recordNodeChangeReal;                        // 234\n                                                                       // 235\n\t      // this will replace current `on` method with real pub/sub from `eventify`.\n\t      graphPart.on = realOn;                                          // 237\n\t      // delegate to real `on` handler:                               // 238\n\t      return realOn.apply(graphPart, arguments);                      // 239\n\t    }                                                                 // 240\n\t  }                                                                   // 241\n                                                                       // 242\n\t  function recordLinkChangeReal(link, changeType) {                   // 243\n\t    changes.push({                                                    // 244\n\t      link: link,                                                     // 245\n\t      changeType: changeType                                          // 246\n\t    });                                                               // 247\n\t  }                                                                   // 248\n                                                                       // 249\n\t  function recordNodeChangeReal(node, changeType) {                   // 250\n\t    changes.push({                                                    // 251\n\t      node: node,                                                     // 252\n\t      changeType: changeType                                          // 253\n\t    });                                                               // 254\n\t  }                                                                   // 255\n                                                                       // 256\n\t  function addNode(nodeId, data) {                                    // 257\n\t    if (nodeId === undefined) {                                       // 258\n\t      throw new Error('Invalid node identifier');                     // 259\n\t    }                                                                 // 260\n                                                                       // 261\n\t    enterModification();                                              // 262\n                                                                       // 263\n\t    var node = getNode(nodeId);                                       // 264\n\t    if (!node) {                                                      // 265\n\t      node = new Node(nodeId);                                        // 266\n\t      nodesCount++;                                                   // 267\n\t      recordNodeChange(node, 'add');                                  // 268\n\t    } else {                                                          // 269\n\t      recordNodeChange(node, 'update');                               // 270\n\t    }                                                                 // 271\n                                                                       // 272\n\t    node.data = data;                                                 // 273\n                                                                       // 274\n\t    nodes[nodeId] = node;                                             // 275\n                                                                       // 276\n\t    exitModification();                                               // 277\n\t    return node;                                                      // 278\n\t  }                                                                   // 279\n                                                                       // 280\n\t  function getNode(nodeId) {                                          // 281\n\t    return nodes[nodeId];                                             // 282\n\t  }                                                                   // 283\n                                                                       // 284\n\t  function removeNode(nodeId) {                                       // 285\n\t    var node = getNode(nodeId);                                       // 286\n\t    if (!node) {                                                      // 287\n\t      return false;                                                   // 288\n\t    }                                                                 // 289\n                                                                       // 290\n\t    enterModification();                                              // 291\n                                                                       // 292\n\t    if (node.links) {                                                 // 293\n\t      while (node.links.length) {                                     // 294\n\t        var link = node.links[0];                                     // 295\n\t        removeLink(link);                                             // 296\n\t      }                                                               // 297\n\t    }                                                                 // 298\n                                                                       // 299\n\t    delete nodes[nodeId];                                             // 300\n\t    nodesCount--;                                                     // 301\n                                                                       // 302\n\t    recordNodeChange(node, 'remove');                                 // 303\n                                                                       // 304\n\t    exitModification();                                               // 305\n                                                                       // 306\n\t    return true;                                                      // 307\n\t  }                                                                   // 308\n                                                                       // 309\n                                                                       // 310\n\t  function addLink(fromId, toId, data) {                              // 311\n\t    enterModification();                                              // 312\n                                                                       // 313\n\t    var fromNode = getNode(fromId) || addNode(fromId);                // 314\n\t    var toNode = getNode(toId) || addNode(toId);                      // 315\n                                                                       // 316\n\t    var link = createLink(fromId, toId, data);                        // 317\n                                                                       // 318\n\t    links.push(link);                                                 // 319\n                                                                       // 320\n\t    // TODO: this is not cool. On large graphs potentially would consume more memory.\n\t    addLinkToNode(fromNode, link);                                    // 322\n\t    if (fromId !== toId) {                                            // 323\n\t      // make sure we are not duplicating links for self-loops        // 324\n\t      addLinkToNode(toNode, link);                                    // 325\n\t    }                                                                 // 326\n                                                                       // 327\n\t    recordLinkChange(link, 'add');                                    // 328\n                                                                       // 329\n\t    exitModification();                                               // 330\n                                                                       // 331\n\t    return link;                                                      // 332\n\t  }                                                                   // 333\n                                                                       // 334\n\t  function createSingleLink(fromId, toId, data) {                     // 335\n\t    var linkId = makeLinkId(fromId, toId);                            // 336\n\t    return new Link(fromId, toId, data, linkId);                      // 337\n\t  }                                                                   // 338\n                                                                       // 339\n\t  function createUniqueLink(fromId, toId, data) {                     // 340\n\t    // TODO: Get rid of this method.                                  // 341\n\t    var linkId = makeLinkId(fromId, toId);                            // 342\n\t    var isMultiEdge = multiEdges.hasOwnProperty(linkId);              // 343\n\t    if (isMultiEdge || getLink(fromId, toId)) {                       // 344\n\t      if (!isMultiEdge) {                                             // 345\n\t        multiEdges[linkId] = 0;                                       // 346\n\t      }                                                               // 347\n\t      var suffix = '@' + (++multiEdges[linkId]);                      // 348\n\t      linkId = makeLinkId(fromId + suffix, toId + suffix);            // 349\n\t    }                                                                 // 350\n                                                                       // 351\n\t    return new Link(fromId, toId, data, linkId);                      // 352\n\t  }                                                                   // 353\n                                                                       // 354\n\t  function getLinks(nodeId) {                                         // 355\n\t    var node = getNode(nodeId);                                       // 356\n\t    return node ? node.links : null;                                  // 357\n\t  }                                                                   // 358\n                                                                       // 359\n\t  function removeLink(link) {                                         // 360\n\t    if (!link) {                                                      // 361\n\t      return false;                                                   // 362\n\t    }                                                                 // 363\n\t    var idx = indexOfElementInArray(link, links);                     // 364\n\t    if (idx < 0) {                                                    // 365\n\t      return false;                                                   // 366\n\t    }                                                                 // 367\n                                                                       // 368\n\t    enterModification();                                              // 369\n                                                                       // 370\n\t    links.splice(idx, 1);                                             // 371\n                                                                       // 372\n\t    var fromNode = getNode(link.fromId);                              // 373\n\t    var toNode = getNode(link.toId);                                  // 374\n                                                                       // 375\n\t    if (fromNode) {                                                   // 376\n\t      idx = indexOfElementInArray(link, fromNode.links);              // 377\n\t      if (idx >= 0) {                                                 // 378\n\t        fromNode.links.splice(idx, 1);                                // 379\n\t      }                                                               // 380\n\t    }                                                                 // 381\n                                                                       // 382\n\t    if (toNode) {                                                     // 383\n\t      idx = indexOfElementInArray(link, toNode.links);                // 384\n\t      if (idx >= 0) {                                                 // 385\n\t        toNode.links.splice(idx, 1);                                  // 386\n\t      }                                                               // 387\n\t    }                                                                 // 388\n                                                                       // 389\n\t    recordLinkChange(link, 'remove');                                 // 390\n                                                                       // 391\n\t    exitModification();                                               // 392\n                                                                       // 393\n\t    return true;                                                      // 394\n\t  }                                                                   // 395\n                                                                       // 396\n\t  function getLink(fromNodeId, toNodeId) {                            // 397\n\t    // TODO: Use sorted links to speed this up                        // 398\n\t    var node = getNode(fromNodeId),                                   // 399\n\t      i;                                                              // 400\n\t    if (!node || !node.links) {                                       // 401\n\t      return null;                                                    // 402\n\t    }                                                                 // 403\n                                                                       // 404\n\t    for (i = 0; i < node.links.length; ++i) {                         // 405\n\t      var link = node.links[i];                                       // 406\n\t      if (link.fromId === fromNodeId && link.toId === toNodeId) {     // 407\n\t        return link;                                                  // 408\n\t      }                                                               // 409\n\t    }                                                                 // 410\n                                                                       // 411\n\t    return null; // no link.                                          // 412\n\t  }                                                                   // 413\n                                                                       // 414\n\t  function clear() {                                                  // 415\n\t    enterModification();                                              // 416\n\t    forEachNode(function(node) {                                      // 417\n\t      removeNode(node.id);                                            // 418\n\t    });                                                               // 419\n\t    exitModification();                                               // 420\n\t  }                                                                   // 421\n                                                                       // 422\n\t  function forEachLink(callback) {                                    // 423\n\t    var i, length;                                                    // 424\n\t    if (typeof callback === 'function') {                             // 425\n\t      for (i = 0, length = links.length; i < length; ++i) {           // 426\n\t        callback(links[i]);                                           // 427\n\t      }                                                               // 428\n\t    }                                                                 // 429\n\t  }                                                                   // 430\n                                                                       // 431\n\t  function forEachLinkedNode(nodeId, callback, oriented) {            // 432\n\t    var node = getNode(nodeId);                                       // 433\n                                                                       // 434\n\t    if (node && node.links && typeof callback === 'function') {       // 435\n\t      if (oriented) {                                                 // 436\n\t        return forEachOrientedLink(node.links, nodeId, callback);     // 437\n\t      } else {                                                        // 438\n\t        return forEachNonOrientedLink(node.links, nodeId, callback);  // 439\n\t      }                                                               // 440\n\t    }                                                                 // 441\n\t  }                                                                   // 442\n                                                                       // 443\n\t  function forEachNonOrientedLink(links, nodeId, callback) {          // 444\n\t    var quitFast;                                                     // 445\n\t    for (var i = 0; i < links.length; ++i) {                          // 446\n\t      var link = links[i];                                            // 447\n\t      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n                                                                       // 449\n\t      quitFast = callback(nodes[linkedNodeId], link);                 // 450\n\t      if (quitFast) {                                                 // 451\n\t        return true; // Client does not need more iterations. Break now.\n\t      }                                                               // 453\n\t    }                                                                 // 454\n\t  }                                                                   // 455\n                                                                       // 456\n\t  function forEachOrientedLink(links, nodeId, callback) {             // 457\n\t    var quitFast;                                                     // 458\n\t    for (var i = 0; i < links.length; ++i) {                          // 459\n\t      var link = links[i];                                            // 460\n\t      if (link.fromId === nodeId) {                                   // 461\n\t        quitFast = callback(nodes[link.toId], link);                  // 462\n\t        if (quitFast) {                                               // 463\n\t          return true; // Client does not need more iterations. Break now.\n\t        }                                                             // 465\n\t      }                                                               // 466\n\t    }                                                                 // 467\n\t  }                                                                   // 468\n                                                                       // 469\n\t  // we will not fire anything until users of this library explicitly call `on()`\n\t  // method.                                                          // 471\n\t  function noop() {}                                                  // 472\n                                                                       // 473\n\t  // Enter, Exit modification allows bulk graph updates without firing events.\n\t  function enterModificationReal() {                                  // 475\n\t    suspendEvents += 1;                                               // 476\n\t  }                                                                   // 477\n                                                                       // 478\n\t  function exitModificationReal() {                                   // 479\n\t    suspendEvents -= 1;                                               // 480\n\t    if (suspendEvents === 0 && changes.length > 0) {                  // 481\n\t      graphPart.fire('changed', changes);                             // 482\n\t      changes.length = 0;                                             // 483\n\t    }                                                                 // 484\n\t  }                                                                   // 485\n                                                                       // 486\n\t  function createNodeIterator() {                                     // 487\n\t    // Object.keys iterator is 1.3x faster than `for in` loop.        // 488\n\t    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n\t    // branch for perf test                                           // 490\n\t    return Object.keys ? objectKeysIterator : forInIterator;          // 491\n\t  }                                                                   // 492\n                                                                       // 493\n\t  function objectKeysIterator(callback) {                             // 494\n\t    if (typeof callback !== 'function') {                             // 495\n\t      return;                                                         // 496\n\t    }                                                                 // 497\n                                                                       // 498\n\t    var keys = Object.keys(nodes);                                    // 499\n\t    for (var i = 0; i < keys.length; ++i) {                           // 500\n\t      if (callback(nodes[keys[i]])) {                                 // 501\n\t        return true; // client doesn't want to proceed. Return.       // 502\n\t      }                                                               // 503\n\t    }                                                                 // 504\n\t  }                                                                   // 505\n                                                                       // 506\n\t  function forInIterator(callback) {                                  // 507\n\t    if (typeof callback !== 'function') {                             // 508\n\t      return;                                                         // 509\n\t    }                                                                 // 510\n\t    var node;                                                         // 511\n                                                                       // 512\n\t    for (node in nodes) {                                             // 513\n\t      if (callback(nodes[node])) {                                    // 514\n\t        return true; // client doesn't want to proceed. Return.       // 515\n\t      }                                                               // 516\n\t    }                                                                 // 517\n\t  }                                                                   // 518\n\t}                                                                     // 519\n                                                                       // 520\n\t// need this for old browsers. Should this be a separate module?      // 521\n\tfunction indexOfElementInArray(element, array) {                      // 522\n\t  if (!array) return -1;                                              // 523\n                                                                       // 524\n\t  if (array.indexOf) {                                                // 525\n\t    return array.indexOf(element);                                    // 526\n\t  }                                                                   // 527\n                                                                       // 528\n\t  var len = array.length,                                             // 529\n\t    i;                                                                // 530\n                                                                       // 531\n\t  for (i = 0; i < len; i += 1) {                                      // 532\n\t    if (array[i] === element) {                                       // 533\n\t      return i;                                                       // 534\n\t    }                                                                 // 535\n\t  }                                                                   // 536\n                                                                       // 537\n\t  return -1;                                                          // 538\n\t}                                                                     // 539\n                                                                       // 540\n\t/**                                                                   // 541\n\t * Internal structure to represent node;                              // 542\n\t */                                                                   // 543\n\tfunction Node(id) {                                                   // 544\n\t  this.id = id;                                                       // 545\n\t  this.links = null;                                                  // 546\n\t  this.data = null;                                                   // 547\n\t}                                                                     // 548\n                                                                       // 549\n\tfunction addLinkToNode(node, link) {                                  // 550\n\t  if (node.links) {                                                   // 551\n\t    node.links.push(link);                                            // 552\n\t  } else {                                                            // 553\n\t    node.links = [link];                                              // 554\n\t  }                                                                   // 555\n\t}                                                                     // 556\n                                                                       // 557\n\t/**                                                                   // 558\n\t * Internal structure to represent links;                             // 559\n\t */                                                                   // 560\n\tfunction Link(fromId, toId, data, id) {                               // 561\n\t  this.fromId = fromId;                                               // 562\n\t  this.toId = toId;                                                   // 563\n\t  this.data = data;                                                   // 564\n\t  this.id = id;                                                       // 565\n\t}                                                                     // 566\n                                                                       // 567\n\tfunction hashCode(str) {                                              // 568\n\t  var hash = 0, i, chr, len;                                          // 569\n\t  if (str.length == 0) return hash;                                   // 570\n\t  for (i = 0, len = str.length; i < len; i++) {                       // 571\n\t    chr   = str.charCodeAt(i);                                        // 572\n\t    hash  = ((hash << 5) - hash) + chr;                               // 573\n\t    hash |= 0; // Convert to 32bit integer                            // 574\n\t  }                                                                   // 575\n\t  return hash;                                                        // 576\n\t}                                                                     // 577\n                                                                       //\n\tfunction makeLinkId(fromId, toId) {                                   //\n\t  return hashCode(fromId.toString() + ' ' + toId.toString());       //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 47 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar createRandomIterator = __webpack_require__(18).randomIterator;    // 5\n\tvar createRandom = __webpack_require__(18).random;                    // 6\n                                                                       // 7\n\tmodule.exports = createChineseWhisper;                                // 8\n                                                                       // 9\n\tfunction createChineseWhisper(graph, kind) {                          // 10\n\t  var api = {                                                         // 11\n\t    step: step,                                                       // 12\n\t    getClass: getClass,                                               // 13\n\t    getChangeRate: getChangeRate,                                     // 14\n\t    forEachCluster: forEachCluster,                                   // 15\n\t    createClusterMap: createClusterMap                                // 16\n\t  };                                                                  // 17\n                                                                       // 18\n\t  var changeRate = 1;                                                 // 19\n\t  var classChangesCount = 0;                                          // 20\n\t  var random = createRandom(42);                                      // 21\n\t  var iterator;                                                       // 22\n\t  var classMap = new Map();                                           // 23\n\t  var nodeIds = [];                                                   // 24\n                                                                       // 25\n\t  initInternalStructures();                                           // 26\n                                                                       // 27\n\t  return api;                                                         // 28\n                                                                       // 29\n\t  function step() {                                                   // 30\n\t    classChangesCount = 0;                                            // 31\n\t    iterator.forEach(assignHighestClass);                             // 32\n\t    changeRate = classChangesCount/nodeIds.length;                    // 33\n\t  }                                                                   // 34\n                                                                       // 35\n\t  function getChangeRate() {                                          // 36\n\t    return changeRate;                                                // 37\n\t  }                                                                   // 38\n                                                                       // 39\n\t  function getClass(nodeId) {                                         // 40\n\t    return classMap.get(nodeId);                                      // 41\n\t  }                                                                   // 42\n                                                                       // 43\n\t  function initInternalStructures() {                                 // 44\n\t    graph.forEachNode(initNodeClass);                                 // 45\n\t    iterator = createRandomIterator(nodeIds, random);                 // 46\n                                                                       // 47\n\t    function initNodeClass(node) {                                    // 48\n\t      classMap.set(node.id, nodeIds.length);                          // 49\n\t      nodeIds.push(node.id);                                          // 50\n\t    }                                                                 // 51\n\t  }                                                                   // 52\n                                                                       // 53\n\t  function assignHighestClass(nodeId) {                               // 54\n\t    var newLevel = getHighestClassInTheNeighborhoodOf(nodeId);        // 55\n\t    var currentLevel = classMap.get(nodeId);                          // 56\n\t    if (newLevel !== currentLevel) {                                  // 57\n\t      classMap.set(nodeId, newLevel);                                 // 58\n\t      classChangesCount += 1;                                         // 59\n\t    }                                                                 // 60\n\t  }                                                                   // 61\n                                                                       // 62\n\t  function getHighestClassInTheNeighborhoodOf(nodeId) {               // 63\n\t    var seenClasses = new Map();                                      // 64\n\t    var maxClassValue = 0;                                            // 65\n\t    var maxClassName = -1;                                            // 66\n                                                                       // 67\n\t    graph.forEachLinkedNode(nodeId, visitNeighbour);                  // 68\n                                                                       // 69\n\t    if (maxClassName === -1) {                                        // 70\n\t      // the node didn't have any neighbours                          // 71\n\t      return classMap.get(nodeId);                                    // 72\n\t    }                                                                 // 73\n                                                                       // 74\n\t    return maxClassName;                                              // 75\n                                                                       // 76\n\t    function visitNeighbour(otherNode, link) {                        // 77\n\t      if (shouldUpdate(link.toId === nodeId)) {                       // 78\n\t        var otherNodeClass = classMap.get(otherNode.id);              // 79\n\t        var counter = seenClasses.get(otherNodeClass) || 0;           // 80\n\t        counter += 1;                                                 // 81\n\t        if (counter > maxClassValue) {                                // 82\n\t          maxClassValue = counter;                                    // 83\n\t          maxClassName = otherNodeClass;                              // 84\n\t        }                                                             // 85\n                                                                       // 86\n\t        seenClasses.set(otherNodeClass, counter);                     // 87\n\t      }                                                               // 88\n\t    }                                                                 // 89\n\t  }                                                                   // 90\n                                                                       // 91\n\t  function shouldUpdate(isInLink) {                                   // 92\n\t    if (kind === 'in') return isInLink;                               // 93\n\t    if (kind === 'out') return !isInLink;                             // 94\n\t    return true;                                                      // 95\n\t  }                                                                   // 96\n                                                                       // 97\n\t  function createClusterMap() {                                       // 98\n\t    var clusters = new Map();                                         // 99\n                                                                       // 100\n\t    for (var i = 0; i < nodeIds.length; ++i) {                        // 101\n\t      var nodeId = nodeIds[i];                                        // 102\n\t      var clusterId = getClass(nodeId);                               // 103\n\t      var nodesInCluster = clusters.get(clusterId);                   // 104\n\t      if (nodesInCluster) nodesInCluster.push(nodeId);                // 105\n\t      else clusters.set(clusterId, [nodeId]);                         // 106\n\t    }                                                                 // 107\n                                                                       // 108\n\t    return clusters;                                                  // 109\n\t  }                                                                   // 110\n                                                                       // 111\n\t  function forEachCluster(cb) {                                       // 112\n\t    var clusters = createClusterMap();                                // 113\n                                                                       // 114\n\t    clusters.forEach(reportToClient);                                 // 115\n                                                                       // 116\n\t    function reportToClient(value, key) {                             // 117\n\t      cb({                                                            // 118\n\t        class: key,                                                   // 119\n\t        nodes: value                                                  // 120\n\t      });                                                             //\n\t    }                                                                 //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 48 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar createGraph = __webpack_require__(46);                            // 5\n                                                                       // 6\n\tmodule.exports = coarsen;                                             // 7\n                                                                       // 8\n\tfunction coarsen(srcGraph, community) {                               // 9\n\t  if (typeof community.canCoarse === 'function') {                    // 10\n\t    if (!community.canCoarse()) {                                     // 11\n\t       console.warn('Cannot coarse anymore');                         // 12\n\t    }                                                                 // 13\n\t  }                                                                   // 14\n                                                                       // 15\n\t  var graph = createGraph({                                           // 16\n\t    uniqueLinkId: false                                               // 17\n\t  });                                                                 // 18\n                                                                       // 19\n\t  srcGraph.forEachLink(function(srcLink) {                            // 20\n\t    var fromCommunity = community.getClass(srcLink.fromId);           // 21\n\t    var toCommunity = community.getClass(srcLink.toId);               // 22\n                                                                       // 23\n\t    if (fromCommunity === toCommunity) {                              // 24\n\t      makeSureNodeAdded(fromCommunity, srcLink.fromId);               // 25\n\t      makeSureNodeAdded(fromCommunity, srcLink.toId);                 // 26\n\t    } else {                                                          // 27\n\t      makeSureNodeAdded(fromCommunity, srcLink.fromId);               // 28\n\t      makeSureNodeAdded(toCommunity, srcLink.toId);                   // 29\n\t    }                                                                 // 30\n                                                                       // 31\n\t    var link = graph.getLink(fromCommunity, toCommunity);             // 32\n\t    if (!link) link = graph.addLink(fromCommunity, toCommunity, 0);   // 33\n\t    link.data += getWeight(srcLink.data);                             // 34\n\t  });                                                                 // 35\n                                                                       // 36\n\t  return graph;                                                       // 37\n                                                                       // 38\n\t  function makeSureNodeAdded(nodeId, srcNodeId) {                     // 39\n\t    var node = graph.getNode(nodeId);                                 // 40\n\t    if (!node) node = graph.addNode(nodeId, new Set());               // 41\n                                                                       // 42\n\t    node.data.add(srcNodeId);                                         // 43\n                                                                       // 44\n\t    return node;                                                      // 45\n\t  }                                                                   // 46\n\t}                                                                     // 47\n                                                                       // 48\n\tfunction getWeight(data) {                                            // 49\n\t  if (!data) return 1;                                                // 50\n                                                                       // 51\n\t  if (typeof data === 'number') return data;                          // 52\n\t  if (typeof data.weight === 'number') return data.weight;            //\n                                                                       //\n\t  return 1;                                                           //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 49 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 // 3\n                                                                       // 4\n\tvar DisjointSet = __webpack_require__(50);                            // 5\n\tmodule.exports = kruskal;                                             // 6\n                                                                       // 7\n\tfunction kruskal(graph, getWeight) {                                  // 8\n\t  var tree = [];                                                      // 9\n\t  getWeight = getWeight || uniformWeight;                             // 10\n\t  // map of disjoint sets for quick lookup                            // 11\n\t  var nodes = new Map();                                              // 12\n\t  // Sorted array of edges by their weight                            // 13\n\t  var links = [];                                                     // 14\n                                                                       // 15\n\t  graph.forEachNode(initSet);                                         // 16\n\t  graph.forEachLink(initLink);                                        // 17\n\t  links.sort(byWeight);                                               // 18\n                                                                       // 19\n\t  for (var i = 0; i < links.length; ++i) {                            // 20\n\t    var fromId = links[i].fromId;                                     // 21\n\t    var toId = links[i].toId;                                         // 22\n\t    var fromSet = nodes.get(fromId);                                  // 23\n\t    var toSet = nodes.get(toId);                                      // 24\n\t    if (fromSet.find() !== toSet.find()) {                            // 25\n\t      tree.push(new TreeNode(fromId, toId));                          // 26\n\t      fromSet.union(toSet);                                           // 27\n\t    }                                                                 // 28\n\t  }                                                                   // 29\n                                                                       // 30\n\t  return tree;                                                        // 31\n                                                                       // 32\n\t  function initLink(link) {                                           // 33\n\t    links.push(link);                                                 // 34\n\t  }                                                                   // 35\n                                                                       // 36\n\t  function initSet(node) {                                            // 37\n\t    nodes.set(node.id, new DisjointSet(node.id));                     // 38\n\t  }                                                                   // 39\n                                                                       // 40\n\t  function byWeight(x, y) {                                           // 41\n\t    return getWeight(x) - getWeight(y);                               // 42\n\t  }                                                                   // 43\n\t}                                                                     // 44\n                                                                       // 45\n\tfunction uniformWeight(link) {                                        // 46\n\t  return 1;                                                           // 47\n\t}                                                                     // 48\n                                                                       // 49\n\tfunction TreeNode(fromId, toId) {                                     //\n\t  this.fromId = fromId;                                               //\n\t  this.toId = toId;                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 50 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = DisjointSet;                                         // 5\n                                                                       // 6\n\tfunction DisjointSet(payload) {                                       // 7\n\t  this.payload = payload;                                             // 8\n\t  this.parent = this;                                                 // 9\n\t  this.rank = 0;                                                      // 10\n\t}                                                                     // 11\n                                                                       // 12\n\tDisjointSet.prototype.find = find;                                    // 13\n\tDisjointSet.prototype.union = union;                                  // 14\n                                                                       // 15\n\tfunction find() {                                                     // 16\n\t  var parent = this.parent;                                           // 17\n\t  if (parent !== this) {                                              // 18\n\t    // compress so that in future we ran faster:                      // 19\n\t    this.parent = parent.find();                                      // 20\n\t  }                                                                   // 21\n                                                                       // 22\n\t  return this.parent;                                                 // 23\n\t}                                                                     // 24\n                                                                       // 25\n\tfunction union(y) {                                                   // 26\n\t  var ourParent = this.find();                                        // 27\n\t  var theirParent = y.find();                                         // 28\n                                                                       // 29\n\t  if (theirParent === ourParent) return; // we are in the same set    // 30\n                                                                       // 31\n\t  if (ourParent.rank < theirParent.rank) {                            // 32\n\t    ourParent.parent = theirParent;                                   // 33\n\t  } else if (ourParent.rank > theirParent.rank) {                     // 34\n\t    theirParent.parent = ourParent;                                   // 35\n\t  } else {                                                            // 36\n\t    theirParent.parent = ourParent;                                   //\n\t    ourParent.rank += 1;                                              //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 51 */                                                               // 2\n/***/ function(module, exports, __webpack_require__) {                 //\n                                                                       //\n\tmodule.exports.degree = __webpack_require__(52);                      //\n\tmodule.exports.betweenness = __webpack_require__(53);                 //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 52 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = degree;                                              // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * Calculates graph nodes degree centrality (in/out or both).         // 8\n\t *                                                                    // 9\n\t * @see http://en.wikipedia.org/wiki/Centrality#Degree_centrality     // 10\n\t *                                                                    // 11\n\t * @param {ngraph.graph} graph object for which we are calculating centrality.\n\t * @param {string} [kind=both] What kind of degree centrality needs to be calculated:\n\t *   'in'    - calculate in-degree centrality                         // 14\n\t *   'out'   - calculate out-degree centrality                        // 15\n\t *   'inout' - (default) generic degree centrality is calculated      // 16\n\t */                                                                   // 17\n\tfunction degree(graph, kind) {                                        // 18\n\t  var getNodeDegree,                                                  // 19\n\t    sortedDegrees = [],                                               // 20\n\t    result = Object.create(null),                                     // 21\n\t    nodeDegree;                                                       // 22\n                                                                       // 23\n\t  kind = (kind || 'both').toLowerCase();                              // 24\n\t  if (kind === 'both' || kind === 'inout') {                          // 25\n\t    getNodeDegree = inoutDegreeCalculator;                            // 26\n\t  } else if (kind === 'in') {                                         // 27\n\t    getNodeDegree = inDegreeCalculator;                               // 28\n\t  } else if (kind === 'out') {                                        // 29\n\t    getNodeDegree = outDegreeCalculator;                              // 30\n\t  } else {                                                            // 31\n\t    throw new Error('Expected centrality degree kind is: in, out or both');\n\t  }                                                                   // 33\n                                                                       // 34\n\t  graph.forEachNode(calculateNodeDegree);                             // 35\n                                                                       // 36\n\t  return result;                                                      // 37\n                                                                       // 38\n\t  function calculateNodeDegree(node) {                                // 39\n\t    var links = graph.getLinks(node.id);                              // 40\n\t    result[node.id] = getNodeDegree(links, node.id);                  // 41\n\t  }                                                                   // 42\n\t}                                                                     // 43\n                                                                       // 44\n\tfunction inDegreeCalculator(links, nodeId) {                          // 45\n\t  var total = 0;                                                      // 46\n\t  if (!links) return total;                                           // 47\n                                                                       // 48\n\t  for (var i = 0; i < links.length; i += 1) {                         // 49\n\t    total += (links[i].toId === nodeId) ? 1 : 0;                      // 50\n\t  }                                                                   // 51\n\t  return total;                                                       // 52\n\t}                                                                     // 53\n                                                                       // 54\n\tfunction outDegreeCalculator(links, nodeId) {                         // 55\n\t  var total = 0;                                                      // 56\n\t  if (!links) return total;                                           // 57\n                                                                       // 58\n\t  for (var i = 0; i < links.length; i += 1) {                         // 59\n\t    total += (links[i].fromId === nodeId) ? 1 : 0;                    // 60\n\t  }                                                                   // 61\n\t  return total;                                                       // 62\n\t}                                                                     // 63\n                                                                       // 64\n\tfunction inoutDegreeCalculator(links) {                               // 65\n\t  if (!links) return 0;                                               //\n                                                                       //\n\t  return links.length;                                                //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ },                                                               // 1\n/* 53 */                                                               // 2\n/***/ function(module, exports) {                                      // 3\n                                                                       // 4\n\tmodule.exports = betweennes;                                          // 5\n                                                                       // 6\n\t/**                                                                   // 7\n\t * I'm using http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n\t * as a reference for this implementation                             // 9\n\t */                                                                   // 10\n\tfunction betweennes(graph, oriented) {                                // 11\n\t  var Q = [],                                                         // 12\n\t    S = []; // Queue and Stack                                        // 13\n\t  // list of predcessors on shorteest paths from source               // 14\n\t  var pred = Object.create(null);                                     // 15\n\t  // distance from source                                             // 16\n\t  var dist = Object.create(null);                                     // 17\n\t  // number of shortest paths from source to key                      // 18\n\t  var sigma = Object.create(null);                                    // 19\n\t  // dependency of source on key                                      // 20\n\t  var delta = Object.create(null);                                    // 21\n                                                                       // 22\n\t  var currentNode;                                                    // 23\n\t  var centrality = Object.create(null);                               // 24\n                                                                       // 25\n\t  graph.forEachNode(setCentralityToZero);                             // 26\n\t  graph.forEachNode(calculateCentrality);                             // 27\n                                                                       // 28\n\t  if (!oriented) {                                                    // 29\n\t    // The centrality scores need to be divided by two if the graph is not oriented,\n\t    // since all shortest paths are considered twice                  // 31\n\t    Object.keys(centrality).forEach(divideByTwo);                     // 32\n\t  }                                                                   // 33\n                                                                       // 34\n\t  return centrality;                                                  // 35\n                                                                       // 36\n\t  function divideByTwo(key) {                                         // 37\n\t    centrality[key] /= 2;                                             // 38\n\t  }                                                                   // 39\n                                                                       // 40\n\t  function setCentralityToZero(node) {                                // 41\n\t    centrality[node.id] = 0;                                          // 42\n\t  }                                                                   // 43\n                                                                       // 44\n\t  function calculateCentrality(node) {                                // 45\n\t    currentNode = node.id;                                            // 46\n\t    singleSourceShortestPath(currentNode);                            // 47\n\t    accumulate();                                                     // 48\n\t  }                                                                   // 49\n                                                                       // 50\n\t  function accumulate() {                                             // 51\n\t    graph.forEachNode(setDeltaToZero);                                // 52\n\t    while (S.length) {                                                // 53\n\t      var w = S.pop();                                                // 54\n\t      var coeff = (1 + delta[w])/sigma[w];                            // 55\n\t      var predcessors = pred[w];                                      // 56\n\t      for (var idx = 0; idx < predcessors.length; ++idx) {            // 57\n\t        var v = predcessors[idx];                                     // 58\n\t        delta[v] += sigma[v] * coeff;                                 // 59\n\t      }                                                               // 60\n\t      if (w !== currentNode) {                                        // 61\n\t        centrality[w] += delta[w];                                    // 62\n\t      }                                                               // 63\n\t    }                                                                 // 64\n\t  }                                                                   // 65\n                                                                       // 66\n\t  function setDeltaToZero(node) {                                     // 67\n\t    delta[node.id] = 0;                                               // 68\n\t  }                                                                   // 69\n                                                                       // 70\n\t  function singleSourceShortestPath(source) {                         // 71\n\t    graph.forEachNode(initNode);                                      // 72\n\t    dist[source] = 0;                                                 // 73\n\t    sigma[source] = 1;                                                // 74\n\t    Q.push(source);                                                   // 75\n                                                                       // 76\n\t    while (Q.length) {                                                // 77\n\t      var v = Q.shift();                                              // 78\n\t      var dedup = Object.create(null);                                // 79\n\t      S.push(v);                                                      // 80\n\t      graph.forEachLinkedNode(v, toId, oriented);                     // 81\n\t    }                                                                 // 82\n                                                                       // 83\n\t    function toId(otherNode) {                                        // 84\n\t      // NOTE: This code will also consider multi-edges, which are often\n\t      // ignored by popular software (Gephi/NetworkX). Depending on your use\n\t      // case this may not be desired and deduping needs to be performed. To\n\t      // save memory I'm not deduping here...                         // 88\n\t      processNode(otherNode.id);                                      // 89\n\t    }                                                                 // 90\n                                                                       // 91\n\t    function initNode(node) {                                         // 92\n\t      var nodeId = node.id;                                           // 93\n\t      pred[nodeId] = []; // empty list                                // 94\n\t      dist[nodeId] = -1;                                              // 95\n\t      sigma[nodeId] = 0;                                              // 96\n\t    }                                                                 // 97\n                                                                       // 98\n\t    function processNode(w) {                                         // 99\n\t      // path discovery                                               // 100\n\t      if (dist[w] === -1) {                                           // 101\n\t        // Node w is found for the first time                         // 102\n\t        dist[w] = dist[v] + 1;                                        // 103\n\t        Q.push(w);                                                    // 104\n\t      }                                                               // 105\n\t      // path counting                                                // 106\n\t      if (dist[w] === dist[v] + 1) {                                  // 107\n\t        // edge (v, w) on a shortest path                             // 108\n\t        sigma[w] += sigma[v];                                         // 109\n\t        pred[w].push(v);                                              // 110\n\t      }                                                               //\n\t    }                                                                 //\n\t  }                                                                   //\n\t}                                                                     //\n                                                                       //\n                                                                       //\n/***/ }                                                                //\n/******/ ]);                                                           //\n//# sourceMappingURL=server.js.map                                     //\n/////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n","servePath":"/server.js","sourceMap":{"version":3,"sources":["webpack:/webpack/bootstrap e3d99540c6791c6fa0f5","webpack:///src/server.js","webpack:///src/app/server/index.js","webpack:///src/app/server/globals.js","webpack:///src/app/server/methods.js","webpack:///src/app/server/forceAtlas/layout.js","webpack:///~/mkdirp/index.js","webpack:///~/ngraph.forcelayout3d/index.js","webpack:///~/ngraph.forcelayout/index.js","webpack:///~/ngraph.physics.simulator/index.js","webpack:///~/ngraph.physics.simulator/lib/spring.js","webpack:///~/ngraph.expose/index.js","webpack:///~/ngraph.merge/index.js","webpack:///~/ngraph.events/index.js","webpack:///~/ngraph.quadtreebh/index.js","webpack:///~/ngraph.random/index.js","webpack:///~/ngraph.quadtreebh/node.js","webpack:///~/ngraph.quadtreebh/insertStack.js","webpack:///~/ngraph.quadtreebh/isSamePosition.js","webpack:///~/ngraph.physics.simulator/lib/bounds.js","webpack:///~/ngraph.physics.simulator/lib/dragForce.js","webpack:///~/ngraph.physics.simulator/lib/springForce.js","webpack:///~/ngraph.physics.simulator/lib/eulerIntegrator.js","webpack:///~/ngraph.physics.simulator/lib/createBody.js","webpack:///~/ngraph.physics.primitives/index.js","webpack:///~/ngraph.quadtreebh3d/index.js","webpack:///~/ngraph.quadtreebh3d/node.js","webpack:///~/ngraph.quadtreebh3d/insertStack.js","webpack:///~/ngraph.quadtreebh3d/isSamePosition.js","webpack:///~/ngraph.forcelayout3d/lib/bounds.js","webpack:///~/ngraph.forcelayout3d/lib/dragForce.js","webpack:///~/ngraph.forcelayout3d/lib/springForce.js","webpack:///~/ngraph.forcelayout3d/lib/eulerIntegrator.js","webpack:///~/ngraph.forcelayout3d/lib/createBody.js","webpack:///~/ngraph.tobinary/index.js","webpack:///~/ngraph.tobinary/lib/getLabels.js","webpack:///~/ngraph.tobinary/lib/getLinksBuffer.js","webpack:///src/app/server/wordnet/wordnet.js","webpack:///src/app/server/wordnet/index_file.js","webpack:///src/app/server/wordnet/wordnet_file.js","webpack:///src/app/server/wordnet/data_file.js","webpack:///~/wordnet-db/index.js","webpack:///~/ngraph.graph/index.js","webpack:///~/ngraph.cw/index.js","webpack:///~/ngraph.coarsen/index.js","webpack:///~/ngraph.kruskal/index.js","webpack:///~/ngraph.disjoint-set/index.js","webpack:///~/ngraph.centrality/index.js","webpack:///~/ngraph.centrality/src/degree.js","webpack:///~/ngraph.centrality/src/betweenness.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;;;;;ACJA;AACA;AACA;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5CA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/CA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:3500/assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e3d99540c6791c6fa0f5\n **/","'use strict';\n\nvar _reactrouterReactRouterSsr = require('meteor/reactrouter:react-router-ssr');\n\nrequire('app/server');\n\n// Do server-rendering only in production\n// Otherwise, it will break the hot-reload\n// DO NOT REMOVE THIS LINE TO TEST, use: meteor --production\nif (process.env.NODE_ENV === 'production') {\n  // Load Webpack infos for SSR\n  _reactrouterReactRouterSsr.ReactRouterSSR.LoadWebpackStats(WebpackStats);\n\n  require('./routes').default;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/server.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nrequire('./globals');\n\nrequire('./methods');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/index.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\n\nglobal.__dirname = process.env[\"PWD\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/globals.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nvar _meteor = require('meteor/meteor');\n\nvar _layout = require('./forceAtlas/layout');\n\nvar _layout2 = _interopRequireDefault(_layout);\n\nvar _wordnet = require('./wordnet/wordnet');\n\nvar _wordnet2 = _interopRequireDefault(_wordnet);\n\nvar _ngraph = require('ngraph.forcelayout3d');\n\nvar _ngraph2 = _interopRequireDefault(_ngraph);\n\nvar _ngraph3 = require('ngraph.graph');\n\nvar _ngraph4 = _interopRequireDefault(_ngraph3);\n\nvar _ngraph5 = require('ngraph.cw');\n\nvar _ngraph6 = _interopRequireDefault(_ngraph5);\n\nvar _ngraph7 = require('ngraph.coarsen');\n\nvar _ngraph8 = _interopRequireDefault(_ngraph7);\n\nvar _ngraph9 = require('ngraph.kruskal');\n\nvar _ngraph10 = _interopRequireDefault(_ngraph9);\n\nvar _ngraph11 = require('ngraph.centrality');\n\nvar _ngraph12 = _interopRequireDefault(_ngraph11);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar wordnet = new _wordnet2.default(process.cwd() + '/../web.browser/app/dict');\n\nvar graph = null;\n\n_meteor.Meteor.methods({\n  // calculate the layout of the graph before serving it to the client\n  calculateLayout: function calculateLayout() {\n\n    // if the graph hasn't been created\n    // load the data set\n    if (!graph) {\n      HTTP.get(_meteor.Meteor.absoluteUrl('/generated.json'), function (err, result) {\n        // if we don't have an er\n        if (!err && result.data) {\n          (function () {\n            var data = result.data;\n            // call the load function w/ graph data in json,\n            var graph = load(data,\n            // function that returns object w/ id and info_dict[word] from python,\n            function (node) {\n              return {\n                id: node[\"id\"],\n                data: {\n                  definition: node['definition'],\n                  pos: node['pos'],\n                  sense_n: node['sense_n']\n                }\n              };\n            },\n            // function that links two nodes\n            function (link) {\n              return {\n                fromId: data.nodes[link.source].id,\n                toId: data.nodes[link.target].id\n              };\n            });\n\n            graphCallback(graph, true);\n          })();\n        }\n      });\n    } else {\n      graphCallback(graph, false);\n    }\n\n    // pass the graph that was created in ngraph\n    // we don't want to overwrite the previous iterations\n    function graphCallback(graph, overwrite) {\n      // create instance of ngraph.graph w/ chinese whispers graph clustering algorithm\n      //var whisper = createWhisper(graph);\n      //var requiredChangeRate = 0; // 0 is complete convergence\n      ////\n      //while (whisper.getChangeRate() > requiredChangeRate) {\n      //  whisper.step();\n      //}\n      //let coarseGraph = coarsen(graph, whisper);\n      //let index = 0;\n      //coarseGraph.forEachNode(function(node) {\n      //  node.data.forEach(function(id) {\n      //    coarseGraph.addNode(id, {hidden: true, data: graph.getNode(id).data});\n      //    coarseGraph.addLink(node.id, id);\n      //    index++;\n      //  });\n      //});\n\n      //var clusters = whisper.createClusterMap();\n      //// removeLinks for removing links in the graph\n      //var removedLinks = [];\n      //\n      //// use forEach to remove links and cluster\n      //clusters.forEach(visitCluster);\n      //\n      //function visitCluster(clusterNodes, clusterClass) {\n      //  var i;\n      //  for (i = 0; i < clusterNodes.length; ++i) {\n      //    let node = graph.getNode(clusterNodes[i]);\n      //    graph.addNode(node.id, {cluster: clusterClass, info: node.data});\n      //  }\n      //\n      //  for (i = 0; i < clusterNodes.length; ++i) {\n      //    let node = graph.getNode(clusterNodes[i]);\n      //    graph.forEachLinkedNode(node.id,\n      //      function(linkedNode, link) {\n      //        // if the clusters are not the same\n      //        // we remove the link from the graph\n      //        if (linkedNode.data.cluster != node.data.cluster) {\n      //          graph.removeLink(link);\n      //          removedLinks.push(link);\n      //        }\n      //      },\n      //      true\n      //    );\n      //  }\n      //}\n      //\n      //let removedThisIteration;\n      //while (!removedThisIteration || removedThisIteration.length > 0) {\n      //  removedThisIteration = [];\n      //  graph.forEachLink(function(link) {\n      //    if (!link) return;\n      //    let from = graph.getNode(link.fromId);\n      //    let to = graph.getNode(link.toId);\n      //    if (from.data.cluster !== to.data.cluster) {\n      //      graph.removeLink(link);\n      //      removedThisIteration.push(link);\n      //    }\n      //  });\n      //  for (var i = 0; i < removedThisIteration.length; ++i) {\n      //    removedLinks.push(removedThisIteration[i]);\n      //  }\n      //}\n      //// print each connection in the graph w/o being in the same cluster\n      //graph.forEachLink(function(link) {\n      //  let from = graph.getNode(link.fromId);\n      //  let to = graph.getNode(link.toId);\n      //  if (from.data.cluster !== to.data.cluster) {\n      //    console.log({from: from.data.cluster, to: to.data.cluster});\n      //  }\n      //});\n      //\n      //console.log(removedLinks.length);\n\n      //var path = kruskal(graph);\n      //let tree = createGraph();\n      //graph.forEachNode(function(node) {\n      //  tree.addNode(node.id, node.data);\n      //});\n      //for (var i = 0; i < path.length; ++i) {\n      //  let edge = path[i];\n      //  tree.addLink(edge.fromId, edge.toId);\n      //}\n\n      var layout = (0, _layout2.default)(graph, {\n        iterations: 50,\n        saveEach: 25\n      });\n      layout.run(true);\n    }\n  },\n  findSynsets: function findSynsets(word) {\n    var response = Async.runSync(function (done) {\n      wordnet.lookup(word, function (results) {\n        // if there are no results\n        if (results.length === 0) {\n          // render message saying no words were found for 'word'\n          done(null, null);\n        }\n        // console.log(JSON.stringify(results, null, '\\t'));\n        var synsets = [];\n        for (var i = 0; i < results.length; i++) {\n          var synset = results[i];\n          // console.log(synset.lemma, synset.pos);\n          synsets.push({\n            name: synset.lemma,\n            definition: synset.def,\n            synonyms: synset.synonyms,\n            pos: synset.pos\n          });\n        }\n        done(null, synsets);\n      });\n    });\n    return response.result;\n  }\n});\n\n// jsonGraph is the file created in python\n// nodeTransform is a function that operates\n// linkTransform\nfunction load(jsonGraph, nodeTransform, linkTransform) {\n  // stored used to store jsonGraph\n  var stored;\n  nodeTransform = nodeTransform || id;\n  linkTransform = linkTransform || id;\n  // either parse the json string to a json object\n  if (typeof jsonGraph === 'string') {\n    stored = JSON.parse(jsonGraph);\n  } else {\n    stored = jsonGraph;\n  }\n\n  // create an empty ngraph.graph\n  var graph = (0, _ngraph4.default)(),\n      i;\n\n  if (stored.links === undefined || stored.nodes === undefined) {\n    throw new Error('Cannot load graph without links and nodes');\n  }\n\n  for (i = 0; i < stored.nodes.length; ++i) {\n    // apply nodeTranform to each node\n    // ex: set to {id: node[\"id\"], data: node['data']};\n    var parsedNode = nodeTransform(stored.nodes[i]);\n    if (!parsedNode.hasOwnProperty('id')) {\n      throw new Error('Graph node format is invalid: Node id is missing');\n    }\n    // add the node w/ id and parsedNode\n    graph.addNode(parsedNode.id, parsedNode.data);\n  }\n\n  for (i = 0; i < stored.links.length; ++i) {\n    // apply linkTransform to each link\n    // ex: return fromId, toId for the two nodes\n    var link = linkTransform(stored.links[i]);\n    if (!link.hasOwnProperty('fromId') || !link.hasOwnProperty('toId')) {\n      throw new Error('Graph link format is invalid. Both fromId and toId are required');\n    }\n\n    graph.addLink(link.fromId, link.toId, link.data);\n  }\n\n  return graph;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/methods.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createLayout;\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nvar _ngraph = require('ngraph.forcelayout3d');\n\nvar _ngraph2 = _interopRequireDefault(_ngraph);\n\nvar _ngraph3 = require('ngraph.tobinary');\n\nvar _ngraph4 = _interopRequireDefault(_ngraph3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createLayout(graph, options) {\n  options = options || {};\n  var iterations = typeof options.iterations === 'number' ? options.iterations : 500;\n  var saveEach = typeof options.saveEach === 'number' ? options.saveEach : 5;\n  var is2d = options.is2d ? true : false;\n  var coordinatesPerRecord = is2d ? 2 : 3;\n  var intSize = 4;\n  var layouter = is2d ? _ngraph2.default.get2dLayout : _ngraph2.default;\n  var layout = layouter(graph, options.physicsSettings);\n  var outDir = process.env[\"PWD\"] + \"/public/data\";\n\n  if (!_fs2.default.existsSync(outDir)) {\n    _mkdirp2.default.sync(outDir);\n  }\n  var lastIteration = getLastIteration(outDir);\n\n  return {\n    run: run,\n    lastIteration: getLastIteration\n  };\n\n  function getLastIteration() {\n    var files = _fs2.default.readdirSync(outDir);\n    var largest = 0;\n    for (var i = 0; i < files.length; ++i) {\n      var match = files[i].match(/^(\\d+)\\.bin$/i);\n      if (!match) continue;\n      var iterationNumber = parseInt(match[1], 10);\n      if (iterationNumber > largest) largest = iterationNumber;\n    }\n    return largest;\n  }\n\n  function run(overwrite) {\n    if (overwrite) {\n      lastIteration = 0;\n    } else {\n      if (lastIteration >= iterations) {\n        printLastIterationHelp();\n        return;\n      } else if (lastIteration > 0) {\n        initLayout(lastIteration);\n      }\n    }\n\n    for (var step = lastIteration + 1; step < iterations; ++step) {\n      console.log('Step ' + step);\n      layout.step();\n      if (step % saveEach === 0) {\n        saveIteration(step);\n      }\n    }\n    saveIteration('positions');\n  }\n\n  function initLayout(iteration) {\n    var lastName = _path2.default.join(outDir, iteration + '.bin');\n    console.log('Attempting to resume layout from ' + lastName);\n    var buf = _fs2.default.readFileSync(lastName);\n    var idx = 0;\n    graph.forEachNode(initPosition);\n\n    function initPosition(node) {\n      var x = buf.readInt32LE(idx);\n      var y = buf.readInt32LE(idx + 4);\n      if (is2d) {\n        layout.setNodePosition(node.id, x, y);\n        idx += 8;\n      } else {\n        var z = buf.readInt32LE(idx + 8);\n        layout.setNodePosition(node.id, x, y, z);\n        idx += 12;\n      }\n    }\n  }\n\n  function printLastIterationHelp() {\n    console.log('The ' + outDir + ' already has ' + lastIteration + ' saved iterations.');\n    console.log('* If you want to overwite existing work call `layout.run(true)`');\n    console.log('* If you want to perform more iterations set higher value for `options.iterations`');\n  }\n\n  function saveIteration(name) {\n    var fname = _path2.default.join(outDir, name + '.bin');\n\n    console.log(\"Saving: \", fname);\n    var nodesLength = graph.getNodesCount();\n    var buf = new Buffer(nodesLength * intSize * coordinatesPerRecord);\n    var i = 0;\n\n    graph.forEachNode(saveNode);\n\n    _fs2.default.writeFileSync(fname, buf);\n\n    (0, _ngraph4.default)(graph, {\n      outDir: outDir\n    });\n\n    function saveNode(node) {\n      var idx = i * intSize * coordinatesPerRecord;\n      var pos = layout.getNodePosition(node.id);\n      buf.writeInt32LE(Math.ceil(pos.x), idx);\n      buf.writeInt32LE(Math.ceil(pos.y), idx + 4);\n      if (!is2d) {\n        buf.writeInt32LE(Math.ceil(pos.z), idx + 8);\n      }\n      i++;\n    }\n  }\n}\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/forceAtlas/layout.js\n ** module id = 6\n ** module chunks = 0\n **/","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mkdirp/index.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * This module provides all required forces to regular ngraph.physics.simulator\n * to make it 3D simulator. Ideally ngraph.physics.simulator should operate\n * with vectors, but on practices that showed performance decrease... Maybe\n * I was doing it wrong, will see if I can refactor/throw away this module.\n */\nmodule.exports = createLayout;\ncreateLayout.get2dLayout = require('ngraph.forcelayout');\n\nfunction createLayout(graph, physicsSettings) {\n  var merge = require('ngraph.merge');\n  physicsSettings = merge(physicsSettings, {\n        createQuadTree: require('ngraph.quadtreebh3d'),\n        createBounds: require('./lib/bounds'),\n        createDragForce: require('./lib/dragForce'),\n        createSpringForce: require('./lib/springForce'),\n        integrator: require('./lib/eulerIntegrator'),\n        createBody: require('./lib/createBody')\n      });\n\n  return createLayout.get2dLayout(graph, physicsSettings);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/index.js\n ** module id = 10\n ** module chunks = 0\n **/","module.exports = createLayout;\nmodule.exports.simulator = require('ngraph.physics.simulator');\n\nvar eventify = require('ngraph.events');\n\n/**\n * Creates force based layout for a given graph.\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = require('ngraph.physics.simulator');\n  var physicsSimulator = createSimulator(physicsSettings);\n\n  var nodeBodies = typeof Object.create === 'function' ? Object.create(null) : {};\n  var springs = {};\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physical objects according to what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     */\n    step: function() {\n      return physicsSimulator.step();\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      physicsSimulator.off('stable', onStableChanged);\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is trated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator\n  };\n\n  eventify(api);\n  return api;\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies[nodeId];\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n    physicsSimulator.on('stable', onStableChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n  }\n\n  function initPhysics() {\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n    });\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n\n      nodeBodies[nodeId] = body;\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies[nodeId];\n    if (body) {\n      nodeBodies[nodeId] = null;\n      delete nodeBodies[nodeId];\n\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies[link.fromId],\n        toBody  = nodeBodies[link.toId],\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies[nodeId];\n    body.mass = nodeMass(nodeId);\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be preconfigured\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies[nodeId];\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies[nodeId];\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function nodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() { }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout/index.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = physicsSimulator;\n\nfunction physicsSimulator(settings) {\n  var Spring = require('./lib/spring');\n  var expose = require('ngraph.expose');\n  var merge = require('ngraph.merge');\n  var eventify = require('ngraph.events');\n\n  settings = merge(settings, {\n      /**\n       * Ideal length for links (springs in physical model).\n       */\n      springLength: 30,\n\n      /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n      springCoeff: 0.0008,\n\n      /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n      gravity: -1.2,\n\n      /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n      theta: 0.8,\n\n      /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n      dragCoeff: 0.02,\n\n      /**\n       * Default time step (dt) for forces integration\n       */\n      timeStep : 20,\n\n      /**\n        * Maximum movement of the system which can be considered as stabilized\n        */\n      stableThreshold: 0.009\n  });\n\n  // We allow clients to override basic factory methods:\n  var createQuadTree = settings.createQuadTree || require('ngraph.quadtreebh');\n  var createBounds = settings.createBounds || require('./lib/bounds');\n  var createDragForce = settings.createDragForce || require('./lib/dragForce');\n  var createSpringForce = settings.createSpringForce || require('./lib/springForce');\n  var integrate = settings.integrator || require('./lib/eulerIntegrator');\n  var createBody = settings.createBody || require('./lib/createBody');\n\n  var bodies = [], // Bodies in this simulation.\n      springs = [], // Springs in this simulation.\n      quadTree =  createQuadTree(settings),\n      bounds = createBounds(bodies, settings),\n      springForce = createSpringForce(settings),\n      dragForce = createDragForce(settings);\n\n  var totalMovement = 0; // how much movement we made on last step\n  var lastStable = false; // indicates whether system was stable on last step() call\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      accumulateForces();\n      totalMovement = integrate(bodies, settings.timeStep);\n\n      bounds.update();\n      var stableNow = totalMovement < settings.stableThreshold;\n      if (lastStable !== stableNow) {\n        publicApi.fire('stable', stableNow);\n      }\n\n      lastStable = stableNow;\n\n      return stableNow;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n      var body = createBody(pos);\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) { return; }\n\n      var idx = bodies.indexOf(body);\n      if (idx < 0) { return; }\n\n      bodies.splice(idx, 1);\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springWeight, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);\n      springs.push(spring);\n\n      // TODO: could mark simulator as dirty.\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) { return; }\n      var idx = springs.indexOf(spring);\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: function () {\n      return bounds.box;\n    },\n\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({gravity: value});\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({theta: value});\n        return this;\n      } else {\n        return settings.theta;\n      }\n    }\n  };\n\n  // allow settings modification via public API:\n  expose(settings, publicApi);\n  eventify(publicApi);\n\n  return publicApi;\n\n  function accumulateForces() {\n    // Accumulate forces acting on bodies.\n    var body,\n        i = bodies.length;\n\n    if (i) {\n      // only add bodies if there the array is not empty:\n      quadTree.insertBodies(bodies); // performance: O(n * log n)\n      while (i--) {\n        body = bodies[i];\n        // If body is pinned there is no point updating its forces - it should\n        // never move:\n        if (!body.isPinned) {\n          body.force.reset();\n\n          quadTree.updateBodyForce(body);\n          dragForce.update(body);\n        }\n      }\n    }\n\n    i = springs.length;\n    while(i--) {\n      springForce.update(springs[i]);\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/index.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = Spring;\n\n/**\n * Represents a physical spring. Spring connects two bodies, has rest length\n * stiffness coefficient and optional weight\n */\nfunction Spring(fromBody, toBody, length, coeff, weight) {\n    this.from = fromBody;\n    this.to = toBody;\n    this.length = length;\n    this.coeff = coeff;\n\n    this.weight = typeof weight === 'number' ? weight : 1;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/spring.js\n ** module id = 13\n ** module chunks = 0\n **/","module.exports = exposeProperties;\n\n/**\n * Augments `target` object with getter/setter functions, which modify settings\n *\n * @example\n *  var target = {};\n *  exposeProperties({ age: 42}, target);\n *  target.age(); // returns 42\n *  target.age(24); // make age 24;\n *\n *  var filteredTarget = {};\n *  exposeProperties({ age: 42, name: 'John'}, filteredTarget, ['name']);\n *  filteredTarget.name(); // returns 'John'\n *  filteredTarget.age === undefined; // true\n */\nfunction exposeProperties(settings, target, filter) {\n  var needsFilter = Object.prototype.toString.call(filter) === '[object Array]';\n  if (needsFilter) {\n    for (var i = 0; i < filter.length; ++i) {\n      augment(settings, target, filter[i]);\n    }\n  } else {\n    for (var key in settings) {\n      augment(settings, target, key);\n    }\n  }\n}\n\nfunction augment(source, target, key) {\n  if (source.hasOwnProperty(key)) {\n    if (typeof target[key] === 'function') {\n      // this accessor is already defined. Ignore it\n      return;\n    }\n    target[key] = function (value) {\n      if (value !== undefined) {\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.expose/index.js\n ** module id = 14\n ** module chunks = 0\n **/","module.exports = merge;\n\n/**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in \n * options\n *\n * @returns {Object} merged object\n */\nfunction merge(target, options) {\n  var key;\n  if (!target) { target = {}; }\n  if (options) {\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        var targetHasIt = target.hasOwnProperty(key),\n            optionsValueType = typeof options[key],\n            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n\n        if (shouldReplace) {\n          target[key] = options[key];\n        } else if (optionsValueType === 'object') {\n          // go deep, don't care about loops here, we are simple API!:\n          target[key] = merge(target[key], options[key]);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.merge/index.js\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.events/index.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * This is Barnes Hut simulation algorithm for 2d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    newNode = function() {\n      // To avoid pressure on GC we reuse nodes.\n      var node = nodesCache[currentInCache];\n      if (node) {\n        node.quad0 = null;\n        node.quad1 = null;\n        node.quad2 = null;\n        node.quad3 = null;\n        node.body = null;\n        node.mass = node.massX = node.massY = 0;\n        node.left = node.right = node.top = node.bottom = 0;\n      } else {\n        node = new Node();\n        nodesCache[currentInCache] = node;\n      }\n\n      ++currentInCache;\n      return node;\n    },\n\n    root = newNode(),\n\n    // Inserts body to the tree\n    insert = function(newBody) {\n      insertStack.reset();\n      insertStack.push(root, newBody);\n\n      while (!insertStack.isEmpty()) {\n        var stackItem = insertStack.pop(),\n          node = stackItem.node,\n          body = stackItem.body;\n\n        if (!node.body) {\n          // This is internal node. Update the total mass of the node and center-of-mass.\n          var x = body.pos.x;\n          var y = body.pos.y;\n          node.mass = node.mass + body.mass;\n          node.massX = node.massX + body.mass * x;\n          node.massY = node.massY + body.mass * y;\n\n          // Recursively insert the body in the appropriate quadrant.\n          // But first find the appropriate quadrant.\n          var quadIdx = 0, // Assume we are in the 0's quad.\n            left = node.left,\n            right = (node.right + left) / 2,\n            top = node.top,\n            bottom = (node.bottom + top) / 2;\n\n          if (x > right) { // somewhere in the eastern part.\n            quadIdx = quadIdx + 1;\n            var oldLeft = left;\n            left = right;\n            right = right + (right - oldLeft);\n          }\n          if (y > bottom) { // and in south.\n            quadIdx = quadIdx + 2;\n            var oldTop = top;\n            top = bottom;\n            bottom = bottom + (bottom - oldTop);\n          }\n\n          var child = getChild(node, quadIdx);\n          if (!child) {\n            // The node is internal but this quadrant is not taken. Add\n            // subnode to it.\n            child = newNode();\n            child.left = left;\n            child.top = top;\n            child.right = right;\n            child.bottom = bottom;\n            child.body = body;\n\n            setChild(node, quadIdx, child);\n          } else {\n            // continue searching in this quadrant.\n            insertStack.push(child, body);\n          }\n        } else {\n          // We are trying to add to the leaf node.\n          // We have to convert current leaf into internal node\n          // and continue adding two nodes.\n          var oldBody = node.body;\n          node.body = null; // internal nodes do not cary bodies\n\n          if (isSamePosition(oldBody.pos, body.pos)) {\n            // Prevent infinite subdivision by bumping one node\n            // anywhere in this quadrant\n            var retriesCount = 3;\n            do {\n              var offset = random.nextDouble();\n              var dx = (node.right - node.left) * offset;\n              var dy = (node.bottom - node.top) * offset;\n\n              oldBody.pos.x = node.left + dx;\n              oldBody.pos.y = node.top + dy;\n              retriesCount -= 1;\n              // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n              // This is very bad, we ran out of precision.\n              // if we do not return from the method we'll get into\n              // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n              // Next layout iteration should get larger bounding box in the first step and fix this\n              return;\n            }\n          }\n          // Next iteration should subdivide node further.\n          insertStack.push(node, oldBody);\n          insertStack.push(node, body);\n        }\n      }\n    },\n\n    update = function(sourceBody) {\n      var queue = updateQueue,\n        v,\n        dx,\n        dy,\n        r, fx = 0,\n        fy = 0,\n        queueLength = 1,\n        shiftIdx = 0,\n        pushIdx = 1;\n\n      queue[0] = root;\n\n      while (queueLength) {\n        var node = queue[shiftIdx],\n          body = node.body;\n\n        queueLength -= 1;\n        shiftIdx += 1;\n        var differentBody = (body !== sourceBody);\n        if (body && differentBody) {\n          // If the current node is a leaf node (and it is not source body),\n          // calculate the force exerted by the current node on body, and add this\n          // amount to body's net force.\n          dx = body.pos.x - sourceBody.pos.x;\n          dy = body.pos.y - sourceBody.pos.y;\n          r = Math.sqrt(dx * dx + dy * dy);\n\n          if (r === 0) {\n            // Poor man's protection against zero distance.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy);\n          }\n\n          // This is standard gravition force calculation but we divide\n          // by r^3 to save two operations when normalizing force vector.\n          v = gravity * body.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else if (differentBody) {\n          // Otherwise, calculate the ratio s / r,  where s is the width of the region\n          // represented by the internal node, and r is the distance between the body\n          // and the node's center-of-mass\n          dx = node.massX / node.mass - sourceBody.pos.x;\n          dy = node.massY / node.mass - sourceBody.pos.y;\n          r = Math.sqrt(dx * dx + dy * dy);\n\n          if (r === 0) {\n            // Sorry about code duplucation. I don't want to create many functions\n            // right away. Just want to see performance first.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy);\n          }\n          // If s / r < , treat this internal node as a single body, and calculate the\n          // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n          if ((node.right - node.left) / r < theta) {\n            // in the if statement above we consider node's width only\n            // because the region was squarified during tree creation.\n            // Thus there is no difference between using width or height.\n            v = gravity * node.mass * sourceBody.mass / (r * r * r);\n            fx += v * dx;\n            fy += v * dy;\n          } else {\n            // Otherwise, run the procedure recursively on each of the current node's children.\n\n            // I intentionally unfolded this loop, to save several CPU cycles.\n            if (node.quad0) {\n              queue[pushIdx] = node.quad0;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad1) {\n              queue[pushIdx] = node.quad1;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad2) {\n              queue[pushIdx] = node.quad2;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad3) {\n              queue[pushIdx] = node.quad3;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n          }\n        }\n      }\n\n      sourceBody.force.x += fx;\n      sourceBody.force.y += fy;\n    },\n\n    insertBodies = function(bodies) {\n      var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        i,\n        max = bodies.length;\n\n      // To reduce quad tree depth we are looking for exact bounding box of all particles.\n      i = max;\n      while (i--) {\n        var x = bodies[i].pos.x;\n        var y = bodies[i].pos.y;\n        if (x < x1) {\n          x1 = x;\n        }\n        if (x > x2) {\n          x2 = x;\n        }\n        if (y < y1) {\n          y1 = y;\n        }\n        if (y > y2) {\n          y2 = y;\n        }\n      }\n\n      // Squarify the bounds.\n      var dx = x2 - x1,\n        dy = y2 - y1;\n      if (dx > dy) {\n        y2 = y1 + dx;\n      } else {\n        x2 = x1 + dy;\n      }\n\n      currentInCache = 0;\n      root = newNode();\n      root.left = x1;\n      root.right = x2;\n      root.top = y1;\n      root.bottom = y2;\n\n      i = max - 1;\n      if (i > 0) {\n        root.body = bodies[i];\n      }\n      while (i--) {\n        insert(bodies[i], root);\n      }\n    };\n\n  return {\n    insertBodies: insertBodies,\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh/index.js\n ** module id = 17\n ** module chunks = 0\n **/","module.exports = {\n  random: random,\n  randomIterator: randomIterator\n};\n\n/**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\nfunction random(inputSeed) {\n  var seed = typeof inputSeed === 'number' ? inputSeed : (+ new Date());\n  var randomFunc = function() {\n      // Robert Jenkins' 32 bit integer hash function.\n      seed = ((seed + 0x7ed55d16) + (seed << 12))  & 0xffffffff;\n      seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;\n      seed = ((seed + 0x165667b1) + (seed << 5))   & 0xffffffff;\n      seed = ((seed + 0xd3a2646c) ^ (seed << 9))   & 0xffffffff;\n      seed = ((seed + 0xfd7046c5) + (seed << 3))   & 0xffffffff;\n      seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;\n      return (seed & 0xfffffff) / 0x10000000;\n  };\n\n  return {\n      /**\n       * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n       *\n       * @param maxValue Number REQUIRED. Ommitting this number will result in NaN values from PRNG.\n       */\n      next : function (maxValue) {\n          return Math.floor(randomFunc() * maxValue);\n      },\n\n      /**\n       * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n       * This function is the same as Math.random() (except that it could be seeded)\n       */\n      nextDouble : function () {\n          return randomFunc();\n      }\n  };\n}\n\n/*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\nfunction randomIterator(array, customRandom) {\n    var localRandom = customRandom || random();\n    if (typeof localRandom.next !== 'function') {\n      throw new Error('customRandom does not match expected API: next() function is missing');\n    }\n\n    return {\n        forEach : function (callback) {\n            var i, j, t;\n            for (i = array.length - 1; i > 0; --i) {\n                j = localRandom.next(i + 1); // i inclusive\n                t = array[j];\n                array[j] = array[i];\n                array[i] = t;\n\n                callback(t);\n            }\n\n            if (array.length) {\n                callback(array[0]);\n            }\n        },\n\n        /**\n         * Shuffles array randomly, in place.\n         */\n        shuffle : function () {\n            var i, j, t;\n            for (i = array.length - 1; i > 0; --i) {\n                j = localRandom.next(i + 1); // i inclusive\n                t = array[j];\n                array[j] = array[i];\n                array[i] = t;\n            }\n\n            return array;\n        }\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.random/index.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * Internal data structure to represent 2D QuadTree node\n */\nmodule.exports = function Node() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain boides:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n  this.quad0 = null;\n  this.quad1 = null;\n  this.quad2 = null;\n  this.quad3 = null;\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  this.massX = 0;\n  this.massY = 0;\n\n  // bounding box coordinates\n  this.left = 0;\n  this.top = 0;\n  this.bottom = 0;\n  this.right = 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh/node.js\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = InsertStack;\n\n/**\n * Our implmentation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressue: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh/insertStack.js\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = function isSamePosition(point1, point2) {\n    var dx = Math.abs(point1.x - point2.x);\n    var dy = Math.abs(point1.y - point2.y);\n\n    return (dx < 1e-8 && dy < 1e-8);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh/isSamePosition.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function (bodies, settings) {\n  var random = require('ngraph.random').random(42);\n  var boundingBox =  { x1: 0, y1: 0, x2: 0, y2: 0 };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset : function () {\n      boundingBox.x1 = boundingBox.y1 = 0;\n      boundingBox.x2 = boundingBox.y2 = 0;\n    },\n\n    getBestNewPosition: function (neighbors) {\n      var graphRect = boundingBox;\n\n      var baseX = 0, baseY = 0;\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          baseX += neighbors[i].pos.x;\n          baseY += neighbors[i].pos.y;\n        }\n\n        baseX /= neighbors.length;\n        baseY /= neighbors.length;\n      } else {\n        baseX = (graphRect.x1 + graphRect.x2) / 2;\n        baseY = (graphRect.y1 + graphRect.y2) / 2;\n      }\n\n      var springLength = settings.springLength;\n      return {\n        x: baseX + random.next(springLength) - springLength / 2,\n        y: baseY + random.next(springLength) - springLength / 2\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) { return; } // don't have to wory here.\n\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE;\n\n    while(i--) {\n      // this is O(n), could it be done faster with quadtree?\n      // how about pinned nodes?\n      var body = bodies[i];\n      if (body.isPinned) {\n        body.pos.x = body.prevPos.x;\n        body.pos.y = body.prevPos.y;\n      } else {\n        body.prevPos.x = body.pos.x;\n        body.prevPos.y = body.pos.y;\n      }\n      if (body.pos.x < x1) {\n        x1 = body.pos.x;\n      }\n      if (body.pos.x > x2) {\n        x2 = body.pos.x;\n      }\n      if (body.pos.y < y1) {\n        y1 = body.pos.y;\n      }\n      if (body.pos.y > y2) {\n        y2 = body.pos.y;\n      }\n    }\n\n    boundingBox.x1 = x1;\n    boundingBox.x2 = x2;\n    boundingBox.y1 = y1;\n    boundingBox.y2 = y2;\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/bounds.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * Represents drag force, which reduces force value on each step by given\n * coefficient.\n *\n * @param {Object} options for the drag force\n * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n */\nmodule.exports = function (options) {\n  var merge = require('ngraph.merge'),\n      expose = require('ngraph.expose');\n\n  options = merge(options, {\n    dragCoeff: 0.02\n  });\n\n  var api = {\n    update : function (body) {\n      body.force.x -= options.dragCoeff * body.velocity.x;\n      body.force.y -= options.dragCoeff * body.velocity.y;\n    }\n  };\n\n  // let easy access to dragCoeff:\n  expose(options, api, ['dragCoeff']);\n\n  return api;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/dragForce.js\n ** module id = 23\n ** module chunks = 0\n **/","/**\n * Represents spring force, which updates forces acting on two bodies, conntected\n * by a spring.\n *\n * @param {Object} options for the spring force\n * @param {Number=} options.springCoeff spring force coefficient.\n * @param {Number=} options.springLength desired length of a spring at rest.\n */\nmodule.exports = function (options) {\n  var merge = require('ngraph.merge');\n  var random = require('ngraph.random').random(42);\n  var expose = require('ngraph.expose');\n\n  options = merge(options, {\n    springCoeff: 0.0002,\n    springLength: 80\n  });\n\n  var api = {\n    /**\n     * Upsates forces acting on a spring\n     */\n    update : function (spring) {\n      var body1 = spring.from,\n          body2 = spring.to,\n          length = spring.length < 0 ? options.springLength : spring.length,\n          dx = body2.pos.x - body1.pos.x,\n          dy = body2.pos.y - body1.pos.y,\n          r = Math.sqrt(dx * dx + dy * dy);\n\n      if (r === 0) {\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n      }\n\n      var d = r - length;\n      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n\n      body1.force.x += coeff * dx;\n      body1.force.y += coeff * dy;\n\n      body2.force.x -= coeff * dx;\n      body2.force.y -= coeff * dy;\n    }\n  };\n\n  expose(options, api, ['springCoeff', 'springLength']);\n  return api;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/springForce.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * Performs forces integration, using given timestep. Uses Euler method to solve\n * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n *\n * @returns {Number} squared distance of total position updates.\n */\n\nmodule.exports = integrate;\n\nfunction integrate(bodies, timeStep) {\n  var dx = 0, tx = 0,\n      dy = 0, ty = 0,\n      i,\n      max = bodies.length;\n\n  if (max === 0) {\n    return 0;\n  }\n\n  for (i = 0; i < max; ++i) {\n    var body = bodies[i],\n        coeff = timeStep / body.mass;\n\n    body.velocity.x += coeff * body.force.x;\n    body.velocity.y += coeff * body.force.y;\n    var vx = body.velocity.x,\n        vy = body.velocity.y,\n        v = Math.sqrt(vx * vx + vy * vy);\n\n    if (v > 1) {\n      body.velocity.x = vx / v;\n      body.velocity.y = vy / v;\n    }\n\n    dx = timeStep * body.velocity.x;\n    dy = timeStep * body.velocity.y;\n\n    body.pos.x += dx;\n    body.pos.y += dy;\n\n    tx += Math.abs(dx); ty += Math.abs(dy);\n  }\n\n  return (tx * tx + ty * ty)/max;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/eulerIntegrator.js\n ** module id = 25\n ** module chunks = 0\n **/","var physics = require('ngraph.physics.primitives');\n\nmodule.exports = function(pos) {\n  return new physics.Body(pos);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.simulator/lib/createBody.js\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = {\n  Body: Body,\n  Vector2d: Vector2d,\n  Body3d: Body3d,\n  Vector3d: Vector3d\n};\n\nfunction Body(x, y) {\n  this.pos = new Vector2d(x, y);\n  this.prevPos = new Vector2d(x, y);\n  this.force = new Vector2d();\n  this.velocity = new Vector2d();\n  this.mass = 1;\n}\n\nBody.prototype.setPosition = function (x, y) {\n  this.prevPos.x = this.pos.x = x;\n  this.prevPos.y = this.pos.y = y;\n};\n\nfunction Vector2d(x, y) {\n  if (x && typeof x !== 'number') {\n    // could be another vector\n    this.x = typeof x.x === 'number' ? x.x : 0;\n    this.y = typeof x.y === 'number' ? x.y : 0;\n  } else {\n    this.x = typeof x === 'number' ? x : 0;\n    this.y = typeof y === 'number' ? y : 0;\n  }\n}\n\nVector2d.prototype.reset = function () {\n  this.x = this.y = 0;\n};\n\nfunction Body3d(x, y, z) {\n  this.pos = new Vector3d(x, y, z);\n  this.prevPos = new Vector3d(x, y, z);\n  this.force = new Vector3d();\n  this.velocity = new Vector3d();\n  this.mass = 1;\n}\n\nBody3d.prototype.setPosition = function (x, y, z) {\n  this.prevPos.x = this.pos.x = x;\n  this.prevPos.y = this.pos.y = y;\n  this.prevPos.z = this.pos.z = z;\n};\n\nfunction Vector3d(x, y, z) {\n  if (x && typeof x !== 'number') {\n    // could be another vector\n    this.x = typeof x.x === 'number' ? x.x : 0;\n    this.y = typeof x.y === 'number' ? x.y : 0;\n    this.z = typeof x.z === 'number' ? x.z : 0;\n  } else {\n    this.x = typeof x === 'number' ? x : 0;\n    this.y = typeof y === 'number' ? y : 0;\n    this.z = typeof z === 'number' ? z : 0;\n  }\n};\n\nVector3d.prototype.reset = function () {\n  this.x = this.y = this.z = 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.physics.primitives/index.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\n * This is Barnes Hut simulation algorithm for 3d case. Implementation\n * is highly optimized (avoids recusion and gc pressure)\n *\n * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html\n *\n * NOTE: This module duplicates a lot of code from 2d case. Primary reason for\n * this is performance. Every time I tried to abstract away vector operations\n * I had negative impact on performance. So in this case I'm scarifying code\n * reuse in favor of speed\n */\n\nmodule.exports = function(options) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  // we require deterministic randomness here\n  var random = require('ngraph.random').random(1984),\n    Node = require('./node'),\n    InsertStack = require('./insertStack'),\n    isSamePosition = require('./isSamePosition');\n\n  var gravity = options.gravity,\n    updateQueue = [],\n    insertStack = new InsertStack(),\n    theta = options.theta,\n\n    nodesCache = [],\n    currentInCache = 0,\n    newNode = function() {\n      // To avoid pressure on GC we reuse nodes.\n      var node = nodesCache[currentInCache];\n      if (node) {\n        node.quad0 = null;\n        node.quad4 = null;\n        node.quad1 = null;\n        node.quad5 = null;\n        node.quad2 = null;\n        node.quad6 = null;\n        node.quad3 = null;\n        node.quad7 = null;\n        node.body = null;\n        node.mass = node.massX = node.massY = node.massZ = 0;\n        node.left = node.right = node.top = node.bottom = node.front = node.back = 0;\n      } else {\n        node = new Node();\n        nodesCache[currentInCache] = node;\n      }\n\n      ++currentInCache;\n      return node;\n    },\n\n    root = newNode(),\n\n    // Inserts body to the tree\n    insert = function(newBody) {\n      insertStack.reset();\n      insertStack.push(root, newBody);\n\n      while (!insertStack.isEmpty()) {\n        var stackItem = insertStack.pop(),\n          node = stackItem.node,\n          body = stackItem.body;\n\n        if (!node.body) {\n          // This is internal node. Update the total mass of the node and center-of-mass.\n          var x = body.pos.x;\n          var y = body.pos.y;\n          var z = body.pos.z;\n          node.mass += body.mass;\n          node.massX += body.mass * x;\n          node.massY += body.mass * y;\n          node.massZ += body.mass * z;\n\n          // Recursively insert the body in the appropriate quadrant.\n          // But first find the appropriate quadrant.\n          var quadIdx = 0, // Assume we are in the 0's quad.\n            left = node.left,\n            right = (node.right + left) / 2,\n            top = node.top,\n            bottom = (node.bottom + top) / 2,\n            back = node.back,\n            front = (node.front + back) / 2;\n\n          if (x > right) { // somewhere in the eastern part.\n            quadIdx += 1;\n            var oldLeft = left;\n            left = right;\n            right = right + (right - oldLeft);\n          }\n          if (y > bottom) { // and in south.\n            quadIdx += 2;\n            var oldTop = top;\n            top = bottom;\n            bottom = bottom + (bottom - oldTop);\n          }\n          if (z > front) { // and in frontal part\n            quadIdx += 4;\n            var oldBack = back;\n            back = front;\n            front = back + (back - oldBack);\n          }\n\n          var child = getChild(node, quadIdx);\n          if (!child) {\n            // The node is internal but this quadrant is not taken. Add subnode to it.\n            child = newNode();\n            child.left = left;\n            child.top = top;\n            child.right = right;\n            child.bottom = bottom;\n            child.back = back;\n            child.front = front;\n            child.body = body;\n\n            setChild(node, quadIdx, child);\n          } else {\n            // continue searching in this quadrant.\n            insertStack.push(child, body);\n          }\n        } else {\n          // We are trying to add to the leaf node.\n          // We have to convert current leaf into internal node\n          // and continue adding two nodes.\n          var oldBody = node.body;\n          node.body = null; // internal nodes do not carry bodies\n\n          if (isSamePosition(oldBody.pos, body.pos)) {\n            // Prevent infinite subdivision by bumping one node\n            // anywhere in this quadrant\n            var retriesCount = 3;\n            do {\n              var offset = random.nextDouble();\n              var dx = (node.right - node.left) * offset;\n              var dy = (node.bottom - node.top) * offset;\n              var dz = (node.front - node.back) * offset;\n\n              oldBody.pos.x = node.left + dx;\n              oldBody.pos.y = node.top + dy;\n              oldBody.pos.z = node.back + dz;\n              retriesCount -= 1;\n              // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n              // This is very bad, we ran out of precision.\n              // if we do not return from the method we'll get into\n              // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n              // Next layout iteration should get larger bounding box in the first step and fix this\n              return;\n            }\n          }\n          // Next iteration should subdivide node further.\n          insertStack.push(node, oldBody);\n          insertStack.push(node, body);\n        }\n      }\n    },\n\n    update = function(sourceBody) {\n      var queue = updateQueue,\n        v,\n        dx, dy, dz,\n        r, fx = 0,\n        fy = 0,\n        fz = 0,\n        queueLength = 1,\n        shiftIdx = 0,\n        pushIdx = 1;\n\n      queue[0] = root;\n\n      while (queueLength) {\n        var node = queue[shiftIdx],\n          body = node.body;\n\n        queueLength -= 1;\n        shiftIdx += 1;\n        var differentBody = (body !== sourceBody);\n        if (body && differentBody) {\n          // If the current node is a leaf node (and it is not source body),\n          // calculate the force exerted by the current node on body, and add this\n          // amount to body's net force.\n          dx = body.pos.x - sourceBody.pos.x;\n          dy = body.pos.y - sourceBody.pos.y;\n          dz = body.pos.z - sourceBody.pos.z;\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          if (r === 0) {\n            // Poor man's protection against zero distance.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            dz = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n          }\n\n          // This is standard gravitation force calculation but we divide\n          // by r^3 to save two operations when normalizing force vector.\n          v = gravity * body.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n          fz += v * dz;\n        } else if (differentBody) {\n          // Otherwise, calculate the ratio s / r,  where s is the width of the region\n          // represented by the internal node, and r is the distance between the body\n          // and the node's center-of-mass\n          dx = node.massX / node.mass - sourceBody.pos.x;\n          dy = node.massY / node.mass - sourceBody.pos.y;\n          dz = node.massZ / node.mass - sourceBody.pos.z;\n\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          if (r === 0) {\n            // Sorry about code duplication. I don't want to create many functions\n            // right away. Just want to see performance first.\n            dx = (random.nextDouble() - 0.5) / 50;\n            dy = (random.nextDouble() - 0.5) / 50;\n            dz = (random.nextDouble() - 0.5) / 50;\n            r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n          }\n\n          // If s / r < , treat this internal node as a single body, and calculate the\n          // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n          if ((node.right - node.left) / r < theta) {\n            // in the if statement above we consider node's width only\n            // because the region was squarified during tree creation.\n            // Thus there is no difference between using width or height.\n            v = gravity * node.mass * sourceBody.mass / (r * r * r);\n            fx += v * dx;\n            fy += v * dy;\n            fz += v * dz;\n          } else {\n            // Otherwise, run the procedure recursively on each of the current node's children.\n\n            // I intentionally unfolded this loop, to save several CPU cycles.\n            if (node.quad0) {\n              queue[pushIdx] = node.quad0;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad1) {\n              queue[pushIdx] = node.quad1;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad2) {\n              queue[pushIdx] = node.quad2;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad3) {\n              queue[pushIdx] = node.quad3;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad4) {\n              queue[pushIdx] = node.quad4;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad5) {\n              queue[pushIdx] = node.quad5;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad6) {\n              queue[pushIdx] = node.quad6;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n            if (node.quad7) {\n              queue[pushIdx] = node.quad7;\n              queueLength += 1;\n              pushIdx += 1;\n            }\n          }\n        }\n      }\n\n      sourceBody.force.x += fx;\n      sourceBody.force.y += fy;\n      sourceBody.force.z += fz;\n    },\n\n    insertBodies = function(bodies) {\n      var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        z1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        z2 = Number.MIN_VALUE,\n        i,\n        max = bodies.length;\n\n      // To reduce quad tree depth we are looking for exact bounding box of all particles.\n      i = max;\n      while (i--) {\n        var pos = bodies[i].pos;\n        var x = pos.x;\n        var y = pos.y;\n        var z = pos.z;\n        if (x < x1) {\n          x1 = x;\n        }\n        if (x > x2) {\n          x2 = x;\n        }\n        if (y < y1) {\n          y1 = y;\n        }\n        if (y > y2) {\n          y2 = y;\n        }\n        if (z < z1) {\n          z1 = z;\n        }\n        if (z > z2) {\n          z2 = z;\n        }\n      }\n\n      // Squarify the bounds.\n      var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));\n\n      x2 = x1 + maxSide;\n      y2 = y1 + maxSide;\n      z2 = z1 + maxSide;\n\n      currentInCache = 0;\n      root = newNode();\n      root.left = x1;\n      root.right = x2;\n      root.top = y1;\n      root.bottom = y2;\n      root.back = z1;\n      root.front = z2;\n\n      i = max - 1;\n      if (i > 0) {\n        root.body = bodies[i];\n      }\n      while (i--) {\n        insert(bodies[i], root);\n      }\n    };\n\n  return {\n    insertBodies: insertBodies,\n    updateBodyForce: update,\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n};\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  if (idx === 4) return node.quad4;\n  if (idx === 5) return node.quad5;\n  if (idx === 6) return node.quad6;\n  if (idx === 7) return node.quad7;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n  else if (idx === 4) node.quad4 = child;\n  else if (idx === 5) node.quad5 = child;\n  else if (idx === 6) node.quad6 = child;\n  else if (idx === 7) node.quad7 = child;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh3d/index.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\n * Internal data structure to represent 3D QuadTree node\n */\nmodule.exports = function Node() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain boides:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // Behind Z median:\n  // 0 | 1\n  // -----\n  // 2 | 3\n  // In front of Z median:\n  // 4 | 5\n  // -----\n  // 6 | 7\n  this.quad0 = null;\n  this.quad1 = null;\n  this.quad2 = null;\n  this.quad3 = null;\n  this.quad4 = null;\n  this.quad5 = null;\n  this.quad6 = null;\n  this.quad7 = null;\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  this.massX = 0;\n  this.massY = 0;\n  this.massZ = 0;\n\n  // bounding box coordinates\n  this.left = 0;\n  this.top = 0;\n  this.bottom = 0;\n  this.right = 0;\n  this.front = 0;\n  this.back = 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh3d/node.js\n ** module id = 29\n ** module chunks = 0\n **/","module.exports = InsertStack;\n\n/**\n * Our implementation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressure: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh3d/insertStack.js\n ** module id = 30\n ** module chunks = 0\n **/","module.exports = function isSamePosition(point1, point2) {\n    var dx = Math.abs(point1.x - point2.x);\n    var dy = Math.abs(point1.y - point2.y);\n    var dz = Math.abs(point1.z - point2.z);\n\n    return (dx < 1e-8 && dy < 1e-8 && dz < 1e-8);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.quadtreebh3d/isSamePosition.js\n ** module id = 31\n ** module chunks = 0\n **/","module.exports = function (bodies, settings) {\n  var random = require('ngraph.random').random(42);\n  var boundingBox =  { x1: 0, y1: 0, z1: 0, x2: 0, y2: 0, z2: 0 };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset : function () {\n      boundingBox.x1 = boundingBox.y1 = 0;\n      boundingBox.x2 = boundingBox.y2 = 0;\n      boundingBox.z1 = boundingBox.z2 = 0;\n    },\n\n    getBestNewPosition: function (neighbors) {\n      var graphRect = boundingBox;\n\n      var baseX = 0, baseY = 0, baseZ = 0;\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          baseX += neighbors[i].pos.x;\n          baseY += neighbors[i].pos.y;\n          baseZ += neighbors[i].pos.z;\n        }\n\n        baseX /= neighbors.length;\n        baseY /= neighbors.length;\n        baseZ /= neighbors.length;\n      } else {\n        baseX = (graphRect.x1 + graphRect.x2) / 2;\n        baseY = (graphRect.y1 + graphRect.y2) / 2;\n        baseZ = (graphRect.z1 + graphRect.z2) / 2;\n      }\n\n      var springLength = settings.springLength;\n      return {\n        x: baseX + random.next(springLength) - springLength / 2,\n        y: baseY + random.next(springLength) - springLength / 2,\n        z: baseZ + random.next(springLength) - springLength / 2\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) { return; } // don't have to wory here.\n\n    var x1 = Number.MAX_VALUE,\n        y1 = Number.MAX_VALUE,\n        z1 = Number.MAX_VALUE,\n        x2 = Number.MIN_VALUE,\n        y2 = Number.MIN_VALUE,\n        z2 = Number.MIN_VALUE;\n\n    while(i--) {\n      // this is O(n), could it be done faster with quadtree?\n      // how about pinned nodes?\n      var body = bodies[i];\n      if (body.isPinned) {\n        body.pos.x = body.prevPos.x;\n        body.pos.y = body.prevPos.y;\n        body.pos.z = body.prevPos.z;\n      } else {\n        body.prevPos.x = body.pos.x;\n        body.prevPos.y = body.pos.y;\n        body.prevPos.z = body.pos.z;\n      }\n      if (body.pos.x < x1) {\n        x1 = body.pos.x;\n      }\n      if (body.pos.x > x2) {\n        x2 = body.pos.x;\n      }\n      if (body.pos.y < y1) {\n        y1 = body.pos.y;\n      }\n      if (body.pos.y > y2) {\n        y2 = body.pos.y;\n      }\n      if (body.pos.z < z1) {\n        z1 = body.pos.z;\n      }\n      if (body.pos.z > z2) {\n        z2 = body.pos.z;\n      }\n    }\n\n    boundingBox.x1 = x1;\n    boundingBox.x2 = x2;\n    boundingBox.y1 = y1;\n    boundingBox.y2 = y2;\n    boundingBox.z1 = z1;\n    boundingBox.z2 = z2;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/lib/bounds.js\n ** module id = 32\n ** module chunks = 0\n **/","/**\n * Represents 3d drag force, which reduces force value on each step by given\n * coefficient.\n *\n * @param {Object} options for the drag force\n * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default\n */\nmodule.exports = function (options) {\n  var merge = require('ngraph.merge'),\n      expose = require('ngraph.expose');\n\n  options = merge(options, {\n    dragCoeff: 0.02\n  });\n\n  var api = {\n    update : function (body) {\n      body.force.x -= options.dragCoeff * body.velocity.x;\n      body.force.y -= options.dragCoeff * body.velocity.y;\n      body.force.z -= options.dragCoeff * body.velocity.z;\n    }\n  };\n\n  // let easy access to dragCoeff:\n  expose(options, api, ['dragCoeff']);\n\n  return api;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/lib/dragForce.js\n ** module id = 33\n ** module chunks = 0\n **/","/**\n * Represents 3d spring force, which updates forces acting on two bodies, conntected\n * by a spring.\n *\n * @param {Object} options for the spring force\n * @param {Number=} options.springCoeff spring force coefficient.\n * @param {Number=} options.springLength desired length of a spring at rest.\n */\nmodule.exports = function (options) {\n  var merge = require('ngraph.merge');\n  var random = require('ngraph.random').random(42);\n  var expose = require('ngraph.expose');\n\n  options = merge(options, {\n    springCoeff: 0.0002,\n    springLength: 80\n  });\n\n  var api = {\n    /**\n     * Upsates forces acting on a spring\n     */\n    update : function (spring) {\n      var body1 = spring.from,\n          body2 = spring.to,\n          length = spring.length < 0 ? options.springLength : spring.length,\n          dx = body2.pos.x - body1.pos.x,\n          dy = body2.pos.y - body1.pos.y,\n          dz = body2.pos.z - body1.pos.z,\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n      if (r === 0) {\n          dx = (random.nextDouble() - 0.5) / 50;\n          dy = (random.nextDouble() - 0.5) / 50;\n          dz = (random.nextDouble() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy + dz * dz);\n      }\n\n      var d = r - length;\n      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;\n\n      body1.force.x += coeff * dx;\n      body1.force.y += coeff * dy;\n      body1.force.z += coeff * dz;\n\n      body2.force.x -= coeff * dx;\n      body2.force.y -= coeff * dy;\n      body2.force.z -= coeff * dz;\n    }\n  };\n\n  expose(options, api, ['springCoeff', 'springLength']);\n  return api;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/lib/springForce.js\n ** module id = 34\n ** module chunks = 0\n **/","/**\n * Performs 3d forces integration, using given timestep. Uses Euler method to solve\n * differential equation (http://en.wikipedia.org/wiki/Euler_method ).\n *\n * @returns {Number} squared distance of total position updates.\n */\n\nmodule.exports = integrate;\n\nfunction integrate(bodies, timeStep) {\n  var dx = 0, tx = 0,\n      dy = 0, ty = 0,\n      dz = 0, tz = 0,\n      i,\n      max = bodies.length;\n\n  for (i = 0; i < max; ++i) {\n    var body = bodies[i],\n        coeff = timeStep / body.mass;\n\n    body.velocity.x += coeff * body.force.x;\n    body.velocity.y += coeff * body.force.y;\n    body.velocity.z += coeff * body.force.z;\n\n    var vx = body.velocity.x,\n        vy = body.velocity.y,\n        vz = body.velocity.z,\n        v = Math.sqrt(vx * vx + vy * vy + vz * vz);\n\n    if (v > 1) {\n      body.velocity.x = vx / v;\n      body.velocity.y = vy / v;\n      body.velocity.z = vz / v;\n    }\n\n    dx = timeStep * body.velocity.x;\n    dy = timeStep * body.velocity.y;\n    dz = timeStep * body.velocity.z;\n\n    body.pos.x += dx;\n    body.pos.y += dy;\n    body.pos.z += dz;\n\n    tx += Math.abs(dx); ty += Math.abs(dy); tz += Math.abs(dz);\n  }\n\n  return (tx * tx + ty * ty + tz * tz)/bodies.length;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/lib/eulerIntegrator.js\n ** module id = 35\n ** module chunks = 0\n **/","var physics = require('ngraph.physics.primitives');\n\nmodule.exports = function(pos) {\n  return new physics.Body3d(pos);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.forcelayout3d/lib/createBody.js\n ** module id = 36\n ** module chunks = 0\n **/","var merge = require('ngraph.merge');\nvar fs = require('fs');\nvar path = require('path');\nvar mkdirp = require('mkdirp');\nmodule.exports = save;\n\nfunction save(graph, options) {\n  options = merge(options, {\n    outDir: '.',\n    labels: 'labels.json',\n    meta: 'meta.json',\n    links: 'links.bin'\n  });\n\n  fixPaths();\n\n  var labels = require('./lib/getLabels.js')(graph);\n  saveLabels(labels);\n  labels = labels.map(function(label) {\n    return label.id;\n  });\n\n  var linksBuffer = require('./lib/getLinksBuffer.js')(graph, labels);\n  fs.writeFileSync(options.links, linksBuffer);\n  console.log(graph.getLinksCount() + ' links saved to ' + options.links);\n\n  saveMeta();\n\n  function fixPaths() {\n    if (!fs.existsSync(options.outDir)) {\n      mkdirp.sync(options.outDir);\n    }\n    options.labels = path.join(options.outDir, options.labels);\n    options.meta = path.join(options.outDir, options.meta);\n    options.links = path.join(options.outDir, options.links);\n  }\n\n  function saveMeta() {\n    var meta = getMetaInfo();\n    fs.writeFileSync(options.meta, JSON.stringify(meta), 'utf8');\n    console.log('Meta information saved to ' + options.meta);\n  }\n\n  function getMetaInfo() {\n    return {\n      date: +new Date(),\n      nodeCount: graph.getNodesCount(),\n      linkCount: graph.getLinksCount(),\n      nodeFile: options.labels,\n      linkFile: options.links\n    };\n  }\n\n  function saveLabels(labels) {\n    fs.writeFileSync(options.labels, JSON.stringify(labels), 'utf8');\n    console.log(labels.length + ' ids saved to ' + options.labels);\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.tobinary/index.js\n ** module id = 37\n ** module chunks = 0\n **/","/**\n * Gets all labels (i.e. node ids) as array, sorted in the `forEachNode()` order\n */\nmodule.exports = getLabels;\n\nfunction getLabels(graph) {\n  var labels = [];\n  graph.forEachNode(saveNode);\n\n  return labels;\n\n  function saveNode(node) {\n    labels.push({id: node.id, data: node.data});\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.tobinary/lib/getLabels.js\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = getLinksBuffer;\n\nfunction getLinksBuffer(graph, labels) {\n  var nodeMap = Object.create(null);\n\n  labels.forEach(function(element, i) {\n    // +1 to avoid 0 uncertainty\n    nodeMap[element] = i + 1;\n  });\n\n  var linksCount = graph.getLinksCount();\n  var buf = new Buffer((labels.length + linksCount) * 4);\n  var idx = 0;\n\n  graph.forEachNode(function(node) {\n    var startWriten = false;\n    var start = nodeMap[node.id];\n    graph.forEachLinkedNode(node.id, saveLink, true);\n\n    function saveLink(node) {\n      if (!startWriten) {\n        startWriten = true;\n        buf.writeInt32LE(-start, idx);\n        idx += 4;\n      }\n      var other = nodeMap[node.id];\n\n      buf.writeInt32LE(other, idx);\n      idx += 4;\n    }\n  });\n\n  return buf.slice(0, idx);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.tobinary/lib/getLinksBuffer.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\n/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar IndexFile = require('./index_file'),\n    DataFile = require('./data_file');\n\nfunction pushResults(data, results, offsets, callback) {\n  var wordnet = this;\n\n  if (offsets.length == 0) {\n    callback(results);\n  } else {\n    data.get(offsets.pop(), function (record) {\n      results.push(record);\n      wordnet.pushResults(data, results, offsets, callback);\n    });\n  }\n}\n\nfunction lookupFromFiles(files, results, word, callback) {\n  var wordnet = this;\n\n  if (files.length == 0) callback(results);else {\n    var file = files.pop();\n\n    file.index.lookup(word, function (record) {\n      if (record) {\n        wordnet.pushResults(file.data, results, record.synsetOffset, function () {\n          wordnet.lookupFromFiles(files, results, word, callback);\n        });\n      } else {\n        wordnet.lookupFromFiles(files, results, word, callback);\n      }\n    });\n  }\n}\n\nfunction lookup(word, callback) {\n  word = word.toLowerCase().replace(/\\s+/g, '_');\n\n  this.lookupFromFiles([{ index: this.nounIndex, data: this.nounData }, { index: this.verbIndex, data: this.verbData }, { index: this.adjIndex, data: this.adjData }, { index: this.advIndex, data: this.advData }], [], word, callback);\n}\n\nfunction get(synsetOffset, pos, callback) {\n  var dataFile = this.getDataFile(pos);\n  var wordnet = this;\n\n  dataFile.get(synsetOffset, function (result) {\n    callback(result);\n  });\n}\n\nfunction getDataFile(pos) {\n  switch (pos) {\n    case 'n':\n      return this.nounData;\n    case 'v':\n      return this.verbData;\n    case 'a':case 's':\n      return this.adjData;\n    case 'r':\n      return this.advData;\n  }\n}\n\nfunction loadSynonyms(synonyms, results, ptrs, callback) {\n  var wordnet = this;\n\n  if (ptrs.length > 0) {\n    var ptr = ptrs.pop();\n\n    this.get(ptr.synsetOffset, ptr.pos, function (result) {\n      synonyms.push(result);\n      wordnet.loadSynonyms(synonyms, results, ptrs, callback);\n    });\n  } else {\n    wordnet.loadResultSynonyms(synonyms, results, callback);\n  }\n}\n\nfunction loadResultSynonyms(synonyms, results, callback) {\n  var wordnet = this;\n\n  if (results.length > 0) {\n    var result = results.pop();\n    wordnet.loadSynonyms(synonyms, results, result.ptrs, callback);\n  } else callback(synonyms);\n}\n\nfunction lookupSynonyms(word, callback) {\n  var wordnet = this;\n\n  wordnet.lookup(word, function (results) {\n    wordnet.loadResultSynonyms([], results, callback);\n  });\n}\n\nfunction getSynonyms() {\n  var wordnet = this;\n  var callback = arguments[2] ? arguments[2] : arguments[1];\n  var pos = arguments[0].pos ? arguments[0].pos : arguments[1];\n  var synsetOffset = arguments[0].synsetOffset ? arguments[0].synsetOffset : arguments[0];\n\n  this.get(synsetOffset, pos, function (result) {\n    wordnet.loadSynonyms([], [], result.ptrs, callback);\n  });\n}\n\nfunction WordNet(dataDir) {\n\n  if (!dataDir) {\n    try {\n      var WNdb = require('wordnet-db');\n    } catch (e) {\n      console.error(\"Please 'npm install wordnet-db' before using WordNet module or specify a dict directory.\");\n      throw e;\n    }\n    dataDir = WNdb.path;\n  }\n\n  this.nounIndex = new IndexFile(dataDir, 'noun');\n  this.verbIndex = new IndexFile(dataDir, 'verb');\n  this.adjIndex = new IndexFile(dataDir, 'adj');\n  this.advIndex = new IndexFile(dataDir, 'adv');\n\n  this.nounData = new DataFile(dataDir, 'noun');\n  this.verbData = new DataFile(dataDir, 'verb');\n  this.adjData = new DataFile(dataDir, 'adj');\n  this.advData = new DataFile(dataDir, 'adv');\n\n  this.get = get;\n  this.lookup = lookup;\n  this.lookupFromFiles = lookupFromFiles;\n  this.pushResults = pushResults;\n  this.loadResultSynonyms = loadResultSynonyms;\n  this.loadSynonyms = loadSynonyms;\n  this.lookupSynonyms = lookupSynonyms;\n  this.getSynonyms = getSynonyms;\n  this.getDataFile = getDataFile;\n}\n\nmodule.exports = WordNet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/wordnet/wordnet.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\n/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar WordNetFile = require('./wordnet_file'),\n    fs = require('fs'),\n    util = require('util');\n\nfunction getFileSize(path) {\n  var stat = fs.statSync(path);\n  return stat.size;\n}\n\nfunction findPrevEOL(fd, pos, callback) {\n  var buff = new Buffer(1024);\n  if (pos == 0) callback(0);else {\n    fs.read(fd, buff, 0, 1, pos, function (err, count) {\n      if (buff[0] == 10) callback(pos + 1);else findPrevEOL(fd, pos - 1, callback);\n    });\n  }\n}\n\nfunction readLine(fd, pos, callback) {\n  var buff = new Buffer(1024);\n  findPrevEOL(fd, pos, function (pos) {\n    WordNetFile.appendLineChar(fd, pos, 0, buff, callback);\n  });\n}\n\nfunction miss(callback) {\n  callback({ status: 'miss' });\n}\n\nfunction findAt(fd, size, pos, lastPos, adjustment, searchKey, callback, lastKey) {\n  if (lastPos == pos || pos >= size) {\n    miss(callback);\n  } else {\n    readLine(fd, pos, function (line) {\n      var tokens = line.split(/\\s+/);\n      var key = tokens[0];\n\n      if (key == searchKey) {\n        callback({ status: 'hit', key: key, 'line': line, tokens: tokens });\n      } else if (adjustment == 1 || key == lastKey) {\n        miss(callback);\n      } else {\n        adjustment = Math.ceil(adjustment * 0.5);\n\n        if (key < searchKey) {\n          findAt(fd, size, pos + adjustment, pos, adjustment, searchKey, callback, key);\n        } else {\n          findAt(fd, size, pos - adjustment, pos, adjustment, searchKey, callback, key);\n        }\n      }\n    });\n  }\n}\n\nfunction find(searchKey, callback) {\n  var indexFile = this;\n\n  indexFile.open(function (err, fd, done) {\n    if (err) {\n      console.log(err);\n    } else {\n      var size = getFileSize(indexFile.filePath) - 1;\n      var pos = Math.ceil(size / 2);\n      findAt(fd, size, pos, null, pos, searchKey, function (result) {\n        callback(result);done();\n      });\n    }\n  });\n}\n\nfunction lookupFromFile(word, callback) {\n  this.find(word, function (record) {\n    var indexRecord = null;\n\n    if (record.status == 'hit') {\n      var ptrs = [],\n          offsets = [];\n\n      for (var i = 0; i < parseInt(record.tokens[3]); i++) {\n        ptrs.push(record.tokens[i]);\n      }for (var i = 0; i < parseInt(record.tokens[2]); i++) {\n        offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));\n      }indexRecord = {\n        lemma: record.tokens[0],\n        pos: record.tokens[1],\n        ptrSymbol: ptrs,\n        senseCnt: parseInt(record.tokens[ptrs.length + 4], 10),\n        tagsenseCnt: parseInt(record.tokens[ptrs.length + 5], 10),\n        synsetOffset: offsets\n      };\n    }\n\n    callback(indexRecord);\n  });\n}\n\nfunction lookup(word, callback) {\n  this.lookupFromFile(word, callback);\n}\n\nvar IndexFile = function IndexFile(dataDir, name) {\n  WordNetFile.call(this, dataDir, 'index.' + name);\n};\n\nutil.inherits(IndexFile, WordNetFile);\n\nIndexFile.prototype.lookupFromFile = lookupFromFile;\nIndexFile.prototype.lookup = lookup;\nIndexFile.prototype.find = find;\n\nIndexFile.prototype._findAt = findAt;\n\nmodule.exports = IndexFile;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/wordnet/index_file.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\n/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar fs = require('fs'),\n    path = require('path'),\n    util = require('util');\n\nfunction appendLineChar(fd, pos, buffPos, buff, callback) {\n  if (buffPos >= buff.length) {\n    var newBuff = new Buffer(buff.length * 2);\n    buff.copy(newBuff, 0, 0, buff.length);\n    buff = newBuff;\n  }\n\n  fs.read(fd, buff, buffPos, 1, pos, function (err, count) {\n    if (err) console.log(err);else {\n      if (buff[buffPos] == 10 || buffPos == buff.length) callback(buff.slice(0, buffPos).toString('UTF-8'));else {\n        appendLineChar(fd, pos + 1, buffPos + 1, buff, callback);\n      }\n    }\n  });\n}\n\nfunction open(callback) {\n  var filePath = this.filePath;\n\n  fs.open(filePath, 'r', null, function (err, fd) {\n    if (err) {\n      console.log('Unable to open %s', filePath);\n      return;\n    }\n    callback(err, fd, function () {\n      fs.close(fd);\n    });\n  });\n}\n\nvar WordNetFile = function WordNetFile(dataDir, fileName) {\n  this.dataDir = dataDir;\n  this.fileName = fileName;\n  this.filePath = require('path').join(this.dataDir, this.fileName);\n};\n\nWordNetFile.prototype.open = open;\nWordNetFile.appendLineChar = appendLineChar;\n\nmodule.exports = WordNetFile;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/wordnet/wordnet_file.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n\n/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar WordNetFile = require('./wordnet_file'),\n    fs = require('fs'),\n    util = require('util');\n\nfunction get(location, callback) {\n  var buff = new Buffer(4096);\n\n  this.open(function (err, fd, done) {\n    WordNetFile.appendLineChar(fd, location, 0, buff, function (line) {\n      done();\n      var data = line.split('| ');\n      var tokens = data[0].split(/\\s+/);\n      var ptrs = [];\n      var wCnt = parseInt(tokens[3], 16);\n      var synonyms = [];\n\n      for (var i = 0; i < wCnt; i++) {\n        synonyms.push(tokens[4 + i * 2]);\n      }\n\n      var ptrOffset = (wCnt - 1) * 2 + 6;\n      for (var i = 0; i < parseInt(tokens[ptrOffset], 10); i++) {\n        ptrs.push({\n          pointerSymbol: tokens[ptrOffset + 1 + i * 4],\n          synsetOffset: parseInt(tokens[ptrOffset + 2 + i * 4], 10),\n          pos: tokens[ptrOffset + 3 + i * 4],\n          sourceTarget: tokens[ptrOffset + 4 + i * 4]\n        });\n      }\n\n      // break \"gloss\" into definition vs. examples\n      var glossArray = data[1].split(\"; \");\n      var definition = glossArray[0];\n      var examples = glossArray.slice(1);\n\n      for (var k = 0; k < examples.length; k++) {\n        examples[k] = examples[k].replace(/\\\"/g, '').replace(/\\s\\s+/g, '');\n      }\n\n      callback({\n        synsetOffset: parseInt(tokens[0], 10),\n        lexFilenum: parseInt(tokens[1], 10),\n        pos: tokens[2],\n        wCnt: wCnt,\n        lemma: tokens[4],\n        synonyms: synonyms,\n        lexId: tokens[5],\n        ptrs: ptrs,\n        gloss: data[1],\n        def: definition,\n        exp: examples\n      });\n    });\n  });\n}\n\nvar DataFile = function DataFile(dataDir, name) {\n  WordNetFile.call(this, dataDir, 'data.' + name);\n};\n\nutil.inherits(DataFile, WordNetFile);\nDataFile.prototype.get = get;\n\nmodule.exports = DataFile;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/server/wordnet/data_file.js\n ** module id = 44\n ** module chunks = 0\n **/","\r\nexports.version = \"3.1\";\t// this is the WordNet DB version\r\nexports.path = require('path').join(__dirname, \"dict\");\r\nexports.files = require('fs').readdirSync(exports.path);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/wordnet-db/index.js\n ** module id = 45\n ** module chunks = 0\n **/","/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = require('ngraph.events');\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if (options.uniqueLinkId === undefined) {\n    // Request each link id to be unique between same nodes. This negatively\n    // impacts `addLink()` performance (O(n), where n - number of edges of each\n    // vertex), but makes operations with multigraphs more accessible.\n    options.uniqueLinkId = true;\n  }\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.uniqueLinkId ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function() {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function() {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      recordNodeChange(node, 'update');\n    }\n\n    node.data = data;\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    if (node.links) {\n      while (node.links.length) {\n        var link = node.links[0];\n        removeLink(link);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id) {\n  this.id = id;\n  this.links = null;\n  this.data = null;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return hashCode(fromId.toString() + ' ' + toId.toString());\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.graph/index.js\n ** module id = 46\n ** module chunks = 0\n **/","var createRandomIterator = require('ngraph.random').randomIterator;\nvar createRandom = require('ngraph.random').random;\n\nmodule.exports = createChineseWhisper;\n\nfunction createChineseWhisper(graph, kind) {\n  var api = {\n    step: step,\n    getClass: getClass,\n    getChangeRate: getChangeRate,\n    forEachCluster: forEachCluster,\n    createClusterMap: createClusterMap\n  };\n\n  var changeRate = 1;\n  var classChangesCount = 0;\n  var random = createRandom(42);\n  var iterator;\n  var classMap = new Map();\n  var nodeIds = [];\n\n  initInternalStructures();\n\n  return api;\n\n  function step() {\n    classChangesCount = 0;\n    iterator.forEach(assignHighestClass);\n    changeRate = classChangesCount/nodeIds.length;\n  }\n\n  function getChangeRate() {\n    return changeRate;\n  }\n\n  function getClass(nodeId) {\n    return classMap.get(nodeId);\n  }\n\n  function initInternalStructures() {\n    graph.forEachNode(initNodeClass);\n    iterator = createRandomIterator(nodeIds, random);\n\n    function initNodeClass(node) {\n      classMap.set(node.id, nodeIds.length);\n      nodeIds.push(node.id);\n    }\n  }\n\n  function assignHighestClass(nodeId) {\n    var newLevel = getHighestClassInTheNeighborhoodOf(nodeId);\n    var currentLevel = classMap.get(nodeId);\n    if (newLevel !== currentLevel) {\n      classMap.set(nodeId, newLevel);\n      classChangesCount += 1;\n    }\n  }\n\n  function getHighestClassInTheNeighborhoodOf(nodeId) {\n    var seenClasses = new Map();\n    var maxClassValue = 0;\n    var maxClassName = -1;\n\n    graph.forEachLinkedNode(nodeId, visitNeighbour);\n\n    if (maxClassName === -1) {\n      // the node didn't have any neighbours\n      return classMap.get(nodeId);\n    }\n\n    return maxClassName;\n\n    function visitNeighbour(otherNode, link) {\n      if (shouldUpdate(link.toId === nodeId)) {\n        var otherNodeClass = classMap.get(otherNode.id);\n        var counter = seenClasses.get(otherNodeClass) || 0;\n        counter += 1;\n        if (counter > maxClassValue) {\n          maxClassValue = counter;\n          maxClassName = otherNodeClass;\n        }\n\n        seenClasses.set(otherNodeClass, counter);\n      }\n    }\n  }\n\n  function shouldUpdate(isInLink) {\n    if (kind === 'in') return isInLink;\n    if (kind === 'out') return !isInLink;\n    return true;\n  }\n\n  function createClusterMap() {\n    var clusters = new Map();\n\n    for (var i = 0; i < nodeIds.length; ++i) {\n      var nodeId = nodeIds[i];\n      var clusterId = getClass(nodeId);\n      var nodesInCluster = clusters.get(clusterId);\n      if (nodesInCluster) nodesInCluster.push(nodeId);\n      else clusters.set(clusterId, [nodeId]);\n    }\n\n    return clusters;\n  }\n\n  function forEachCluster(cb) {\n    var clusters = createClusterMap();\n\n    clusters.forEach(reportToClient);\n\n    function reportToClient(value, key) {\n      cb({\n        class: key,\n        nodes: value\n      });\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.cw/index.js\n ** module id = 47\n ** module chunks = 0\n **/","var createGraph = require('ngraph.graph');\n\nmodule.exports = coarsen;\n\nfunction coarsen(srcGraph, community) {\n  if (typeof community.canCoarse === 'function') {\n    if (!community.canCoarse()) {\n       console.warn('Cannot coarse anymore');\n    }\n  }\n\n  var graph = createGraph({\n    uniqueLinkId: false\n  });\n\n  srcGraph.forEachLink(function(srcLink) {\n    var fromCommunity = community.getClass(srcLink.fromId);\n    var toCommunity = community.getClass(srcLink.toId);\n\n    if (fromCommunity === toCommunity) {\n      makeSureNodeAdded(fromCommunity, srcLink.fromId);\n      makeSureNodeAdded(fromCommunity, srcLink.toId);\n    } else {\n      makeSureNodeAdded(fromCommunity, srcLink.fromId);\n      makeSureNodeAdded(toCommunity, srcLink.toId);\n    }\n\n    var link = graph.getLink(fromCommunity, toCommunity);\n    if (!link) link = graph.addLink(fromCommunity, toCommunity, 0);\n    link.data += getWeight(srcLink.data);\n  });\n\n  return graph;\n\n  function makeSureNodeAdded(nodeId, srcNodeId) {\n    var node = graph.getNode(nodeId);\n    if (!node) node = graph.addNode(nodeId, new Set());\n\n    node.data.add(srcNodeId);\n\n    return node;\n  }\n}\n\nfunction getWeight(data) {\n  if (!data) return 1;\n\n  if (typeof data === 'number') return data;\n  if (typeof data.weight === 'number') return data.weight;\n\n  return 1;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.coarsen/index.js\n ** module id = 48\n ** module chunks = 0\n **/","var DisjointSet = require('ngraph.disjoint-set');\nmodule.exports = kruskal;\n\nfunction kruskal(graph, getWeight) {\n  var tree = [];\n  getWeight = getWeight || uniformWeight;\n  // map of disjoint sets for quick lookup\n  var nodes = new Map();\n  // Sorted array of edges by their weight\n  var links = [];\n\n  graph.forEachNode(initSet);\n  graph.forEachLink(initLink);\n  links.sort(byWeight);\n\n  for (var i = 0; i < links.length; ++i) {\n    var fromId = links[i].fromId;\n    var toId = links[i].toId;\n    var fromSet = nodes.get(fromId);\n    var toSet = nodes.get(toId);\n    if (fromSet.find() !== toSet.find()) {\n      tree.push(new TreeNode(fromId, toId));\n      fromSet.union(toSet);\n    }\n  }\n\n  return tree;\n\n  function initLink(link) {\n    links.push(link);\n  }\n\n  function initSet(node) {\n    nodes.set(node.id, new DisjointSet(node.id));\n  }\n\n  function byWeight(x, y) {\n    return getWeight(x) - getWeight(y);\n  }\n}\n\nfunction uniformWeight(link) {\n  return 1;\n}\n\nfunction TreeNode(fromId, toId) {\n  this.fromId = fromId;\n  this.toId = toId;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.kruskal/index.js\n ** module id = 49\n ** module chunks = 0\n **/","module.exports = DisjointSet;\n\nfunction DisjointSet(payload) {\n  this.payload = payload;\n  this.parent = this;\n  this.rank = 0;\n}\n\nDisjointSet.prototype.find = find;\nDisjointSet.prototype.union = union;\n\nfunction find() {\n  var parent = this.parent;\n  if (parent !== this) {\n    // compress so that in future we ran faster:\n    this.parent = parent.find();\n  }\n\n  return this.parent;\n}\n\nfunction union(y) {\n  var ourParent = this.find();\n  var theirParent = y.find();\n\n  if (theirParent === ourParent) return; // we are in the same set\n\n  if (ourParent.rank < theirParent.rank) {\n    ourParent.parent = theirParent;\n  } else if (ourParent.rank > theirParent.rank) {\n    theirParent.parent = ourParent;\n  } else {\n    theirParent.parent = ourParent;\n    ourParent.rank += 1;\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.disjoint-set/index.js\n ** module id = 50\n ** module chunks = 0\n **/","module.exports.degree = require('./src/degree.js');\nmodule.exports.betweenness = require('./src/betweenness.js');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.centrality/index.js\n ** module id = 51\n ** module chunks = 0\n **/","module.exports = degree;\n\n/**\n * Calculates graph nodes degree centrality (in/out or both).\n *\n * @see http://en.wikipedia.org/wiki/Centrality#Degree_centrality\n *\n * @param {ngraph.graph} graph object for which we are calculating centrality.\n * @param {string} [kind=both] What kind of degree centrality needs to be calculated:\n *   'in'    - calculate in-degree centrality\n *   'out'   - calculate out-degree centrality\n *   'inout' - (default) generic degree centrality is calculated\n */\nfunction degree(graph, kind) {\n  var getNodeDegree,\n    sortedDegrees = [],\n    result = Object.create(null),\n    nodeDegree;\n\n  kind = (kind || 'both').toLowerCase();\n  if (kind === 'both' || kind === 'inout') {\n    getNodeDegree = inoutDegreeCalculator;\n  } else if (kind === 'in') {\n    getNodeDegree = inDegreeCalculator;\n  } else if (kind === 'out') {\n    getNodeDegree = outDegreeCalculator;\n  } else {\n    throw new Error('Expected centrality degree kind is: in, out or both');\n  }\n\n  graph.forEachNode(calculateNodeDegree);\n\n  return result;\n\n  function calculateNodeDegree(node) {\n    var links = graph.getLinks(node.id);\n    result[node.id] = getNodeDegree(links, node.id);\n  }\n}\n\nfunction inDegreeCalculator(links, nodeId) {\n  var total = 0;\n  if (!links) return total;\n\n  for (var i = 0; i < links.length; i += 1) {\n    total += (links[i].toId === nodeId) ? 1 : 0;\n  }\n  return total;\n}\n\nfunction outDegreeCalculator(links, nodeId) {\n  var total = 0;\n  if (!links) return total;\n\n  for (var i = 0; i < links.length; i += 1) {\n    total += (links[i].fromId === nodeId) ? 1 : 0;\n  }\n  return total;\n}\n\nfunction inoutDegreeCalculator(links) {\n  if (!links) return 0;\n\n  return links.length;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.centrality/src/degree.js\n ** module id = 52\n ** module chunks = 0\n **/","module.exports = betweennes;\n\n/**\n * I'm using http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n * as a reference for this implementation\n */\nfunction betweennes(graph, oriented) {\n  var Q = [],\n    S = []; // Queue and Stack\n  // list of predcessors on shorteest paths from source\n  var pred = Object.create(null);\n  // distance from source\n  var dist = Object.create(null);\n  // number of shortest paths from source to key\n  var sigma = Object.create(null);\n  // dependency of source on key\n  var delta = Object.create(null);\n\n  var currentNode;\n  var centrality = Object.create(null);\n\n  graph.forEachNode(setCentralityToZero);\n  graph.forEachNode(calculateCentrality);\n\n  if (!oriented) {\n    // The centrality scores need to be divided by two if the graph is not oriented,\n    // since all shortest paths are considered twice\n    Object.keys(centrality).forEach(divideByTwo);\n  }\n\n  return centrality;\n\n  function divideByTwo(key) {\n    centrality[key] /= 2;\n  }\n\n  function setCentralityToZero(node) {\n    centrality[node.id] = 0;\n  }\n\n  function calculateCentrality(node) {\n    currentNode = node.id;\n    singleSourceShortestPath(currentNode);\n    accumulate();\n  }\n\n  function accumulate() {\n    graph.forEachNode(setDeltaToZero);\n    while (S.length) {\n      var w = S.pop();\n      var coeff = (1 + delta[w])/sigma[w];\n      var predcessors = pred[w];\n      for (var idx = 0; idx < predcessors.length; ++idx) {\n        var v = predcessors[idx];\n        delta[v] += sigma[v] * coeff;\n      }\n      if (w !== currentNode) {\n        centrality[w] += delta[w];\n      }\n    }\n  }\n\n  function setDeltaToZero(node) {\n    delta[node.id] = 0;\n  }\n\n  function singleSourceShortestPath(source) {\n    graph.forEachNode(initNode);\n    dist[source] = 0;\n    sigma[source] = 1;\n    Q.push(source);\n\n    while (Q.length) {\n      var v = Q.shift();\n      var dedup = Object.create(null);\n      S.push(v);\n      graph.forEachLinkedNode(v, toId, oriented);\n    }\n\n    function toId(otherNode) {\n      // NOTE: This code will also consider multi-edges, which are often\n      // ignored by popular software (Gephi/NetworkX). Depending on your use\n      // case this may not be desired and deduping needs to be performed. To\n      // save memory I'm not deduping here...\n      processNode(otherNode.id);\n    }\n\n    function initNode(node) {\n      var nodeId = node.id;\n      pred[nodeId] = []; // empty list\n      dist[nodeId] = -1;\n      sigma[nodeId] = 0;\n    }\n\n    function processNode(w) {\n      // path discovery\n      if (dist[w] === -1) {\n        // Node w is found for the first time\n        dist[w] = dist[v] + 1;\n        Q.push(w);\n      }\n      // path counting\n      if (dist[w] === dist[v] + 1) {\n        // edge (v, w) on a shortest path\n        sigma[w] += sigma[v];\n        pred[w].push(v);\n      }\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngraph.centrality/src/betweenness.js\n ** module id = 53\n ** module chunks = 0\n **/"]}}]