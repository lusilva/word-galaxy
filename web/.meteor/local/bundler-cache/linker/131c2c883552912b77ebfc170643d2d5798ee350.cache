[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar ObserveSequence, seqChangedToEmpty, seqChangedToArray, seqChangedToCursor;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/observe-sequence/observe_sequence.js                                 //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nvar warn = function () {                                                         // 1\n  if (ObserveSequence._suppressWarnings) {                                       // 2\n    ObserveSequence._suppressWarnings--;                                         // 3\n  } else {                                                                       // 4\n    if (typeof console !== 'undefined' && console.warn)                          // 5\n      console.warn.apply(console, arguments);                                    // 6\n                                                                                 // 7\n    ObserveSequence._loggedWarnings++;                                           // 8\n  }                                                                              // 9\n};                                                                               // 10\n                                                                                 // 11\nvar idStringify = MongoID.idStringify;                                           // 12\nvar idParse = MongoID.idParse;                                                   // 13\n                                                                                 // 14\nObserveSequence = {                                                              // 15\n  _suppressWarnings: 0,                                                          // 16\n  _loggedWarnings: 0,                                                            // 17\n                                                                                 // 18\n  // A mechanism similar to cursor.observe which receives a reactive             // 19\n  // function returning a sequence type and firing appropriate callbacks         // 20\n  // when the value changes.                                                     // 21\n  //                                                                             // 22\n  // @param sequenceFunc {Function} a reactive function returning a              // 23\n  //     sequence type. The currently supported sequence types are:              // 24\n  //     Array, Cursor, and null.                                                // 25\n  //                                                                             // 26\n  // @param callbacks {Object} similar to a specific subset of                   // 27\n  //     callbacks passed to `cursor.observe`                                    // 28\n  //     (http://docs.meteor.com/#observe), with minor variations to             // 29\n  //     support the fact that not all sequences contain objects with            // 30\n  //     _id fields.  Specifically:                                              // 31\n  //                                                                             // 32\n  //     * addedAt(id, item, atIndex, beforeId)                                  // 33\n  //     * changedAt(id, newItem, oldItem, atIndex)                              // 34\n  //     * removedAt(id, oldItem, atIndex)                                       // 35\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)                       // 36\n  //                                                                             // 37\n  // @returns {Object(stop: Function)} call 'stop' on the return value           // 38\n  //     to stop observing this sequence function.                               // 39\n  //                                                                             // 40\n  // We don't make any assumptions about our ability to compare sequence         // 41\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra      // 42\n  // state/random methods on the objects) so unlike cursor.observe, we may       // 43\n  // sometimes call changedAt() when nothing actually changed.                   // 44\n  // XXX consider if we *can* make the stronger assumption and avoid             // 45\n  //     no-op changedAt calls (in some cases?)                                  // 46\n  //                                                                             // 47\n  // XXX currently only supports the callbacks used by our                       // 48\n  // implementation of {{#each}}, but this can be expanded.                      // 49\n  //                                                                             // 50\n  // XXX #each doesn't use the indices (though we'll eventually need             // 51\n  // a way to get them when we support `@index`), but calling                    // 52\n  // `cursor.observe` causes the index to be calculated on every                 // 53\n  // callback using a linear scan (unless you turn it off by passing             // 54\n  // `_no_indices`).  Any way to avoid calculating indices on a pure             // 55\n  // cursor observe like we used to?                                             // 56\n  observe: function (sequenceFunc, callbacks) {                                  // 57\n    var lastSeq = null;                                                          // 58\n    var activeObserveHandle = null;                                              // 59\n                                                                                 // 60\n    // 'lastSeqArray' contains the previous value of the sequence                // 61\n    // we're observing. It is an array of objects with '_id' and                 // 62\n    // 'item' fields.  'item' is the element in the array, or the                // 63\n    // document in the cursor.                                                   // 64\n    //                                                                           // 65\n    // '_id' is whichever of the following is relevant, unless it has            // 66\n    // already appeared -- in which case it's randomly generated.                // 67\n    //                                                                           // 68\n    // * if 'item' is an object:                                                 // 69\n    //   * an '_id' field, if present                                            // 70\n    //   * otherwise, the index in the array                                     // 71\n    //                                                                           // 72\n    // * if 'item' is a number or string, use that value                         // 73\n    //                                                                           // 74\n    // XXX this can be generalized by allowing {{#each}} to accept a             // 75\n    // general 'key' argument which could be a function, a dotted                // 76\n    // field name, or the special @index value.                                  // 77\n    var lastSeqArray = []; // elements are objects of form {_id, item}           // 78\n    var computation = Tracker.autorun(function () {                              // 79\n      var seq = sequenceFunc();                                                  // 80\n                                                                                 // 81\n      Tracker.nonreactive(function () {                                          // 82\n        var seqArray; // same structure as `lastSeqArray` above.                 // 83\n                                                                                 // 84\n        if (activeObserveHandle) {                                               // 85\n          // If we were previously observing a cursor, replace lastSeqArray with\n          // more up-to-date information.  Then stop the old observe.            // 87\n          lastSeqArray = _.map(lastSeq.fetch(), function (doc) {                 // 88\n            return {_id: doc._id, item: doc};                                    // 89\n          });                                                                    // 90\n          activeObserveHandle.stop();                                            // 91\n          activeObserveHandle = null;                                            // 92\n        }                                                                        // 93\n                                                                                 // 94\n        if (!seq) {                                                              // 95\n          seqArray = seqChangedToEmpty(lastSeqArray, callbacks);                 // 96\n        } else if (seq instanceof Array) {                                       // 97\n          seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);            // 98\n        } else if (isStoreCursor(seq)) {                                         // 99\n          var result /* [seqArray, activeObserveHandle] */ =                     // 100\n                seqChangedToCursor(lastSeqArray, seq, callbacks);                // 101\n          seqArray = result[0];                                                  // 102\n          activeObserveHandle = result[1];                                       // 103\n        } else {                                                                 // 104\n          throw badSequenceError();                                              // 105\n        }                                                                        // 106\n                                                                                 // 107\n        diffArray(lastSeqArray, seqArray, callbacks);                            // 108\n        lastSeq = seq;                                                           // 109\n        lastSeqArray = seqArray;                                                 // 110\n      });                                                                        // 111\n    });                                                                          // 112\n                                                                                 // 113\n    return {                                                                     // 114\n      stop: function () {                                                        // 115\n        computation.stop();                                                      // 116\n        if (activeObserveHandle)                                                 // 117\n          activeObserveHandle.stop();                                            // 118\n      }                                                                          // 119\n    };                                                                           // 120\n  },                                                                             // 121\n                                                                                 // 122\n  // Fetch the items of `seq` into an array, where `seq` is of one of the        // 123\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a              // 124\n  // dependency is established.                                                  // 125\n  fetch: function (seq) {                                                        // 126\n    if (!seq) {                                                                  // 127\n      return [];                                                                 // 128\n    } else if (seq instanceof Array) {                                           // 129\n      return seq;                                                                // 130\n    } else if (isStoreCursor(seq)) {                                             // 131\n      return seq.fetch();                                                        // 132\n    } else {                                                                     // 133\n      throw badSequenceError();                                                  // 134\n    }                                                                            // 135\n  }                                                                              // 136\n};                                                                               // 137\n                                                                                 // 138\nvar badSequenceError = function () {                                             // 139\n  return new Error(\"{{#each}} currently only accepts \" +                         // 140\n                   \"arrays, cursors or falsey values.\");                         // 141\n};                                                                               // 142\n                                                                                 // 143\nvar isStoreCursor = function (cursor) {                                          // 144\n  return cursor && _.isObject(cursor) &&                                         // 145\n    _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);                  // 146\n};                                                                               // 147\n                                                                                 // 148\n// Calculates the differences between `lastSeqArray` and                         // 149\n// `seqArray` and calls appropriate functions from `callbacks`.                  // 150\n// Reuses Minimongo's diff algorithm implementation.                             // 151\nvar diffArray = function (lastSeqArray, seqArray, callbacks) {                   // 152\n  var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;    // 153\n  var oldIdObjects = [];                                                         // 154\n  var newIdObjects = [];                                                         // 155\n  var posOld = {}; // maps from idStringify'd ids                                // 156\n  var posNew = {}; // ditto                                                      // 157\n  var posCur = {};                                                               // 158\n  var lengthCur = lastSeqArray.length;                                           // 159\n                                                                                 // 160\n  _.each(seqArray, function (doc, i) {                                           // 161\n    newIdObjects.push({_id: doc._id});                                           // 162\n    posNew[idStringify(doc._id)] = i;                                            // 163\n  });                                                                            // 164\n  _.each(lastSeqArray, function (doc, i) {                                       // 165\n    oldIdObjects.push({_id: doc._id});                                           // 166\n    posOld[idStringify(doc._id)] = i;                                            // 167\n    posCur[idStringify(doc._id)] = i;                                            // 168\n  });                                                                            // 169\n                                                                                 // 170\n  // Arrays can contain arbitrary objects. We don't diff the                     // 171\n  // objects. Instead we always fire 'changedAt' callback on every               // 172\n  // object. The consumer of `observe-sequence` should deal with                 // 173\n  // it appropriately.                                                           // 174\n  diffFn(oldIdObjects, newIdObjects, {                                           // 175\n    addedBefore: function (id, doc, before) {                                    // 176\n      var position = before ? posCur[idStringify(before)] : lengthCur;           // 177\n                                                                                 // 178\n      if (before) {                                                              // 179\n        // If not adding at the end, we need to update indexes.                  // 180\n        // XXX this can still be improved greatly!                               // 181\n        _.each(posCur, function (pos, id) {                                      // 182\n          if (pos >= position)                                                   // 183\n            posCur[id]++;                                                        // 184\n        });                                                                      // 185\n      }                                                                          // 186\n                                                                                 // 187\n      lengthCur++;                                                               // 188\n      posCur[idStringify(id)] = position;                                        // 189\n                                                                                 // 190\n      callbacks.addedAt(                                                         // 191\n        id,                                                                      // 192\n        seqArray[posNew[idStringify(id)]].item,                                  // 193\n        position,                                                                // 194\n        before);                                                                 // 195\n    },                                                                           // 196\n    movedBefore: function (id, before) {                                         // 197\n      if (id === before)                                                         // 198\n        return;                                                                  // 199\n                                                                                 // 200\n      var oldPosition = posCur[idStringify(id)];                                 // 201\n      var newPosition = before ? posCur[idStringify(before)] : lengthCur;        // 202\n                                                                                 // 203\n      // Moving the item forward. The new element is losing one position as it   // 204\n      // was removed from the old position before being inserted at the new      // 205\n      // position.                                                               // 206\n      // Ex.:   0  *1*  2   3   4                                                // 207\n      //        0   2   3  *1*  4                                                // 208\n      // The original issued callback is \"1\" before \"4\".                         // 209\n      // The position of \"1\" is 1, the position of \"4\" is 4.                     // 210\n      // The generated move is (1) -> (3)                                        // 211\n      if (newPosition > oldPosition) {                                           // 212\n        newPosition--;                                                           // 213\n      }                                                                          // 214\n                                                                                 // 215\n      // Fix up the positions of elements between the old and the new positions  // 216\n      // of the moved element.                                                   // 217\n      //                                                                         // 218\n      // There are two cases:                                                    // 219\n      //   1. The element is moved forward. Then all the positions in between    // 220\n      //   are moved back.                                                       // 221\n      //   2. The element is moved back. Then the positions in between *and* the\n      //   element that is currently standing on the moved element's future      // 223\n      //   position are moved forward.                                           // 224\n      _.each(posCur, function (elCurPosition, id) {                              // 225\n        if (oldPosition < elCurPosition && elCurPosition < newPosition)          // 226\n          posCur[id]--;                                                          // 227\n        else if (newPosition <= elCurPosition && elCurPosition < oldPosition)    // 228\n          posCur[id]++;                                                          // 229\n      });                                                                        // 230\n                                                                                 // 231\n      // Finally, update the position of the moved element.                      // 232\n      posCur[idStringify(id)] = newPosition;                                     // 233\n                                                                                 // 234\n      callbacks.movedTo(                                                         // 235\n        id,                                                                      // 236\n        seqArray[posNew[idStringify(id)]].item,                                  // 237\n        oldPosition,                                                             // 238\n        newPosition,                                                             // 239\n        before);                                                                 // 240\n    },                                                                           // 241\n    removed: function (id) {                                                     // 242\n      var prevPosition = posCur[idStringify(id)];                                // 243\n                                                                                 // 244\n      _.each(posCur, function (pos, id) {                                        // 245\n        if (pos >= prevPosition)                                                 // 246\n          posCur[id]--;                                                          // 247\n      });                                                                        // 248\n                                                                                 // 249\n      delete posCur[idStringify(id)];                                            // 250\n      lengthCur--;                                                               // 251\n                                                                                 // 252\n      callbacks.removedAt(                                                       // 253\n        id,                                                                      // 254\n        lastSeqArray[posOld[idStringify(id)]].item,                              // 255\n        prevPosition);                                                           // 256\n    }                                                                            // 257\n  });                                                                            // 258\n                                                                                 // 259\n  _.each(posNew, function (pos, idString) {                                      // 260\n    var id = idParse(idString);                                                  // 261\n    if (_.has(posOld, idString)) {                                               // 262\n      // specifically for primitive types, compare equality before               // 263\n      // firing the 'changedAt' callback. otherwise, always fire it              // 264\n      // because doing a deep EJSON comparison is not guaranteed to              // 265\n      // work (an array can contain arbitrary objects, and 'transform'           // 266\n      // can be used on cursors). also, deep diffing is not                      // 267\n      // necessarily the most efficient (if only a specific subfield             // 268\n      // of the object is later accessed).                                       // 269\n      var newItem = seqArray[pos].item;                                          // 270\n      var oldItem = lastSeqArray[posOld[idString]].item;                         // 271\n                                                                                 // 272\n      if (typeof newItem === 'object' || newItem !== oldItem)                    // 273\n          callbacks.changedAt(id, newItem, oldItem, pos);                        // 274\n      }                                                                          // 275\n  });                                                                            // 276\n};                                                                               // 277\n                                                                                 // 278\nseqChangedToEmpty = function (lastSeqArray, callbacks) {                         // 279\n  return [];                                                                     // 280\n};                                                                               // 281\n                                                                                 // 282\nseqChangedToArray = function (lastSeqArray, array, callbacks) {                  // 283\n  var idsUsed = {};                                                              // 284\n  var seqArray = _.map(array, function (item, index) {                           // 285\n    var id;                                                                      // 286\n    if (typeof item === 'string') {                                              // 287\n      // ensure not empty, since other layers (eg DomRange) assume this as well  // 288\n      id = \"-\" + item;                                                           // 289\n    } else if (typeof item === 'number' ||                                       // 290\n               typeof item === 'boolean' ||                                      // 291\n               item === undefined) {                                             // 292\n      id = item;                                                                 // 293\n    } else if (typeof item === 'object') {                                       // 294\n      id = (item && _.has(item, '_id')) ? item._id : index;                      // 295\n    } else {                                                                     // 296\n      throw new Error(\"{{#each}} doesn't support arrays with \" +                 // 297\n                      \"elements of type \" + typeof item);                        // 298\n    }                                                                            // 299\n                                                                                 // 300\n    var idString = idStringify(id);                                              // 301\n    if (idsUsed[idString]) {                                                     // 302\n      if (typeof item === 'object' && '_id' in item)                             // 303\n        warn(\"duplicate id \" + id + \" in\", array);                               // 304\n      id = Random.id();                                                          // 305\n    } else {                                                                     // 306\n      idsUsed[idString] = true;                                                  // 307\n    }                                                                            // 308\n                                                                                 // 309\n    return { _id: id, item: item };                                              // 310\n  });                                                                            // 311\n                                                                                 // 312\n  return seqArray;                                                               // 313\n};                                                                               // 314\n                                                                                 // 315\nseqChangedToCursor = function (lastSeqArray, cursor, callbacks) {                // 316\n  var initial = true; // are we observing initial data from cursor?              // 317\n  var seqArray = [];                                                             // 318\n                                                                                 // 319\n  var observeHandle = cursor.observe({                                           // 320\n    addedAt: function (document, atIndex, before) {                              // 321\n      if (initial) {                                                             // 322\n        // keep track of initial data so that we can diff once                   // 323\n        // we exit `observe`.                                                    // 324\n        if (before !== null)                                                     // 325\n          throw new Error(\"Expected initial data from observe in order\");        // 326\n        seqArray.push({ _id: document._id, item: document });                    // 327\n      } else {                                                                   // 328\n        callbacks.addedAt(document._id, document, atIndex, before);              // 329\n      }                                                                          // 330\n    },                                                                           // 331\n    changedAt: function (newDocument, oldDocument, atIndex) {                    // 332\n      callbacks.changedAt(newDocument._id, newDocument, oldDocument,             // 333\n                          atIndex);                                              // 334\n    },                                                                           // 335\n    removedAt: function (oldDocument, atIndex) {                                 // 336\n      callbacks.removedAt(oldDocument._id, oldDocument, atIndex);                // 337\n    },                                                                           // 338\n    movedTo: function (document, fromIndex, toIndex, before) {                   // 339\n      callbacks.movedTo(                                                         // 340\n        document._id, document, fromIndex, toIndex, before);                     // 341\n    }                                                                            // 342\n  });                                                                            // 343\n  initial = false;                                                               // 344\n                                                                                 // 345\n  return [seqArray, observeHandle];                                              // 346\n};                                                                               // 347\n                                                                                 // 348\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['observe-sequence'] = {\n  ObserveSequence: ObserveSequence\n};\n\n})();\n","servePath":"/packages/observe-sequence.js","sourceMap":{"version":3,"sources":["/packages/observe-sequence/observe_sequence.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uF","file":"/packages/observe-sequence.js","sourcesContent":["var warn = function () {\n  if (ObserveSequence._suppressWarnings) {\n    ObserveSequence._suppressWarnings--;\n  } else {\n    if (typeof console !== 'undefined' && console.warn)\n      console.warn.apply(console, arguments);\n\n    ObserveSequence._loggedWarnings++;\n  }\n};\n\nvar idStringify = MongoID.idStringify;\nvar idParse = MongoID.idParse;\n\nObserveSequence = {\n  _suppressWarnings: 0,\n  _loggedWarnings: 0,\n\n  // A mechanism similar to cursor.observe which receives a reactive\n  // function returning a sequence type and firing appropriate callbacks\n  // when the value changes.\n  //\n  // @param sequenceFunc {Function} a reactive function returning a\n  //     sequence type. The currently supported sequence types are:\n  //     Array, Cursor, and null.\n  //\n  // @param callbacks {Object} similar to a specific subset of\n  //     callbacks passed to `cursor.observe`\n  //     (http://docs.meteor.com/#observe), with minor variations to\n  //     support the fact that not all sequences contain objects with\n  //     _id fields.  Specifically:\n  //\n  //     * addedAt(id, item, atIndex, beforeId)\n  //     * changedAt(id, newItem, oldItem, atIndex)\n  //     * removedAt(id, oldItem, atIndex)\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)\n  //\n  // @returns {Object(stop: Function)} call 'stop' on the return value\n  //     to stop observing this sequence function.\n  //\n  // We don't make any assumptions about our ability to compare sequence\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra\n  // state/random methods on the objects) so unlike cursor.observe, we may\n  // sometimes call changedAt() when nothing actually changed.\n  // XXX consider if we *can* make the stronger assumption and avoid\n  //     no-op changedAt calls (in some cases?)\n  //\n  // XXX currently only supports the callbacks used by our\n  // implementation of {{#each}}, but this can be expanded.\n  //\n  // XXX #each doesn't use the indices (though we'll eventually need\n  // a way to get them when we support `@index`), but calling\n  // `cursor.observe` causes the index to be calculated on every\n  // callback using a linear scan (unless you turn it off by passing\n  // `_no_indices`).  Any way to avoid calculating indices on a pure\n  // cursor observe like we used to?\n  observe: function (sequenceFunc, callbacks) {\n    var lastSeq = null;\n    var activeObserveHandle = null;\n\n    // 'lastSeqArray' contains the previous value of the sequence\n    // we're observing. It is an array of objects with '_id' and\n    // 'item' fields.  'item' is the element in the array, or the\n    // document in the cursor.\n    //\n    // '_id' is whichever of the following is relevant, unless it has\n    // already appeared -- in which case it's randomly generated.\n    //\n    // * if 'item' is an object:\n    //   * an '_id' field, if present\n    //   * otherwise, the index in the array\n    //\n    // * if 'item' is a number or string, use that value\n    //\n    // XXX this can be generalized by allowing {{#each}} to accept a\n    // general 'key' argument which could be a function, a dotted\n    // field name, or the special @index value.\n    var lastSeqArray = []; // elements are objects of form {_id, item}\n    var computation = Tracker.autorun(function () {\n      var seq = sequenceFunc();\n\n      Tracker.nonreactive(function () {\n        var seqArray; // same structure as `lastSeqArray` above.\n\n        if (activeObserveHandle) {\n          // If we were previously observing a cursor, replace lastSeqArray with\n          // more up-to-date information.  Then stop the old observe.\n          lastSeqArray = _.map(lastSeq.fetch(), function (doc) {\n            return {_id: doc._id, item: doc};\n          });\n          activeObserveHandle.stop();\n          activeObserveHandle = null;\n        }\n\n        if (!seq) {\n          seqArray = seqChangedToEmpty(lastSeqArray, callbacks);\n        } else if (seq instanceof Array) {\n          seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);\n        } else if (isStoreCursor(seq)) {\n          var result /* [seqArray, activeObserveHandle] */ =\n                seqChangedToCursor(lastSeqArray, seq, callbacks);\n          seqArray = result[0];\n          activeObserveHandle = result[1];\n        } else {\n          throw badSequenceError();\n        }\n\n        diffArray(lastSeqArray, seqArray, callbacks);\n        lastSeq = seq;\n        lastSeqArray = seqArray;\n      });\n    });\n\n    return {\n      stop: function () {\n        computation.stop();\n        if (activeObserveHandle)\n          activeObserveHandle.stop();\n      }\n    };\n  },\n\n  // Fetch the items of `seq` into an array, where `seq` is of one of the\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a\n  // dependency is established.\n  fetch: function (seq) {\n    if (!seq) {\n      return [];\n    } else if (seq instanceof Array) {\n      return seq;\n    } else if (isStoreCursor(seq)) {\n      return seq.fetch();\n    } else {\n      throw badSequenceError();\n    }\n  }\n};\n\nvar badSequenceError = function () {\n  return new Error(\"{{#each}} currently only accepts \" +\n                   \"arrays, cursors or falsey values.\");\n};\n\nvar isStoreCursor = function (cursor) {\n  return cursor && _.isObject(cursor) &&\n    _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);\n};\n\n// Calculates the differences between `lastSeqArray` and\n// `seqArray` and calls appropriate functions from `callbacks`.\n// Reuses Minimongo's diff algorithm implementation.\nvar diffArray = function (lastSeqArray, seqArray, callbacks) {\n  var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n  var oldIdObjects = [];\n  var newIdObjects = [];\n  var posOld = {}; // maps from idStringify'd ids\n  var posNew = {}; // ditto\n  var posCur = {};\n  var lengthCur = lastSeqArray.length;\n\n  _.each(seqArray, function (doc, i) {\n    newIdObjects.push({_id: doc._id});\n    posNew[idStringify(doc._id)] = i;\n  });\n  _.each(lastSeqArray, function (doc, i) {\n    oldIdObjects.push({_id: doc._id});\n    posOld[idStringify(doc._id)] = i;\n    posCur[idStringify(doc._id)] = i;\n  });\n\n  // Arrays can contain arbitrary objects. We don't diff the\n  // objects. Instead we always fire 'changedAt' callback on every\n  // object. The consumer of `observe-sequence` should deal with\n  // it appropriately.\n  diffFn(oldIdObjects, newIdObjects, {\n    addedBefore: function (id, doc, before) {\n      var position = before ? posCur[idStringify(before)] : lengthCur;\n\n      if (before) {\n        // If not adding at the end, we need to update indexes.\n        // XXX this can still be improved greatly!\n        _.each(posCur, function (pos, id) {\n          if (pos >= position)\n            posCur[id]++;\n        });\n      }\n\n      lengthCur++;\n      posCur[idStringify(id)] = position;\n\n      callbacks.addedAt(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        position,\n        before);\n    },\n    movedBefore: function (id, before) {\n      if (id === before)\n        return;\n\n      var oldPosition = posCur[idStringify(id)];\n      var newPosition = before ? posCur[idStringify(before)] : lengthCur;\n\n      // Moving the item forward. The new element is losing one position as it\n      // was removed from the old position before being inserted at the new\n      // position.\n      // Ex.:   0  *1*  2   3   4\n      //        0   2   3  *1*  4\n      // The original issued callback is \"1\" before \"4\".\n      // The position of \"1\" is 1, the position of \"4\" is 4.\n      // The generated move is (1) -> (3)\n      if (newPosition > oldPosition) {\n        newPosition--;\n      }\n\n      // Fix up the positions of elements between the old and the new positions\n      // of the moved element.\n      //\n      // There are two cases:\n      //   1. The element is moved forward. Then all the positions in between\n      //   are moved back.\n      //   2. The element is moved back. Then the positions in between *and* the\n      //   element that is currently standing on the moved element's future\n      //   position are moved forward.\n      _.each(posCur, function (elCurPosition, id) {\n        if (oldPosition < elCurPosition && elCurPosition < newPosition)\n          posCur[id]--;\n        else if (newPosition <= elCurPosition && elCurPosition < oldPosition)\n          posCur[id]++;\n      });\n\n      // Finally, update the position of the moved element.\n      posCur[idStringify(id)] = newPosition;\n\n      callbacks.movedTo(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        oldPosition,\n        newPosition,\n        before);\n    },\n    removed: function (id) {\n      var prevPosition = posCur[idStringify(id)];\n\n      _.each(posCur, function (pos, id) {\n        if (pos >= prevPosition)\n          posCur[id]--;\n      });\n\n      delete posCur[idStringify(id)];\n      lengthCur--;\n\n      callbacks.removedAt(\n        id,\n        lastSeqArray[posOld[idStringify(id)]].item,\n        prevPosition);\n    }\n  });\n\n  _.each(posNew, function (pos, idString) {\n    var id = idParse(idString);\n    if (_.has(posOld, idString)) {\n      // specifically for primitive types, compare equality before\n      // firing the 'changedAt' callback. otherwise, always fire it\n      // because doing a deep EJSON comparison is not guaranteed to\n      // work (an array can contain arbitrary objects, and 'transform'\n      // can be used on cursors). also, deep diffing is not\n      // necessarily the most efficient (if only a specific subfield\n      // of the object is later accessed).\n      var newItem = seqArray[pos].item;\n      var oldItem = lastSeqArray[posOld[idString]].item;\n\n      if (typeof newItem === 'object' || newItem !== oldItem)\n          callbacks.changedAt(id, newItem, oldItem, pos);\n      }\n  });\n};\n\nseqChangedToEmpty = function (lastSeqArray, callbacks) {\n  return [];\n};\n\nseqChangedToArray = function (lastSeqArray, array, callbacks) {\n  var idsUsed = {};\n  var seqArray = _.map(array, function (item, index) {\n    var id;\n    if (typeof item === 'string') {\n      // ensure not empty, since other layers (eg DomRange) assume this as well\n      id = \"-\" + item;\n    } else if (typeof item === 'number' ||\n               typeof item === 'boolean' ||\n               item === undefined) {\n      id = item;\n    } else if (typeof item === 'object') {\n      id = (item && _.has(item, '_id')) ? item._id : index;\n    } else {\n      throw new Error(\"{{#each}} doesn't support arrays with \" +\n                      \"elements of type \" + typeof item);\n    }\n\n    var idString = idStringify(id);\n    if (idsUsed[idString]) {\n      if (typeof item === 'object' && '_id' in item)\n        warn(\"duplicate id \" + id + \" in\", array);\n      id = Random.id();\n    } else {\n      idsUsed[idString] = true;\n    }\n\n    return { _id: id, item: item };\n  });\n\n  return seqArray;\n};\n\nseqChangedToCursor = function (lastSeqArray, cursor, callbacks) {\n  var initial = true; // are we observing initial data from cursor?\n  var seqArray = [];\n\n  var observeHandle = cursor.observe({\n    addedAt: function (document, atIndex, before) {\n      if (initial) {\n        // keep track of initial data so that we can diff once\n        // we exit `observe`.\n        if (before !== null)\n          throw new Error(\"Expected initial data from observe in order\");\n        seqArray.push({ _id: document._id, item: document });\n      } else {\n        callbacks.addedAt(document._id, document, atIndex, before);\n      }\n    },\n    changedAt: function (newDocument, oldDocument, atIndex) {\n      callbacks.changedAt(newDocument._id, newDocument, oldDocument,\n                          atIndex);\n    },\n    removedAt: function (oldDocument, atIndex) {\n      callbacks.removedAt(oldDocument._id, oldDocument, atIndex);\n    },\n    movedTo: function (document, fromIndex, toIndex, before) {\n      callbacks.movedTo(\n        document._id, document, fromIndex, toIndex, before);\n    }\n  });\n  initial = false;\n\n  return [seqArray, observeHandle];\n};\n"]}}]