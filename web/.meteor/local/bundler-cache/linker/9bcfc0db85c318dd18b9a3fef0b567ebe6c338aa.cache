[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Retry = Package.retry.Retry;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DDP = Package['ddp-client'].DDP;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar Hook = Package['callback-hook'].Hook;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar babelHelpers = Package['babel-runtime'].babelHelpers;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar StreamServer, DDPServer, Server;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/stream_server.js                                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar url = Npm.require('url');                                                                                         // 1\n                                                                                                                      //\n// By default, we use the permessage-deflate extension with default                                                   //\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid                                      //\n// JSON. If it represents a falsey value, then we do not use permessage-deflate                                       //\n// at all; otherwise, the JSON value is used as an argument to deflate's                                              //\n// configure method; see                                                                                              //\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md                                              //\n//                                                                                                                    //\n// (We do this in an _.once instead of at startup, because we don't want to                                           //\n// crash the tool during isopacket load if your JSON doesn't parse. This is only                                      //\n// a problem because the tool has to load the DDP server code just in order to                                        //\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)                                               //\nvar websocketExtensions = _.once(function () {                                                                        // 14\n  var extensions = [];                                                                                                // 15\n                                                                                                                      //\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {                                                                                   // 19\n    extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig));                         // 20\n  }                                                                                                                   //\n                                                                                                                      //\n  return extensions;                                                                                                  // 25\n});                                                                                                                   //\n                                                                                                                      //\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";                                                // 28\n                                                                                                                      //\nStreamServer = function () {                                                                                          // 30\n  var self = this;                                                                                                    // 31\n  self.registration_callbacks = [];                                                                                   // 32\n  self.open_sockets = [];                                                                                             // 33\n                                                                                                                      //\n  // Because we are installing directly onto WebApp.httpServer instead of using                                       //\n  // WebApp.app, we have to process the path prefix ourselves.                                                        //\n  self.prefix = pathPrefix + '/sockjs';                                                                               // 37\n  RoutePolicy.declare(self.prefix + '/', 'network');                                                                  // 38\n                                                                                                                      //\n  // set up sockjs                                                                                                    //\n  var sockjs = Npm.require('sockjs');                                                                                 // 41\n  var serverOptions = {                                                                                               // 42\n    prefix: self.prefix,                                                                                              // 43\n    log: function () {},                                                                                              // 44\n    // this is the default, but we code it explicitly because we depend                                               //\n    // on it in stream_client:HEARTBEAT_TIMEOUT                                                                       //\n    heartbeat_delay: 45000,                                                                                           // 47\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                       //\n    // bound for that much time, SockJS might not notice that the user has                                            //\n    // reconnected because the timer (of disconnect_delay ms) can fire before                                         //\n    // SockJS processes the new connection. Eventually we'll fix this by not                                          //\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which                                       //\n    // converts to Unix sockets) but for now, raise the delay.                                                        //\n    disconnect_delay: 60 * 1000,                                                                                      // 54\n    // Set the USE_JSESSIONID environment variable to enable setting the                                              //\n    // JSESSIONID cookie. This is useful for setting up proxies with                                                  //\n    // session affinity.                                                                                              //\n    jsessionid: !!process.env.USE_JSESSIONID                                                                          // 58\n  };                                                                                                                  //\n                                                                                                                      //\n  // If you know your server environment (eg, proxies) will prevent websockets                                        //\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                               //\n  // browsers) will not waste time attempting to use them.                                                            //\n  // (Your server will still have a /websocket endpoint.)                                                             //\n  if (process.env.DISABLE_WEBSOCKETS) {                                                                               // 65\n    serverOptions.websocket = false;                                                                                  // 66\n  } else {                                                                                                            //\n    serverOptions.faye_server_options = {                                                                             // 68\n      extensions: websocketExtensions()                                                                               // 69\n    };                                                                                                                //\n  }                                                                                                                   //\n                                                                                                                      //\n  self.server = sockjs.createServer(serverOptions);                                                                   // 73\n                                                                                                                      //\n  // Install the sockjs handlers, but we want to keep around our own particular                                       //\n  // request handler that adjusts idle timeouts while we have an outstanding                                          //\n  // request.  This compensates for the fact that sockjs removes all listeners                                        //\n  // for \"request\" to add its own.                                                                                    //\n  WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback);                              // 79\n  self.server.installHandlers(WebApp.httpServer);                                                                     // 81\n  WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback);                                 // 82\n                                                                                                                      //\n  // Support the /websocket endpoint                                                                                  //\n  self._redirectWebsocketEndpoint();                                                                                  // 86\n                                                                                                                      //\n  self.server.on('connection', function (socket) {                                                                    // 88\n    socket.send = function (data) {                                                                                   // 89\n      socket.write(data);                                                                                             // 90\n    };                                                                                                                //\n    socket.on('close', function () {                                                                                  // 92\n      self.open_sockets = _.without(self.open_sockets, socket);                                                       // 93\n    });                                                                                                               //\n    self.open_sockets.push(socket);                                                                                   // 95\n                                                                                                                      //\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which                                               //\n    // will force old clients to reload. Remove this once we're not                                                   //\n    // concerned about people upgrading from a pre-0.7.0 release. Also,                                               //\n    // remove the clause in the client that ignores the welcome message                                               //\n    // (livedata_connection.js)                                                                                       //\n    socket.send(JSON.stringify({ server_id: \"0\" }));                                                                  // 102\n                                                                                                                      //\n    // call all our callbacks when we get a new socket. they will do the                                              //\n    // work of setting up handlers and such for specific messages.                                                    //\n    _.each(self.registration_callbacks, function (callback) {                                                         // 106\n      callback(socket);                                                                                               // 107\n    });                                                                                                               //\n  });                                                                                                                 //\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(StreamServer.prototype, {                                                                                    // 113\n  // call my callback when a new socket connects.                                                                     //\n  // also call it for all current connections.                                                                        //\n  register: function (callback) {                                                                                     // 116\n    var self = this;                                                                                                  // 117\n    self.registration_callbacks.push(callback);                                                                       // 118\n    _.each(self.all_sockets(), function (socket) {                                                                    // 119\n      callback(socket);                                                                                               // 120\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // get a list of all sockets                                                                                        //\n  all_sockets: function () {                                                                                          // 125\n    var self = this;                                                                                                  // 126\n    return _.values(self.open_sockets);                                                                               // 127\n  },                                                                                                                  //\n                                                                                                                      //\n  // Redirect /websocket to /sockjs/websocket in order to not expose                                                  //\n  // sockjs to clients that want to use raw websockets                                                                //\n  _redirectWebsocketEndpoint: function () {                                                                           // 132\n    var self = this;                                                                                                  // 133\n    // Unfortunately we can't use a connect middleware here since                                                     //\n    // sockjs installs itself prior to all existing listeners                                                         //\n    // (meaning prior to any connect middlewares) so we need to take                                                  //\n    // an approach similar to overshadowListeners in                                                                  //\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee           //\n    _.each(['request', 'upgrade'], function (event) {                                                                 // 139\n      var httpServer = WebApp.httpServer;                                                                             // 140\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);                                              // 141\n      httpServer.removeAllListeners(event);                                                                           // 142\n                                                                                                                      //\n      // request and upgrade have different arguments passed but                                                      //\n      // we only care about the first one which is always request                                                     //\n      var newListener = function (request /*, moreArguments */) {                                                     // 146\n        // Store arguments for use within the closure below                                                           //\n        var args = arguments;                                                                                         // 148\n                                                                                                                      //\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                         //\n        // preserving query string.                                                                                   //\n        var parsedUrl = url.parse(request.url);                                                                       // 152\n        if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {  // 153\n          parsedUrl.pathname = self.prefix + '/websocket';                                                            // 155\n          request.url = url.format(parsedUrl);                                                                        // 156\n        }                                                                                                             //\n        _.each(oldHttpServerListeners, function (oldListener) {                                                       // 158\n          oldListener.apply(httpServer, args);                                                                        // 159\n        });                                                                                                           //\n      };                                                                                                              //\n      httpServer.addListener(event, newListener);                                                                     // 162\n    });                                                                                                               //\n  }                                                                                                                   //\n});                                                                                                                   //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/livedata_server.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nDDPServer = {};                                                                                                       // 1\n                                                                                                                      //\nvar Fiber = Npm.require('fibers');                                                                                    // 3\n                                                                                                                      //\n// This file contains classes:                                                                                        //\n// * Session - The server's connection to a single DDP client                                                         //\n// * Subscription - A single subscription for a single client                                                         //\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.                                           //\n//                                                                                                                    //\n// Session and Subscription are file scope. For now, until we freeze                                                  //\n// the interface, Server is package scope (in the future it should be                                                 //\n// exported.)                                                                                                         //\n                                                                                                                      //\n// Represents a single document in a SessionCollectionView                                                            //\nvar SessionDocumentView = function () {                                                                               // 15\n  var self = this;                                                                                                    // 16\n  self.existsIn = {}; // set of subscriptionHandle                                                                    // 17\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]                                          // 18\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(SessionDocumentView.prototype, {                                                                             // 21\n                                                                                                                      //\n  getFields: function () {                                                                                            // 23\n    var self = this;                                                                                                  // 24\n    var ret = {};                                                                                                     // 25\n    _.each(self.dataByKey, function (precedenceList, key) {                                                           // 26\n      ret[key] = precedenceList[0].value;                                                                             // 27\n    });                                                                                                               //\n    return ret;                                                                                                       // 29\n  },                                                                                                                  //\n                                                                                                                      //\n  clearField: function (subscriptionHandle, key, changeCollector) {                                                   // 32\n    var self = this;                                                                                                  // 33\n    // Publish API ignores _id if present in fields                                                                   //\n    if (key === \"_id\") return;                                                                                        // 35\n    var precedenceList = self.dataByKey[key];                                                                         // 37\n                                                                                                                      //\n    // It's okay to clear fields that didn't exist. No need to throw                                                  //\n    // an error.                                                                                                      //\n    if (!precedenceList) return;                                                                                      // 41\n                                                                                                                      //\n    var removedValue = undefined;                                                                                     // 44\n    for (var i = 0; i < precedenceList.length; i++) {                                                                 // 45\n      var precedence = precedenceList[i];                                                                             // 46\n      if (precedence.subscriptionHandle === subscriptionHandle) {                                                     // 47\n        // The view's value can only change if this subscription is the one that                                      //\n        // used to have precedence.                                                                                   //\n        if (i === 0) removedValue = precedence.value;                                                                 // 50\n        precedenceList.splice(i, 1);                                                                                  // 52\n        break;                                                                                                        // 53\n      }                                                                                                               //\n    }                                                                                                                 //\n    if (_.isEmpty(precedenceList)) {                                                                                  // 56\n      delete self.dataByKey[key];                                                                                     // 57\n      changeCollector[key] = undefined;                                                                               // 58\n    } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {                  //\n      changeCollector[key] = precedenceList[0].value;                                                                 // 61\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  changeField: function (subscriptionHandle, key, value, changeCollector, isAdd) {                                    // 65\n    var self = this;                                                                                                  // 67\n    // Publish API ignores _id if present in fields                                                                   //\n    if (key === \"_id\") return;                                                                                        // 69\n                                                                                                                      //\n    // Don't share state with the data passed in by the user.                                                         //\n    value = EJSON.clone(value);                                                                                       // 73\n                                                                                                                      //\n    if (!_.has(self.dataByKey, key)) {                                                                                // 75\n      self.dataByKey[key] = [{ subscriptionHandle: subscriptionHandle,                                                // 76\n        value: value }];                                                                                              // 77\n      changeCollector[key] = value;                                                                                   // 78\n      return;                                                                                                         // 79\n    }                                                                                                                 //\n    var precedenceList = self.dataByKey[key];                                                                         // 81\n    var elt;                                                                                                          // 82\n    if (!isAdd) {                                                                                                     // 83\n      elt = _.find(precedenceList, function (precedence) {                                                            // 84\n        return precedence.subscriptionHandle === subscriptionHandle;                                                  // 85\n      });                                                                                                             //\n    }                                                                                                                 //\n                                                                                                                      //\n    if (elt) {                                                                                                        // 89\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {                                             // 90\n        // this subscription is changing the value of this field.                                                     //\n        changeCollector[key] = value;                                                                                 // 92\n      }                                                                                                               //\n      elt.value = value;                                                                                              // 94\n    } else {                                                                                                          //\n      // this subscription is newly caring about this field                                                           //\n      precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value });                                  // 97\n    }                                                                                                                 //\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\n/**                                                                                                                   //\n * Represents a client's view of a single collection                                                                  //\n * @param {String} collectionName Name of the collection it represents                                                //\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed                      //\n * @class SessionCollectionView                                                                                       //\n */                                                                                                                   //\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {                                             // 109\n  var self = this;                                                                                                    // 110\n  self.collectionName = collectionName;                                                                               // 111\n  self.documents = {};                                                                                                // 112\n  self.callbacks = sessionCallbacks;                                                                                  // 113\n};                                                                                                                    //\n                                                                                                                      //\nDDPServer._SessionCollectionView = SessionCollectionView;                                                             // 116\n                                                                                                                      //\n_.extend(SessionCollectionView.prototype, {                                                                           // 119\n                                                                                                                      //\n  isEmpty: function () {                                                                                              // 121\n    var self = this;                                                                                                  // 122\n    return _.isEmpty(self.documents);                                                                                 // 123\n  },                                                                                                                  //\n                                                                                                                      //\n  diff: function (previous) {                                                                                         // 126\n    var self = this;                                                                                                  // 127\n    DiffSequence.diffObjects(previous.documents, self.documents, {                                                    // 128\n      both: _.bind(self.diffDocument, self),                                                                          // 129\n                                                                                                                      //\n      rightOnly: function (id, nowDV) {                                                                               // 131\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());                                             // 132\n      },                                                                                                              //\n                                                                                                                      //\n      leftOnly: function (id, prevDV) {                                                                               // 135\n        self.callbacks.removed(self.collectionName, id);                                                              // 136\n      }                                                                                                               //\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  diffDocument: function (id, prevDV, nowDV) {                                                                        // 141\n    var self = this;                                                                                                  // 142\n    var fields = {};                                                                                                  // 143\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {                                                 // 144\n      both: function (key, prev, now) {                                                                               // 145\n        if (!EJSON.equals(prev, now)) fields[key] = now;                                                              // 146\n      },                                                                                                              //\n      rightOnly: function (key, now) {                                                                                // 149\n        fields[key] = now;                                                                                            // 150\n      },                                                                                                              //\n      leftOnly: function (key, prev) {                                                                                // 152\n        fields[key] = undefined;                                                                                      // 153\n      }                                                                                                               //\n    });                                                                                                               //\n    self.callbacks.changed(self.collectionName, id, fields);                                                          // 156\n  },                                                                                                                  //\n                                                                                                                      //\n  added: function (subscriptionHandle, id, fields) {                                                                  // 159\n    var self = this;                                                                                                  // 160\n    var docView = self.documents[id];                                                                                 // 161\n    var added = false;                                                                                                // 162\n    if (!docView) {                                                                                                   // 163\n      added = true;                                                                                                   // 164\n      docView = new SessionDocumentView();                                                                            // 165\n      self.documents[id] = docView;                                                                                   // 166\n    }                                                                                                                 //\n    docView.existsIn[subscriptionHandle] = true;                                                                      // 168\n    var changeCollector = {};                                                                                         // 169\n    _.each(fields, function (value, key) {                                                                            // 170\n      docView.changeField(subscriptionHandle, key, value, changeCollector, true);                                     // 171\n    });                                                                                                               //\n    if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n  },                                                                                                                  //\n                                                                                                                      //\n  changed: function (subscriptionHandle, id, changed) {                                                               // 180\n    var self = this;                                                                                                  // 181\n    var changedResult = {};                                                                                           // 182\n    var docView = self.documents[id];                                                                                 // 183\n    if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");                             // 184\n    _.each(changed, function (value, key) {                                                                           // 186\n      if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n    });                                                                                                               //\n    self.callbacks.changed(self.collectionName, id, changedResult);                                                   // 192\n  },                                                                                                                  //\n                                                                                                                      //\n  removed: function (subscriptionHandle, id) {                                                                        // 195\n    var self = this;                                                                                                  // 196\n    var docView = self.documents[id];                                                                                 // 197\n    if (!docView) {                                                                                                   // 198\n      var err = new Error(\"Removed nonexistent document \" + id);                                                      // 199\n      throw err;                                                                                                      // 200\n    }                                                                                                                 //\n    delete docView.existsIn[subscriptionHandle];                                                                      // 202\n    if (_.isEmpty(docView.existsIn)) {                                                                                // 203\n      // it is gone from everyone                                                                                     //\n      self.callbacks.removed(self.collectionName, id);                                                                // 205\n      delete self.documents[id];                                                                                      // 206\n    } else {                                                                                                          //\n      var changed = {};                                                                                               // 208\n      // remove this subscription from every precedence list                                                          //\n      // and record the changes                                                                                       //\n      _.each(docView.dataByKey, function (precedenceList, key) {                                                      // 211\n        docView.clearField(subscriptionHandle, key, changed);                                                         // 212\n      });                                                                                                             //\n                                                                                                                      //\n      self.callbacks.changed(self.collectionName, id, changed);                                                       // 215\n    }                                                                                                                 //\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Session                                                                    */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\nvar Session = function (server, version, socket, options) {                                                           // 224\n  var self = this;                                                                                                    // 225\n  self.id = Random.id();                                                                                              // 226\n                                                                                                                      //\n  self.server = server;                                                                                               // 228\n  self.version = version;                                                                                             // 229\n                                                                                                                      //\n  self.initialized = false;                                                                                           // 231\n  self.socket = socket;                                                                                               // 232\n                                                                                                                      //\n  // set to null when the session is destroyed. multiple places below                                                 //\n  // use this to determine if the session is alive or not.                                                            //\n  self.inQueue = new Meteor._DoubleEndedQueue();                                                                      // 236\n                                                                                                                      //\n  self.blocked = false;                                                                                               // 238\n  self.workerRunning = false;                                                                                         // 239\n                                                                                                                      //\n  // Sub objects for active subscriptions                                                                             //\n  self._namedSubs = {};                                                                                               // 242\n  self._universalSubs = [];                                                                                           // 243\n                                                                                                                      //\n  self.userId = null;                                                                                                 // 245\n                                                                                                                      //\n  self.collectionViews = {};                                                                                          // 247\n                                                                                                                      //\n  // Set this to false to not send messages when collectionViews are                                                  //\n  // modified. This is done when rerunning subs in _setUserId and those messages                                      //\n  // are calculated via a diff instead.                                                                               //\n  self._isSending = true;                                                                                             // 252\n                                                                                                                      //\n  // If this is true, don't start a newly-created universal publisher on this                                         //\n  // session. The session will take care of starting it when appropriate.                                             //\n  self._dontStartNewUniversalSubs = false;                                                                            // 256\n                                                                                                                      //\n  // when we are rerunning subscriptions, any ready messages                                                          //\n  // we want to buffer up for when we are done rerunning subscriptions                                                //\n  self._pendingReady = [];                                                                                            // 260\n                                                                                                                      //\n  // List of callbacks to call when this connection is closed.                                                        //\n  self._closeCallbacks = [];                                                                                          // 263\n                                                                                                                      //\n  // XXX HACK: If a sockjs connection, save off the URL. This is                                                      //\n  // temporary and will go away in the near future.                                                                   //\n  self._socketUrl = socket.url;                                                                                       // 268\n                                                                                                                      //\n  // Allow tests to disable responding to pings.                                                                      //\n  self._respondToPings = options.respondToPings;                                                                      // 271\n                                                                                                                      //\n  // This object is the public interface to the session. In the public                                                //\n  // API, it is called the `connection` object.  Internally we call it                                                //\n  // a `connectionHandle` to avoid ambiguity.                                                                         //\n  self.connectionHandle = {                                                                                           // 276\n    id: self.id,                                                                                                      // 277\n    close: function () {                                                                                              // 278\n      self.close();                                                                                                   // 279\n    },                                                                                                                //\n    onClose: function (fn) {                                                                                          // 281\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");                                             // 282\n      if (self.inQueue) {                                                                                             // 283\n        self._closeCallbacks.push(cb);                                                                                // 284\n      } else {                                                                                                        //\n        // if we're already closed, call the callback.                                                                //\n        Meteor.defer(cb);                                                                                             // 287\n      }                                                                                                               //\n    },                                                                                                                //\n    clientAddress: self._clientAddress(),                                                                             // 290\n    httpHeaders: self.socket.headers                                                                                  // 291\n  };                                                                                                                  //\n                                                                                                                      //\n  socket.send(DDPCommon.stringifyDDP({ msg: 'connected',                                                              // 294\n    session: self.id }));                                                                                             // 295\n  // On initial connect, spin up all the universal publishers.                                                        //\n  Fiber(function () {                                                                                                 // 297\n    self.startUniversalSubs();                                                                                        // 298\n  }).run();                                                                                                           //\n                                                                                                                      //\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {                                                        // 301\n    self.heartbeat = new DDPCommon.Heartbeat({                                                                        // 302\n      heartbeatInterval: options.heartbeatInterval,                                                                   // 303\n      heartbeatTimeout: options.heartbeatTimeout,                                                                     // 304\n      onTimeout: function () {                                                                                        // 305\n        self.close();                                                                                                 // 306\n      },                                                                                                              //\n      sendPing: function () {                                                                                         // 308\n        self.send({ msg: 'ping' });                                                                                   // 309\n      }                                                                                                               //\n    });                                                                                                               //\n    self.heartbeat.start();                                                                                           // 312\n  }                                                                                                                   //\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", 1);                                // 315\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(Session.prototype, {                                                                                         // 319\n                                                                                                                      //\n  sendReady: function (subscriptionIds) {                                                                             // 321\n    var self = this;                                                                                                  // 322\n    if (self._isSending) self.send({ msg: \"ready\", subs: subscriptionIds });else {                                    // 323\n      _.each(subscriptionIds, function (subscriptionId) {                                                             // 326\n        self._pendingReady.push(subscriptionId);                                                                      // 327\n      });                                                                                                             //\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  sendAdded: function (collectionName, id, fields) {                                                                  // 332\n    var self = this;                                                                                                  // 333\n    if (self._isSending) self.send({ msg: \"added\", collection: collectionName, id: id, fields: fields });             // 334\n  },                                                                                                                  //\n                                                                                                                      //\n  sendChanged: function (collectionName, id, fields) {                                                                // 338\n    var self = this;                                                                                                  // 339\n    if (_.isEmpty(fields)) return;                                                                                    // 340\n                                                                                                                      //\n    if (self._isSending) {                                                                                            // 343\n      self.send({                                                                                                     // 344\n        msg: \"changed\",                                                                                               // 345\n        collection: collectionName,                                                                                   // 346\n        id: id,                                                                                                       // 347\n        fields: fields                                                                                                // 348\n      });                                                                                                             //\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  sendRemoved: function (collectionName, id) {                                                                        // 353\n    var self = this;                                                                                                  // 354\n    if (self._isSending) self.send({ msg: \"removed\", collection: collectionName, id: id });                           // 355\n  },                                                                                                                  //\n                                                                                                                      //\n  getSendCallbacks: function () {                                                                                     // 359\n    var self = this;                                                                                                  // 360\n    return {                                                                                                          // 361\n      added: _.bind(self.sendAdded, self),                                                                            // 362\n      changed: _.bind(self.sendChanged, self),                                                                        // 363\n      removed: _.bind(self.sendRemoved, self)                                                                         // 364\n    };                                                                                                                //\n  },                                                                                                                  //\n                                                                                                                      //\n  getCollectionView: function (collectionName) {                                                                      // 368\n    var self = this;                                                                                                  // 369\n    if (_.has(self.collectionViews, collectionName)) {                                                                // 370\n      return self.collectionViews[collectionName];                                                                    // 371\n    }                                                                                                                 //\n    var ret = new SessionCollectionView(collectionName, self.getSendCallbacks());                                     // 373\n    self.collectionViews[collectionName] = ret;                                                                       // 375\n    return ret;                                                                                                       // 376\n  },                                                                                                                  //\n                                                                                                                      //\n  added: function (subscriptionHandle, collectionName, id, fields) {                                                  // 379\n    var self = this;                                                                                                  // 380\n    var view = self.getCollectionView(collectionName);                                                                // 381\n    view.added(subscriptionHandle, id, fields);                                                                       // 382\n  },                                                                                                                  //\n                                                                                                                      //\n  removed: function (subscriptionHandle, collectionName, id) {                                                        // 385\n    var self = this;                                                                                                  // 386\n    var view = self.getCollectionView(collectionName);                                                                // 387\n    view.removed(subscriptionHandle, id);                                                                             // 388\n    if (view.isEmpty()) {                                                                                             // 389\n      delete self.collectionViews[collectionName];                                                                    // 390\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  changed: function (subscriptionHandle, collectionName, id, fields) {                                                // 394\n    var self = this;                                                                                                  // 395\n    var view = self.getCollectionView(collectionName);                                                                // 396\n    view.changed(subscriptionHandle, id, fields);                                                                     // 397\n  },                                                                                                                  //\n                                                                                                                      //\n  startUniversalSubs: function () {                                                                                   // 400\n    var self = this;                                                                                                  // 401\n    // Make a shallow copy of the set of universal handlers and start them. If                                        //\n    // additional universal publishers start while we're running them (due to                                         //\n    // yielding), they will run separately as part of Server.publish.                                                 //\n    var handlers = _.clone(self.server.universal_publish_handlers);                                                   // 405\n    _.each(handlers, function (handler) {                                                                             // 406\n      self._startSubscription(handler);                                                                               // 407\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Destroy this session and unregister it at the server.                                                            //\n  close: function () {                                                                                                // 412\n    var self = this;                                                                                                  // 413\n                                                                                                                      //\n    // Destroy this session, even if it's not registered at the                                                       //\n    // server. Stop all processing and tear everything down. If a socket                                              //\n    // was attached, close it.                                                                                        //\n                                                                                                                      //\n    // Already destroyed.                                                                                             //\n    if (!self.inQueue) return;                                                                                        // 420\n                                                                                                                      //\n    // Drop the merge box data immediately.                                                                           //\n    self.inQueue = null;                                                                                              // 424\n    self.collectionViews = {};                                                                                        // 425\n                                                                                                                      //\n    if (self.heartbeat) {                                                                                             // 427\n      self.heartbeat.stop();                                                                                          // 428\n      self.heartbeat = null;                                                                                          // 429\n    }                                                                                                                 //\n                                                                                                                      //\n    if (self.socket) {                                                                                                // 432\n      self.socket.close();                                                                                            // 433\n      self.socket._meteorSession = null;                                                                              // 434\n    }                                                                                                                 //\n                                                                                                                      //\n    Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", -1);                             // 437\n                                                                                                                      //\n    Meteor.defer(function () {                                                                                        // 440\n      // stop callbacks can yield, so we defer this on close.                                                         //\n      // sub._isDeactivated() detects that we set inQueue to null and                                                 //\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).                                      //\n      self._deactivateAllSubscriptions();                                                                             // 444\n                                                                                                                      //\n      // Defer calling the close callbacks, so that the caller closing                                                //\n      // the session isn't waiting for all the callbacks to complete.                                                 //\n      _.each(self._closeCallbacks, function (callback) {                                                              // 448\n        callback();                                                                                                   // 449\n      });                                                                                                             //\n    });                                                                                                               //\n                                                                                                                      //\n    // Unregister the session.                                                                                        //\n    self.server._removeSession(self);                                                                                 // 454\n  },                                                                                                                  //\n                                                                                                                      //\n  // Send a message (doing nothing if no socket is connected right now.)                                              //\n  // It should be a JSON object (it will be stringified.)                                                             //\n  send: function (msg) {                                                                                              // 459\n    var self = this;                                                                                                  // 460\n    if (self.socket) {                                                                                                // 461\n      if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));                               // 462\n      self.socket.send(DDPCommon.stringifyDDP(msg));                                                                  // 464\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Send a connection error.                                                                                         //\n  sendError: function (reason, offendingMessage) {                                                                    // 469\n    var self = this;                                                                                                  // 470\n    var msg = { msg: 'error', reason: reason };                                                                       // 471\n    if (offendingMessage) msg.offendingMessage = offendingMessage;                                                    // 472\n    self.send(msg);                                                                                                   // 474\n  },                                                                                                                  //\n                                                                                                                      //\n  // Process 'msg' as an incoming message. (But as a guard against                                                    //\n  // race conditions during reconnection, ignore the message if                                                       //\n  // 'socket' is not the currently connected socket.)                                                                 //\n  //                                                                                                                  //\n  // We run the messages from the client one at a time, in the order                                                  //\n  // given by the client. The message handler is passed an idempotent                                                 //\n  // function 'unblock' which it may call to allow other messages to                                                  //\n  // begin running in parallel in another fiber (for example, a method                                                //\n  // that wants to yield.) Otherwise, it is automatically unblocked                                                   //\n  // when it returns.                                                                                                 //\n  //                                                                                                                  //\n  // Actually, we don't have to 'totally order' the messages in this                                                  //\n  // way, but it's the easiest thing that's correct. (unsub needs to                                                  //\n  // be ordered against sub, methods need to be ordered against each                                                  //\n  // other.)                                                                                                          //\n  processMessage: function (msg_in) {                                                                                 // 492\n    var self = this;                                                                                                  // 493\n    if (!self.inQueue) // we have been destroyed.                                                                     // 494\n      return;                                                                                                         // 495\n                                                                                                                      //\n    // Respond to ping and pong messages immediately without queuing.                                                 //\n    // If the negotiated DDP version is \"pre1\" which didn't support                                                   //\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad                                                  //\n    // request\" for the unknown messages.                                                                             //\n    //                                                                                                                //\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which                                              //\n    // needs a Fiber. We could actually use regular setTimeout and avoid                                              //\n    // these new fibers, but it is easier to just make everything use                                                 //\n    // Meteor.setTimeout and not think too hard.                                                                      //\n    //                                                                                                                //\n    // Any message counts as receiving a pong, as it demonstrates that                                                //\n    // the client is still alive.                                                                                     //\n    if (self.heartbeat) {                                                                                             // 509\n      Fiber(function () {                                                                                             // 510\n        self.heartbeat.messageReceived();                                                                             // 511\n      }).run();                                                                                                       //\n    }                                                                                                                 //\n                                                                                                                      //\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {                                                           // 515\n      if (self._respondToPings) self.send({ msg: \"pong\", id: msg_in.id });                                            // 516\n      return;                                                                                                         // 518\n    }                                                                                                                 //\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {                                                           // 520\n      // Since everything is a pong, nothing to do                                                                    //\n      return;                                                                                                         // 522\n    }                                                                                                                 //\n                                                                                                                      //\n    self.inQueue.push(msg_in);                                                                                        // 525\n    if (self.workerRunning) return;                                                                                   // 526\n    self.workerRunning = true;                                                                                        // 528\n                                                                                                                      //\n    var processNext = function () {                                                                                   // 530\n      var msg = self.inQueue && self.inQueue.shift();                                                                 // 531\n      if (!msg) {                                                                                                     // 532\n        self.workerRunning = false;                                                                                   // 533\n        return;                                                                                                       // 534\n      }                                                                                                               //\n                                                                                                                      //\n      Fiber(function () {                                                                                             // 537\n        var blocked = true;                                                                                           // 538\n                                                                                                                      //\n        var unblock = function () {                                                                                   // 540\n          if (!blocked) return; // idempotent                                                                         // 541\n          blocked = false;                                                                                            // 543\n          processNext();                                                                                              // 544\n        };                                                                                                            //\n                                                                                                                      //\n        if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it                                                        // 551\n      }).run();                                                                                                       //\n    };                                                                                                                //\n                                                                                                                      //\n    processNext();                                                                                                    // 555\n  },                                                                                                                  //\n                                                                                                                      //\n  protocol_handlers: {                                                                                                // 558\n    sub: function (msg) {                                                                                             // 559\n      var self = this;                                                                                                // 560\n                                                                                                                      //\n      // reject malformed messages                                                                                    //\n      if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n        self.sendError(\"Malformed subscription\", msg);                                                                // 566\n        return;                                                                                                       // 567\n      }                                                                                                               //\n                                                                                                                      //\n      if (!self.server.publish_handlers[msg.name]) {                                                                  // 570\n        self.send({                                                                                                   // 571\n          msg: 'nosub', id: msg.id,                                                                                   // 572\n          error: new Meteor.Error(404, \"Subscription not found\") });                                                  // 573\n        return;                                                                                                       // 574\n      }                                                                                                               //\n                                                                                                                      //\n      if (_.has(self._namedSubs, msg.id))                                                                             // 577\n        // subs are idempotent, or rather, they are ignored if a sub                                                  //\n        // with that id already exists. this is important during                                                      //\n        // reconnect.                                                                                                 //\n        return;                                                                                                       // 581\n                                                                                                                      //\n      // XXX It'd be much better if we had generic hooks where any package can                                        //\n      // hook into subscription handling, but in the mean while we special case                                       //\n      // ddp-rate-limiter package. This is also done for weak requirements to                                         //\n      // add the ddp-rate-limiter package in case we don't have Accounts. A                                           //\n      // user trying to use the ddp-rate-limiter must explicitly require it.                                          //\n      if (Package['ddp-rate-limiter']) {                                                                              // 588\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                              // 589\n        var rateLimiterInput = {                                                                                      // 590\n          userId: self.userId,                                                                                        // 591\n          clientAddress: self.connectionHandle.clientAddress,                                                         // 592\n          type: \"subscription\",                                                                                       // 593\n          name: msg.name,                                                                                             // 594\n          connectionId: self.id                                                                                       // 595\n        };                                                                                                            //\n                                                                                                                      //\n        DDPRateLimiter._increment(rateLimiterInput);                                                                  // 598\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                                // 599\n        if (!rateLimitResult.allowed) {                                                                               // 600\n          self.send({                                                                                                 // 601\n            msg: 'nosub', id: msg.id,                                                                                 // 602\n            error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset })\n          });                                                                                                         //\n          return;                                                                                                     // 608\n        }                                                                                                             //\n      }                                                                                                               //\n                                                                                                                      //\n      var handler = self.server.publish_handlers[msg.name];                                                           // 612\n                                                                                                                      //\n      self._startSubscription(handler, msg.id, msg.params, msg.name);                                                 // 614\n    },                                                                                                                //\n                                                                                                                      //\n    unsub: function (msg) {                                                                                           // 618\n      var self = this;                                                                                                // 619\n                                                                                                                      //\n      self._stopSubscription(msg.id);                                                                                 // 621\n    },                                                                                                                //\n                                                                                                                      //\n    method: function (msg, unblock) {                                                                                 // 624\n      var self = this;                                                                                                // 625\n                                                                                                                      //\n      // reject malformed messages                                                                                    //\n      // For now, we silently ignore unknown attributes,                                                              //\n      // for forwards compatibility.                                                                                  //\n      if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n        self.sendError(\"Malformed method invocation\", msg);                                                           // 634\n        return;                                                                                                       // 635\n      }                                                                                                               //\n                                                                                                                      //\n      var randomSeed = msg.randomSeed || null;                                                                        // 638\n                                                                                                                      //\n      // set up to mark the method as satisfied once all observers                                                    //\n      // (and subscriptions) have reacted to any writes that were                                                     //\n      // done.                                                                                                        //\n      var fence = new DDPServer._WriteFence();                                                                        // 643\n      fence.onAllCommitted(function () {                                                                              // 644\n        // Retire the fence so that future writes are allowed.                                                        //\n        // This means that callbacks like timers are free to use                                                      //\n        // the fence, and if they fire before it's armed (for                                                         //\n        // example, because the method waits for them) their                                                          //\n        // writes will be included in the fence.                                                                      //\n        fence.retire();                                                                                               // 650\n        self.send({                                                                                                   // 651\n          msg: 'updated', methods: [msg.id] });                                                                       // 652\n      });                                                                                                             //\n                                                                                                                      //\n      // find the handler                                                                                             //\n      var handler = self.server.method_handlers[msg.method];                                                          // 656\n      if (!handler) {                                                                                                 // 657\n        self.send({                                                                                                   // 658\n          msg: 'result', id: msg.id,                                                                                  // 659\n          error: new Meteor.Error(404, \"Method not found\") });                                                        // 660\n        fence.arm();                                                                                                  // 661\n        return;                                                                                                       // 662\n      }                                                                                                               //\n                                                                                                                      //\n      var setUserId = function (userId) {                                                                             // 665\n        self._setUserId(userId);                                                                                      // 666\n      };                                                                                                              //\n                                                                                                                      //\n      var invocation = new DDPCommon.MethodInvocation({                                                               // 669\n        isSimulation: false,                                                                                          // 670\n        userId: self.userId,                                                                                          // 671\n        setUserId: setUserId,                                                                                         // 672\n        unblock: unblock,                                                                                             // 673\n        connection: self.connectionHandle,                                                                            // 674\n        randomSeed: randomSeed                                                                                        // 675\n      });                                                                                                             //\n                                                                                                                      //\n      var promise = new Promise(function (resolve, reject) {                                                          // 678\n        // XXX It'd be better if we could hook into method handlers better but                                        //\n        // for now, we need to check if the ddp-rate-limiter exists since we                                          //\n        // have a weak requirement for the ddp-rate-limiter package to be added                                       //\n        // to our application.                                                                                        //\n        if (Package['ddp-rate-limiter']) {                                                                            // 683\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                            // 684\n          var rateLimiterInput = {                                                                                    // 685\n            userId: self.userId,                                                                                      // 686\n            clientAddress: self.connectionHandle.clientAddress,                                                       // 687\n            type: \"method\",                                                                                           // 688\n            name: msg.method,                                                                                         // 689\n            connectionId: self.id                                                                                     // 690\n          };                                                                                                          //\n          DDPRateLimiter._increment(rateLimiterInput);                                                                // 692\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                              // 693\n          if (!rateLimitResult.allowed) {                                                                             // 694\n            reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset }));\n            return;                                                                                                   // 700\n          }                                                                                                           //\n        }                                                                                                             //\n                                                                                                                      //\n        resolve(DDPServer._CurrentWriteFence.withValue(fence, function () {                                           // 704\n          return DDP._CurrentInvocation.withValue(invocation, function () {                                           //\n            return maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");         //\n          });                                                                                                         //\n        }));                                                                                                          //\n      });                                                                                                             //\n                                                                                                                      //\n      function finish() {                                                                                             // 716\n        fence.arm();                                                                                                  // 717\n        unblock();                                                                                                    // 718\n      }                                                                                                               //\n                                                                                                                      //\n      var payload = {                                                                                                 // 721\n        msg: \"result\",                                                                                                // 722\n        id: msg.id                                                                                                    // 723\n      };                                                                                                              //\n                                                                                                                      //\n      promise.then(function (result) {                                                                                // 726\n        finish();                                                                                                     // 727\n        if (result !== undefined) {                                                                                   // 728\n          payload.result = result;                                                                                    // 729\n        }                                                                                                             //\n        self.send(payload);                                                                                           // 731\n      }, function (exception) {                                                                                       //\n        finish();                                                                                                     // 733\n        payload.error = wrapInternalException(exception, \"while invoking method '\" + msg.method + \"'\");               // 734\n        self.send(payload);                                                                                           // 738\n      });                                                                                                             //\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  _eachSub: function (f) {                                                                                            // 743\n    var self = this;                                                                                                  // 744\n    _.each(self._namedSubs, f);                                                                                       // 745\n    _.each(self._universalSubs, f);                                                                                   // 746\n  },                                                                                                                  //\n                                                                                                                      //\n  _diffCollectionViews: function (beforeCVs) {                                                                        // 749\n    var self = this;                                                                                                  // 750\n    DiffSequence.diffObjects(beforeCVs, self.collectionViews, {                                                       // 751\n      both: function (collectionName, leftValue, rightValue) {                                                        // 752\n        rightValue.diff(leftValue);                                                                                   // 753\n      },                                                                                                              //\n      rightOnly: function (collectionName, rightValue) {                                                              // 755\n        _.each(rightValue.documents, function (docView, id) {                                                         // 756\n          self.sendAdded(collectionName, id, docView.getFields());                                                    // 757\n        });                                                                                                           //\n      },                                                                                                              //\n      leftOnly: function (collectionName, leftValue) {                                                                // 760\n        _.each(leftValue.documents, function (doc, id) {                                                              // 761\n          self.sendRemoved(collectionName, id);                                                                       // 762\n        });                                                                                                           //\n      }                                                                                                               //\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Sets the current user id in all appropriate contexts and reruns                                                  //\n  // all subscriptions                                                                                                //\n  _setUserId: function (userId) {                                                                                     // 770\n    var self = this;                                                                                                  // 771\n                                                                                                                      //\n    if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + typeof userId);\n                                                                                                                      //\n    // Prevent newly-created universal subscriptions from being added to our                                          //\n    // session; they will be found below when we call startUniversalSubs.                                             //\n    //                                                                                                                //\n    // (We don't have to worry about named subscriptions, because we only add                                         //\n    // them when we process a 'sub' message. We are currently processing a                                            //\n    // 'method' message, and the method did not unblock, because it is illegal                                        //\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a                                       //\n    // new named subscription.)                                                                                       //\n    self._dontStartNewUniversalSubs = true;                                                                           // 785\n                                                                                                                      //\n    // Prevent current subs from updating our collectionViews and call their                                          //\n    // stop callbacks. This may yield.                                                                                //\n    self._eachSub(function (sub) {                                                                                    // 789\n      sub._deactivate();                                                                                              // 790\n    });                                                                                                               //\n                                                                                                                      //\n    // All subs should now be deactivated. Stop sending messages to the client,                                       //\n    // save the state of the published collections, reset to an empty view, and                                       //\n    // update the userId.                                                                                             //\n    self._isSending = false;                                                                                          // 796\n    var beforeCVs = self.collectionViews;                                                                             // 797\n    self.collectionViews = {};                                                                                        // 798\n    self.userId = userId;                                                                                             // 799\n                                                                                                                      //\n    // Save the old named subs, and reset to having no subscriptions.                                                 //\n    var oldNamedSubs = self._namedSubs;                                                                               // 802\n    self._namedSubs = {};                                                                                             // 803\n    self._universalSubs = [];                                                                                         // 804\n                                                                                                                      //\n    _.each(oldNamedSubs, function (sub, subscriptionId) {                                                             // 806\n      self._namedSubs[subscriptionId] = sub._recreate();                                                              // 807\n      // nb: if the handler throws or calls this.error(), it will in fact                                             //\n      // immediately send its 'nosub'. This is OK, though.                                                            //\n      self._namedSubs[subscriptionId]._runHandler();                                                                  // 810\n    });                                                                                                               //\n                                                                                                                      //\n    // Allow newly-created universal subs to be started on our connection in                                          //\n    // parallel with the ones we're spinning up here, and spin up universal                                           //\n    // subs.                                                                                                          //\n    self._dontStartNewUniversalSubs = false;                                                                          // 816\n    self.startUniversalSubs();                                                                                        // 817\n                                                                                                                      //\n    // Start sending messages again, beginning with the diff from the previous                                        //\n    // state of the world to the current state. No yields are allowed during                                          //\n    // this diff, so that other changes cannot interleave.                                                            //\n    Meteor._noYieldsAllowed(function () {                                                                             // 822\n      self._isSending = true;                                                                                         // 823\n      self._diffCollectionViews(beforeCVs);                                                                           // 824\n      if (!_.isEmpty(self._pendingReady)) {                                                                           // 825\n        self.sendReady(self._pendingReady);                                                                           // 826\n        self._pendingReady = [];                                                                                      // 827\n      }                                                                                                               //\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  _startSubscription: function (handler, subId, params, name) {                                                       // 832\n    var self = this;                                                                                                  // 833\n                                                                                                                      //\n    var sub = new Subscription(self, handler, subId, params, name);                                                   // 835\n    if (subId) self._namedSubs[subId] = sub;else self._universalSubs.push(sub);                                       // 837\n                                                                                                                      //\n    sub._runHandler();                                                                                                // 842\n  },                                                                                                                  //\n                                                                                                                      //\n  // tear down specified subscription                                                                                 //\n  _stopSubscription: function (subId, error) {                                                                        // 846\n    var self = this;                                                                                                  // 847\n                                                                                                                      //\n    var subName = null;                                                                                               // 849\n                                                                                                                      //\n    if (subId && self._namedSubs[subId]) {                                                                            // 851\n      subName = self._namedSubs[subId]._name;                                                                         // 852\n      self._namedSubs[subId]._removeAllDocuments();                                                                   // 853\n      self._namedSubs[subId]._deactivate();                                                                           // 854\n      delete self._namedSubs[subId];                                                                                  // 855\n    }                                                                                                                 //\n                                                                                                                      //\n    var response = { msg: 'nosub', id: subId };                                                                       // 858\n                                                                                                                      //\n    if (error) {                                                                                                      // 860\n      response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n    }                                                                                                                 //\n                                                                                                                      //\n    self.send(response);                                                                                              // 867\n  },                                                                                                                  //\n                                                                                                                      //\n  // tear down all subscriptions. Note that this does NOT send removed or nosub                                       //\n  // messages, since we assume the client is gone.                                                                    //\n  _deactivateAllSubscriptions: function () {                                                                          // 872\n    var self = this;                                                                                                  // 873\n                                                                                                                      //\n    _.each(self._namedSubs, function (sub, id) {                                                                      // 875\n      sub._deactivate();                                                                                              // 876\n    });                                                                                                               //\n    self._namedSubs = {};                                                                                             // 878\n                                                                                                                      //\n    _.each(self._universalSubs, function (sub) {                                                                      // 880\n      sub._deactivate();                                                                                              // 881\n    });                                                                                                               //\n    self._universalSubs = [];                                                                                         // 883\n  },                                                                                                                  //\n                                                                                                                      //\n  // Determine the remote client's IP address, based on the                                                           //\n  // HTTP_FORWARDED_COUNT environment variable representing how many                                                  //\n  // proxies the server is behind.                                                                                    //\n  _clientAddress: function () {                                                                                       // 889\n    var self = this;                                                                                                  // 890\n                                                                                                                      //\n    // For the reported client address for a connection to be correct,                                                //\n    // the developer must set the HTTP_FORWARDED_COUNT environment                                                    //\n    // variable to an integer representing the number of hops they                                                    //\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the                                                //\n    // server is behind one proxy.                                                                                    //\n    //                                                                                                                //\n    // This could be computed once at startup instead of every time.                                                  //\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;                                      // 899\n                                                                                                                      //\n    if (httpForwardedCount === 0) return self.socket.remoteAddress;                                                   // 901\n                                                                                                                      //\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];                                                        // 904\n    if (!_.isString(forwardedFor)) return null;                                                                       // 905\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);                                                              // 907\n                                                                                                                      //\n    // Typically the first value in the `x-forwarded-for` header is                                                   //\n    // the original IP address of the client connecting to the first                                                  //\n    // proxy.  However, the end user can easily spoof the header, in                                                  //\n    // which case the first value(s) will be the fake IP address from                                                 //\n    // the user pretending to be a proxy reporting the original IP                                                    //\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the                                                 //\n    // end of the list, we ensure that we get the IP address being                                                    //\n    // reported by *our* first proxy.                                                                                 //\n                                                                                                                      //\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;                              // 918\n                                                                                                                      //\n    return forwardedFor[forwardedFor.length - httpForwardedCount];                                                    // 921\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Subscription                                                               */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\n// ctor for a sub handle: the input to each publish function                                                          //\n                                                                                                                      //\n// Instance name is this because it's usually referred to as this inside a                                            //\n// publish                                                                                                            //\n/**                                                                                                                   //\n * @summary The server's side of a subscription                                                                       //\n * @class Subscription                                                                                                //\n * @instanceName this                                                                                                 //\n */                                                                                                                   //\nvar Subscription = function (session, handler, subscriptionId, params, name) {                                        // 938\n  var self = this;                                                                                                    // 940\n  self._session = session; // type is Session                                                                         // 941\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server                                                                                                    //\n   * @name  connection                                                                                                //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  self.connection = session.connectionHandle; // public API object                                                    // 950\n                                                                                                                      //\n  self._handler = handler;                                                                                            // 952\n                                                                                                                      //\n  // my subscription ID (generated by client, undefined for universal subs).                                          //\n  self._subscriptionId = subscriptionId;                                                                              // 955\n  // undefined for universal subs                                                                                     //\n  self._name = name;                                                                                                  // 957\n                                                                                                                      //\n  self._params = params || [];                                                                                        // 959\n                                                                                                                      //\n  // Only named subscriptions have IDs, but we need some sort of string                                               //\n  // internally to keep track of all subscriptions inside                                                             //\n  // SessionDocumentViews. We use this subscriptionHandle for that.                                                   //\n  if (self._subscriptionId) {                                                                                         // 964\n    self._subscriptionHandle = 'N' + self._subscriptionId;                                                            // 965\n  } else {                                                                                                            //\n    self._subscriptionHandle = 'U' + Random.id();                                                                     // 967\n  }                                                                                                                   //\n                                                                                                                      //\n  // has _deactivate been called?                                                                                     //\n  self._deactivated = false;                                                                                          // 971\n                                                                                                                      //\n  // stop callbacks to g/c this sub.  called w/ zero arguments.                                                       //\n  self._stopCallbacks = [];                                                                                           // 974\n                                                                                                                      //\n  // the set of (collection, documentid) that this subscription has                                                   //\n  // an opinion about                                                                                                 //\n  self._documents = {};                                                                                               // 978\n                                                                                                                      //\n  // remember if we are ready.                                                                                        //\n  self._ready = false;                                                                                                // 981\n                                                                                                                      //\n  // Part of the public API: the user of this sub.                                                                    //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.    //\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @name  userId                                                                                                    //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  self.userId = session.userId;                                                                                       // 992\n                                                                                                                      //\n  // For now, the id filter is going to default to                                                                    //\n  // the to/from DDP methods on MongoID, to                                                                           //\n  // specifically deal with mongo/minimongo ObjectIds.                                                                //\n                                                                                                                      //\n  // Later, you will be able to make this be \"raw\"                                                                    //\n  // if you want to publish a collection that you know                                                                //\n  // just has strings for keys and no funny business, to                                                              //\n  // a ddp consumer that isn't minimongo                                                                              //\n                                                                                                                      //\n  self._idFilter = {                                                                                                  // 1003\n    idStringify: MongoID.idStringify,                                                                                 // 1004\n    idParse: MongoID.idParse                                                                                          // 1005\n  };                                                                                                                  //\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);                           // 1008\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(Subscription.prototype, {                                                                                    // 1012\n  _runHandler: function () {                                                                                          // 1013\n    // XXX should we unblock() here? Either before running the publish                                                //\n    // function, or before running _publishCursor.                                                                    //\n    //                                                                                                                //\n    // Right now, each publish function blocks all future publishes and                                               //\n    // methods waiting on data from Mongo (or whatever else the function                                              //\n    // blocks on). This probably slows page load in common cases.                                                     //\n                                                                                                                      //\n    var self = this;                                                                                                  // 1021\n    try {                                                                                                             // 1022\n      var res = maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),                              // 1023\n      // It's OK that this would look weird for universal subscriptions,                                              //\n      // because they have no arguments so there can never be an                                                      //\n      // audit-argument-checks failure.                                                                               //\n      \"publisher '\" + self._name + \"'\");                                                                              // 1028\n    } catch (e) {                                                                                                     //\n      self.error(e);                                                                                                  // 1030\n      return;                                                                                                         // 1031\n    }                                                                                                                 //\n                                                                                                                      //\n    // Did the handler call this.error or this.stop?                                                                  //\n    if (self._isDeactivated()) return;                                                                                // 1035\n                                                                                                                      //\n    self._publishHandlerResult(res);                                                                                  // 1038\n  },                                                                                                                  //\n                                                                                                                      //\n  _publishHandlerResult: function (res) {                                                                             // 1041\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke                                               //\n    // this.added/changed/ready/etc, the user can just return a collection                                            //\n    // cursor or array of cursors from the publish function; we call their                                            //\n    // _publishCursor method which starts observing the cursor and publishes the                                      //\n    // results. Note that _publishCursor does NOT call ready().                                                       //\n    //                                                                                                                //\n    // XXX This uses an undocumented interface which only the Mongo cursor                                            //\n    // interface publishes. Should we make this interface public and encourage                                        //\n    // users to implement it themselves? Arguably, it's unnecessary; users can                                        //\n    // already write their own functions like                                                                         //\n    //   var publishMyReactiveThingy = function (name, handler) {                                                     //\n    //     Meteor.publish(name, function () {                                                                         //\n    //       var reactiveThingy = handler();                                                                          //\n    //       reactiveThingy.publishMe();                                                                              //\n    //     });                                                                                                        //\n    //   };                                                                                                           //\n                                                                                                                      //\n    var self = this;                                                                                                  // 1059\n    var isCursor = function (c) {                                                                                     // 1060\n      return c && c._publishCursor;                                                                                   // 1061\n    };                                                                                                                //\n    if (isCursor(res)) {                                                                                              // 1063\n      try {                                                                                                           // 1064\n        res._publishCursor(self);                                                                                     // 1065\n      } catch (e) {                                                                                                   //\n        self.error(e);                                                                                                // 1067\n        return;                                                                                                       // 1068\n      }                                                                                                               //\n      // _publishCursor only returns after the initial added callbacks have run.                                      //\n      // mark subscription as ready.                                                                                  //\n      self.ready();                                                                                                   // 1072\n    } else if (_.isArray(res)) {                                                                                      //\n      // check all the elements are cursors                                                                           //\n      if (!_.all(res, isCursor)) {                                                                                    // 1075\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));                                   // 1076\n        return;                                                                                                       // 1077\n      }                                                                                                               //\n      // find duplicate collection names                                                                              //\n      // XXX we should support overlapping cursors, but that would require the                                        //\n      // merge box to allow overlap within a subscription                                                             //\n      var collectionNames = {};                                                                                       // 1082\n      for (var i = 0; i < res.length; ++i) {                                                                          // 1083\n        var collectionName = res[i]._getCollectionName();                                                             // 1084\n        if (_.has(collectionNames, collectionName)) {                                                                 // 1085\n          self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));       // 1086\n          return;                                                                                                     // 1089\n        }                                                                                                             //\n        collectionNames[collectionName] = true;                                                                       // 1091\n      };                                                                                                              //\n                                                                                                                      //\n      try {                                                                                                           // 1094\n        _.each(res, function (cur) {                                                                                  // 1095\n          cur._publishCursor(self);                                                                                   // 1096\n        });                                                                                                           //\n      } catch (e) {                                                                                                   //\n        self.error(e);                                                                                                // 1099\n        return;                                                                                                       // 1100\n      }                                                                                                               //\n      self.ready();                                                                                                   // 1102\n    } else if (res) {                                                                                                 //\n      // truthy values other than cursors or arrays are probably a                                                    //\n      // user mistake (possible returning a Mongo document via, say,                                                  //\n      // `coll.findOne()`).                                                                                           //\n      self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));                 // 1107\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  // This calls all stop callbacks and prevents the handler from updating any                                         //\n  // SessionCollectionViews further. It's used when the user unsubscribes or                                          //\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send                                             //\n  // removed messages for the published objects; if that is necessary, call                                           //\n  // _removeAllDocuments first.                                                                                       //\n  _deactivate: function () {                                                                                          // 1117\n    var self = this;                                                                                                  // 1118\n    if (self._deactivated) return;                                                                                    // 1119\n    self._deactivated = true;                                                                                         // 1121\n    self._callStopCallbacks();                                                                                        // 1122\n    Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);                        // 1123\n  },                                                                                                                  //\n                                                                                                                      //\n  _callStopCallbacks: function () {                                                                                   // 1127\n    var self = this;                                                                                                  // 1128\n    // tell listeners, so they can clean up                                                                           //\n    var callbacks = self._stopCallbacks;                                                                              // 1130\n    self._stopCallbacks = [];                                                                                         // 1131\n    _.each(callbacks, function (callback) {                                                                           // 1132\n      callback();                                                                                                     // 1133\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Send remove messages for every document.                                                                         //\n  _removeAllDocuments: function () {                                                                                  // 1138\n    var self = this;                                                                                                  // 1139\n    Meteor._noYieldsAllowed(function () {                                                                             // 1140\n      _.each(self._documents, function (collectionDocs, collectionName) {                                             // 1141\n        // Iterate over _.keys instead of the dictionary itself, since we'll be                                       //\n        // mutating it.                                                                                               //\n        _.each(_.keys(collectionDocs), function (strId) {                                                             // 1144\n          self.removed(collectionName, self._idFilter.idParse(strId));                                                // 1145\n        });                                                                                                           //\n      });                                                                                                             //\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Returns a new Subscription for the same session with the same                                                    //\n  // initial creation parameters. This isn't a clone: it doesn't have                                                 //\n  // the same _documents cache, stopped state or callbacks; may have a                                                //\n  // different _subscriptionHandle, and gets its userId from the                                                      //\n  // session, not from this object.                                                                                   //\n  _recreate: function () {                                                                                            // 1156\n    var self = this;                                                                                                  // 1157\n    return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);            // 1158\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server                                                                                                    //\n   * @param {Error} error The error to pass to the client.                                                            //\n   * @instance                                                                                                        //\n   * @memberOf Subscription                                                                                           //\n   */                                                                                                                 //\n  error: function (error) {                                                                                           // 1170\n    var self = this;                                                                                                  // 1171\n    if (self._isDeactivated()) return;                                                                                // 1172\n    self._session._stopSubscription(self._subscriptionId, error);                                                     // 1174\n  },                                                                                                                  //\n                                                                                                                      //\n  // Note that while our DDP client will notice that you've called stop() on the                                      //\n  // server (and clean up its _subscriptions table) we don't actually provide a                                       //\n  // mechanism for an app to notice this (the subscribe onError callback only                                         //\n  // triggers if there is an error).                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server                                                                                                    //\n   * @instance                                                                                                        //\n   * @memberOf Subscription                                                                                           //\n   */                                                                                                                 //\n  stop: function () {                                                                                                 // 1188\n    var self = this;                                                                                                  // 1189\n    if (self._isDeactivated()) return;                                                                                // 1190\n    self._session._stopSubscription(self._subscriptionId);                                                            // 1192\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {Function} func The callback function                                                                     //\n   */                                                                                                                 //\n  onStop: function (callback) {                                                                                       // 1202\n    var self = this;                                                                                                  // 1203\n    if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);                                    // 1204\n  },                                                                                                                  //\n                                                                                                                      //\n  // This returns true if the sub has been deactivated, *OR* if the session was                                       //\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't                                            //\n  // happened yet.                                                                                                    //\n  _isDeactivated: function () {                                                                                       // 1213\n    var self = this;                                                                                                  // 1214\n    return self._deactivated || self._session.inQueue === null;                                                       // 1215\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that contains the new document.                            //\n   * @param {String} id The new document's ID.                                                                        //\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.                       //\n   */                                                                                                                 //\n  added: function (collectionName, id, fields) {                                                                      // 1227\n    var self = this;                                                                                                  // 1228\n    if (self._isDeactivated()) return;                                                                                // 1229\n    id = self._idFilter.idStringify(id);                                                                              // 1231\n    Meteor._ensure(self._documents, collectionName)[id] = true;                                                       // 1232\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);                                        // 1233\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that contains the changed document.                        //\n   * @param {String} id The changed document's ID.                                                                    //\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */                                                                                                                 //\n  changed: function (collectionName, id, fields) {                                                                    // 1245\n    var self = this;                                                                                                  // 1246\n    if (self._isDeactivated()) return;                                                                                // 1247\n    id = self._idFilter.idStringify(id);                                                                              // 1249\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);                                      // 1250\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that the document has been removed from.                   //\n   * @param {String} id The ID of the document that has been removed.                                                 //\n   */                                                                                                                 //\n  removed: function (collectionName, id) {                                                                            // 1261\n    var self = this;                                                                                                  // 1262\n    if (self._isDeactivated()) return;                                                                                // 1263\n    id = self._idFilter.idStringify(id);                                                                              // 1265\n    // We don't bother to delete sets of things in a collection if the                                                //\n    // collection is empty.  It could break _removeAllDocuments.                                                      //\n    delete self._documents[collectionName][id];                                                                       // 1268\n    self._session.removed(self._subscriptionHandle, collectionName, id);                                              // 1269\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  ready: function () {                                                                                                // 1278\n    var self = this;                                                                                                  // 1279\n    if (self._isDeactivated()) return;                                                                                // 1280\n    if (!self._subscriptionId) return; // unnecessary but ignored for universal sub                                   // 1282\n    if (!self._ready) {                                                                                               // 1284\n      self._session.sendReady([self._subscriptionId]);                                                                // 1285\n      self._ready = true;                                                                                             // 1286\n    }                                                                                                                 //\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Server                                                                     */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\nServer = function (options) {                                                                                         // 1295\n  var self = this;                                                                                                    // 1296\n                                                                                                                      //\n  // The default heartbeat interval is 30 seconds on the server and 35                                                //\n  // seconds on the client.  Since the client doesn't need to send a                                                  //\n  // ping as long as it is receiving pings, this means that pings                                                     //\n  // normally go from the server to the client.                                                                       //\n  //                                                                                                                  //\n  // Note: Troposphere depends on the ability to mutate                                                               //\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                           //\n  self.options = _.defaults(options || {}, {                                                                          // 1305\n    heartbeatInterval: 15000,                                                                                         // 1306\n    heartbeatTimeout: 15000,                                                                                          // 1307\n    // For testing, allow responding to pings to be disabled.                                                         //\n    respondToPings: true                                                                                              // 1309\n  });                                                                                                                 //\n                                                                                                                      //\n  // Map of callbacks to call when a new connection comes in to the                                                   //\n  // server and completes DDP version negotiation. Use an object instead                                              //\n  // of an array so we can safely remove one from the list while                                                      //\n  // iterating over it.                                                                                               //\n  self.onConnectionHook = new Hook({                                                                                  // 1316\n    debugPrintExceptions: \"onConnection callback\"                                                                     // 1317\n  });                                                                                                                 //\n                                                                                                                      //\n  self.publish_handlers = {};                                                                                         // 1320\n  self.universal_publish_handlers = [];                                                                               // 1321\n                                                                                                                      //\n  self.method_handlers = {};                                                                                          // 1323\n                                                                                                                      //\n  self.sessions = {}; // map from id to session                                                                       // 1325\n                                                                                                                      //\n  self.stream_server = new StreamServer();                                                                            // 1327\n                                                                                                                      //\n  self.stream_server.register(function (socket) {                                                                     // 1329\n    // socket implements the SockJSConnection interface                                                               //\n    socket._meteorSession = null;                                                                                     // 1331\n                                                                                                                      //\n    var sendError = function (reason, offendingMessage) {                                                             // 1333\n      var msg = { msg: 'error', reason: reason };                                                                     // 1334\n      if (offendingMessage) msg.offendingMessage = offendingMessage;                                                  // 1335\n      socket.send(DDPCommon.stringifyDDP(msg));                                                                       // 1337\n    };                                                                                                                //\n                                                                                                                      //\n    socket.on('data', function (raw_msg) {                                                                            // 1340\n      if (Meteor._printReceivedDDP) {                                                                                 // 1341\n        Meteor._debug(\"Received DDP\", raw_msg);                                                                       // 1342\n      }                                                                                                               //\n      try {                                                                                                           // 1344\n        try {                                                                                                         // 1345\n          var msg = DDPCommon.parseDDP(raw_msg);                                                                      // 1346\n        } catch (err) {                                                                                               //\n          sendError('Parse error');                                                                                   // 1348\n          return;                                                                                                     // 1349\n        }                                                                                                             //\n        if (msg === null || !msg.msg) {                                                                               // 1351\n          sendError('Bad request', msg);                                                                              // 1352\n          return;                                                                                                     // 1353\n        }                                                                                                             //\n                                                                                                                      //\n        if (msg.msg === 'connect') {                                                                                  // 1356\n          if (socket._meteorSession) {                                                                                // 1357\n            sendError(\"Already connected\", msg);                                                                      // 1358\n            return;                                                                                                   // 1359\n          }                                                                                                           //\n          Fiber(function () {                                                                                         // 1361\n            self._handleConnect(socket, msg);                                                                         // 1362\n          }).run();                                                                                                   //\n          return;                                                                                                     // 1364\n        }                                                                                                             //\n                                                                                                                      //\n        if (!socket._meteorSession) {                                                                                 // 1367\n          sendError('Must connect first', msg);                                                                       // 1368\n          return;                                                                                                     // 1369\n        }                                                                                                             //\n        socket._meteorSession.processMessage(msg);                                                                    // 1371\n      } catch (e) {                                                                                                   //\n        // XXX print stack nicely                                                                                     //\n        Meteor._debug(\"Internal exception while processing message\", msg, e.message, e.stack);                        // 1374\n      }                                                                                                               //\n    });                                                                                                               //\n                                                                                                                      //\n    socket.on('close', function () {                                                                                  // 1379\n      if (socket._meteorSession) {                                                                                    // 1380\n        Fiber(function () {                                                                                           // 1381\n          socket._meteorSession.close();                                                                              // 1382\n        }).run();                                                                                                     //\n      }                                                                                                               //\n    });                                                                                                               //\n  });                                                                                                                 //\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(Server.prototype, {                                                                                          // 1389\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Register a callback to be called when a new DDP connection is made to the server.                       //\n   * @locus Server                                                                                                    //\n   * @param {function} callback The function to call when a new DDP connection is established.                        //\n   * @memberOf Meteor                                                                                                 //\n   */                                                                                                                 //\n  onConnection: function (fn) {                                                                                       // 1397\n    var self = this;                                                                                                  // 1398\n    return self.onConnectionHook.register(fn);                                                                        // 1399\n  },                                                                                                                  //\n                                                                                                                      //\n  _handleConnect: function (socket, msg) {                                                                            // 1402\n    var self = this;                                                                                                  // 1403\n                                                                                                                      //\n    // The connect message must specify a version and an array of supported                                           //\n    // versions, and it must claim to support what it is proposing.                                                   //\n    if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({ msg: 'failed',                                                             // 1411\n        version: DDPCommon.SUPPORTED_DDP_VERSIONS[0] }));                                                             // 1412\n      socket.close();                                                                                                 // 1413\n      return;                                                                                                         // 1414\n    }                                                                                                                 //\n                                                                                                                      //\n    // In the future, handle session resumption: something like:                                                      //\n    //  socket._meteorSession = self.sessions[msg.session]                                                            //\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);                                    // 1419\n                                                                                                                      //\n    if (msg.version !== version) {                                                                                    // 1421\n      // The best version to use (according to the client's stated preferences)                                       //\n      // is not the one the client is trying to use. Inform them about the best                                       //\n      // version to use.                                                                                              //\n      socket.send(DDPCommon.stringifyDDP({ msg: 'failed', version: version }));                                       // 1425\n      socket.close();                                                                                                 // 1426\n      return;                                                                                                         // 1427\n    }                                                                                                                 //\n                                                                                                                      //\n    // Yay, version matches! Create a new session.                                                                    //\n    // Note: Troposphere depends on the ability to mutate                                                             //\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                         //\n    socket._meteorSession = new Session(self, version, socket, self.options);                                         // 1433\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;                                                  // 1434\n    self.onConnectionHook.each(function (callback) {                                                                  // 1435\n      if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);                                    // 1436\n      return true;                                                                                                    // 1438\n    });                                                                                                               //\n  },                                                                                                                  //\n  /**                                                                                                                 //\n   * Register a publish handler function.                                                                             //\n   *                                                                                                                  //\n   * @param name {String} identifier for query                                                                        //\n   * @param handler {Function} publish handler                                                                        //\n   * @param options {Object}                                                                                          //\n   *                                                                                                                  //\n   * Server will call handler function on each new subscription,                                                      //\n   * either when receiving DDP sub message for a named subscription, or on                                            //\n   * DDP connect for a universal subscription.                                                                        //\n   *                                                                                                                  //\n   * If name is null, this will be a subscription that is                                                             //\n   * automatically established and permanently on for all connected                                                   //\n   * client, instead of a subscription that can be turned on and off                                                  //\n   * with subscribe().                                                                                                //\n   *                                                                                                                  //\n   * options to contain:                                                                                              //\n   *  - (mostly internal) is_auto: true if generated automatically                                                    //\n   *    from an autopublish hook. this is for cosmetic purposes only                                                  //\n   *    (it lets us determine whether to print a warning suggesting                                                   //\n   *    that you turn off autopublish.)                                                                               //\n   */                                                                                                                 //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Publish a record set.                                                                                   //\n   * @memberOf Meteor                                                                                                 //\n   * @locus Server                                                                                                    //\n   * @param {String} name Name of the record set.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */                                                                                                                 //\n  publish: function (name, handler, options) {                                                                        // 1471\n    var self = this;                                                                                                  // 1472\n                                                                                                                      //\n    options = options || {};                                                                                          // 1474\n                                                                                                                      //\n    if (name && name in self.publish_handlers) {                                                                      // 1476\n      Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");                                               // 1477\n      return;                                                                                                         // 1478\n    }                                                                                                                 //\n                                                                                                                      //\n    if (Package.autopublish && !options.is_auto) {                                                                    // 1481\n      // They have autopublish on, yet they're trying to manually                                                     //\n      // picking stuff to publish. They probably should turn off                                                      //\n      // autopublish. (This check isn't perfect -- if you create a                                                    //\n      // publish before you turn on autopublish, it won't catch                                                       //\n      // it. But this will definitely handle the simple case where                                                    //\n      // you've added the autopublish package to your app, and are                                                    //\n      // calling publish from your app code.)                                                                         //\n      if (!self.warned_about_autopublish) {                                                                           // 1489\n        self.warned_about_autopublish = true;                                                                         // 1490\n        Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n      }                                                                                                               //\n    }                                                                                                                 //\n                                                                                                                      //\n    if (name) self.publish_handlers[name] = handler;else {                                                            // 1506\n      self.universal_publish_handlers.push(handler);                                                                  // 1509\n      // Spin up the new publisher on any existing session too. Run each                                              //\n      // session's subscription in a new Fiber, so that there's no change for                                         //\n      // self.sessions to change while we're running this loop.                                                       //\n      _.each(self.sessions, function (session) {                                                                      // 1513\n        if (!session._dontStartNewUniversalSubs) {                                                                    // 1514\n          Fiber(function () {                                                                                         // 1515\n            session._startSubscription(handler);                                                                      // 1516\n          }).run();                                                                                                   //\n        }                                                                                                             //\n      });                                                                                                             //\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  _removeSession: function (session) {                                                                                // 1523\n    var self = this;                                                                                                  // 1524\n    if (self.sessions[session.id]) {                                                                                  // 1525\n      delete self.sessions[session.id];                                                                               // 1526\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Defines functions that can be invoked over the network by clients.                                      //\n   * @locus Anywhere                                                                                                  //\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.                         //\n   * @memberOf Meteor                                                                                                 //\n   */                                                                                                                 //\n  methods: function (methods) {                                                                                       // 1536\n    var self = this;                                                                                                  // 1537\n    _.each(methods, function (func, name) {                                                                           // 1538\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");                    // 1539\n      if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");            // 1541\n      self.method_handlers[name] = func;                                                                              // 1543\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  call: function (name /*, arguments */) {                                                                            // 1547\n    // if it's a function, the last argument is the result callback,                                                  //\n    // not a parameter to the remote method.                                                                          //\n    var args = Array.prototype.slice.call(arguments, 1);                                                              // 1550\n    if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();                        // 1551\n    return this.apply(name, args, callback);                                                                          // 1553\n  },                                                                                                                  //\n                                                                                                                      //\n  // @param options {Optional Object}                                                                                 //\n  // @param callback {Optional Function}                                                                              //\n  apply: function (name, args, options, callback) {                                                                   // 1558\n    var self = this;                                                                                                  // 1559\n                                                                                                                      //\n    // We were passed 3 arguments. They may be either (name, args, options)                                           //\n    // or (name, args, callback)                                                                                      //\n    if (!callback && typeof options === 'function') {                                                                 // 1563\n      callback = options;                                                                                             // 1564\n      options = {};                                                                                                   // 1565\n    }                                                                                                                 //\n    options = options || {};                                                                                          // 1567\n                                                                                                                      //\n    if (callback)                                                                                                     // 1569\n      // It's not really necessary to do this, since we immediately                                                   //\n      // run the callback in this fiber before returning, but we do it                                                //\n      // anyway for regularity.                                                                                       //\n      // XXX improve error message (and how we report it)                                                             //\n      callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");                    // 1574\n                                                                                                                      //\n    // Run the handler                                                                                                //\n    var handler = self.method_handlers[name];                                                                         // 1580\n    var exception;                                                                                                    // 1581\n    if (!handler) {                                                                                                   // 1582\n      exception = new Meteor.Error(404, \"Method not found\");                                                          // 1583\n    } else {                                                                                                          //\n      // If this is a method call from within another method, get the                                                 //\n      // user state from the outer method, otherwise don't allow                                                      //\n      // setUserId to be called                                                                                       //\n      var userId = null;                                                                                              // 1588\n      var setUserId = function () {                                                                                   // 1589\n        throw new Error(\"Can't call setUserId on a server initiated method call\");                                    // 1590\n      };                                                                                                              //\n      var connection = null;                                                                                          // 1592\n      var currentInvocation = DDP._CurrentInvocation.get();                                                           // 1593\n      if (currentInvocation) {                                                                                        // 1594\n        userId = currentInvocation.userId;                                                                            // 1595\n        setUserId = function (userId) {                                                                               // 1596\n          currentInvocation.setUserId(userId);                                                                        // 1597\n        };                                                                                                            //\n        connection = currentInvocation.connection;                                                                    // 1599\n      }                                                                                                               //\n                                                                                                                      //\n      var invocation = new DDPCommon.MethodInvocation({                                                               // 1602\n        isSimulation: false,                                                                                          // 1603\n        userId: userId,                                                                                               // 1604\n        setUserId: setUserId,                                                                                         // 1605\n        connection: connection,                                                                                       // 1606\n        randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)                                                    // 1607\n      });                                                                                                             //\n      try {                                                                                                           // 1609\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {                                       // 1610\n          return maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\");\n        });                                                                                                           //\n        result = EJSON.clone(result);                                                                                 // 1615\n      } catch (e) {                                                                                                   //\n        exception = e;                                                                                                // 1617\n      }                                                                                                               //\n    }                                                                                                                 //\n                                                                                                                      //\n    // Return the result in whichever way the caller asked for it. Note that we                                       //\n    // do NOT block on the write fence in an analogous way to how the client                                          //\n    // blocks on the relevant data being visible, so you are NOT guaranteed that                                      //\n    // cursor observe callbacks have fired when your callback is invoked. (We                                         //\n    // can change this if there's a real use case.)                                                                   //\n    if (callback) {                                                                                                   // 1626\n      callback(exception, result);                                                                                    // 1627\n      return undefined;                                                                                               // 1628\n    }                                                                                                                 //\n    if (exception) throw exception;                                                                                   // 1630\n    return result;                                                                                                    // 1632\n  },                                                                                                                  //\n                                                                                                                      //\n  _urlForSession: function (sessionId) {                                                                              // 1635\n    var self = this;                                                                                                  // 1636\n    var session = self.sessions[sessionId];                                                                           // 1637\n    if (session) return session._socketUrl;else return null;                                                          // 1638\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\nvar calculateVersion = function (clientSupportedVersions, serverSupportedVersions) {                                  // 1645\n  var correctVersion = _.find(clientSupportedVersions, function (version) {                                           // 1647\n    return _.contains(serverSupportedVersions, version);                                                              // 1648\n  });                                                                                                                 //\n  if (!correctVersion) {                                                                                              // 1650\n    correctVersion = serverSupportedVersions[0];                                                                      // 1651\n  }                                                                                                                   //\n  return correctVersion;                                                                                              // 1653\n};                                                                                                                    //\n                                                                                                                      //\nDDPServer._calculateVersion = calculateVersion;                                                                       // 1656\n                                                                                                                      //\n// \"blind\" exceptions other than those that were deliberately thrown to signal                                        //\n// errors to the client                                                                                               //\nvar wrapInternalException = function (exception, context) {                                                           // 1661\n  if (!exception || exception instanceof Meteor.Error) return exception;                                              // 1662\n                                                                                                                      //\n  // tests can set the 'expected' flag on an exception so it won't go to the                                          //\n  // server log                                                                                                       //\n  if (!exception.expected) {                                                                                          // 1667\n    Meteor._debug(\"Exception \" + context, exception.stack);                                                           // 1668\n    if (exception.sanitizedError) {                                                                                   // 1669\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);                    // 1670\n      Meteor._debug();                                                                                                // 1671\n    }                                                                                                                 //\n  }                                                                                                                   //\n                                                                                                                      //\n  // Did the error contain more details that could have been useful if caught in                                      //\n  // server code (or if thrown from non-client-originated code), but also                                             //\n  // provided a \"sanitized\" version with more context than 500 Internal server                                        //\n  // error? Use that.                                                                                                 //\n  if (exception.sanitizedError) {                                                                                     // 1679\n    if (exception.sanitizedError instanceof Meteor.Error) return exception.sanitizedError;                            // 1680\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"is not a Meteor.Error; ignoring\");   // 1682\n  }                                                                                                                   //\n                                                                                                                      //\n  return new Meteor.Error(500, \"Internal server error\");                                                              // 1686\n};                                                                                                                    //\n                                                                                                                      //\n// Audit argument checks, if the audit-argument-checks package exists (it is a                                        //\n// weak dependency of this package).                                                                                  //\nvar maybeAuditArgumentChecks = function (f, context, args, description) {                                             // 1692\n  args = args || [];                                                                                                  // 1693\n  if (Package['audit-argument-checks']) {                                                                             // 1694\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);                                     // 1695\n  }                                                                                                                   //\n  return f.apply(context, args);                                                                                      // 1698\n};                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/writefence.js                                                                                  //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar path = Npm.require('path');                                                                                       // 1\nvar Future = Npm.require(path.join('fibers', 'future'));                                                              // 2\n                                                                                                                      //\n// A write fence collects a group of writes, and provides a callback                                                  //\n// when all of the writes are fully committed and propagated (all                                                     //\n// observers have been notified of the write and acknowledged it.)                                                    //\n//                                                                                                                    //\nDDPServer._WriteFence = function () {                                                                                 // 8\n  var self = this;                                                                                                    // 9\n                                                                                                                      //\n  self.armed = false;                                                                                                 // 11\n  self.fired = false;                                                                                                 // 12\n  self.retired = false;                                                                                               // 13\n  self.outstanding_writes = 0;                                                                                        // 14\n  self.before_fire_callbacks = [];                                                                                    // 15\n  self.completion_callbacks = [];                                                                                     // 16\n};                                                                                                                    //\n                                                                                                                      //\n// The current write fence. When there is a current write fence, code                                                 //\n// that writes to databases should register their writes with it using                                                //\n// beginWrite().                                                                                                      //\n//                                                                                                                    //\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();                                                      // 23\n                                                                                                                      //\n_.extend(DDPServer._WriteFence.prototype, {                                                                           // 25\n  // Start tracking a write, and return an object to represent it. The                                                //\n  // object has a single method, committed(). This method should be                                                   //\n  // called when the write is fully committed and propagated. You can                                                 //\n  // continue to add writes to the WriteFence up until it is triggered                                                //\n  // (calls its callbacks because all writes have committed.)                                                         //\n  beginWrite: function () {                                                                                           // 31\n    var self = this;                                                                                                  // 32\n                                                                                                                      //\n    if (self.retired) return { committed: function () {} };                                                           // 34\n                                                                                                                      //\n    if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");                         // 37\n                                                                                                                      //\n    self.outstanding_writes++;                                                                                        // 40\n    var committed = false;                                                                                            // 41\n    return {                                                                                                          // 42\n      committed: function () {                                                                                        // 43\n        if (committed) throw new Error(\"committed called twice on the same write\");                                   // 44\n        committed = true;                                                                                             // 46\n        self.outstanding_writes--;                                                                                    // 47\n        self._maybeFire();                                                                                            // 48\n      }                                                                                                               //\n    };                                                                                                                //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Arm the fence. Once the fence is armed, and there are no more                                                    //\n  // uncommitted writes, it will activate.                                                                            //\n  arm: function () {                                                                                                  // 55\n    var self = this;                                                                                                  // 56\n    if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");                      // 57\n    self.armed = true;                                                                                                // 59\n    self._maybeFire();                                                                                                // 60\n  },                                                                                                                  //\n                                                                                                                      //\n  // Register a function to be called once before firing the fence.                                                   //\n  // Callback function can add new writes to the fence, in which case                                                 //\n  // it won't fire until those writes are done as well.                                                               //\n  onBeforeFire: function (func) {                                                                                     // 66\n    var self = this;                                                                                                  // 67\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");                // 68\n    self.before_fire_callbacks.push(func);                                                                            // 71\n  },                                                                                                                  //\n                                                                                                                      //\n  // Register a function to be called when the fence fires.                                                           //\n  onAllCommitted: function (func) {                                                                                   // 75\n    var self = this;                                                                                                  // 76\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");                // 77\n    self.completion_callbacks.push(func);                                                                             // 80\n  },                                                                                                                  //\n                                                                                                                      //\n  // Convenience function. Arms the fence, then blocks until it fires.                                                //\n  armAndWait: function () {                                                                                           // 84\n    var self = this;                                                                                                  // 85\n    var future = new Future();                                                                                        // 86\n    self.onAllCommitted(function () {                                                                                 // 87\n      future['return']();                                                                                             // 88\n    });                                                                                                               //\n    self.arm();                                                                                                       // 90\n    future.wait();                                                                                                    // 91\n  },                                                                                                                  //\n                                                                                                                      //\n  _maybeFire: function () {                                                                                           // 94\n    var self = this;                                                                                                  // 95\n    if (self.fired) throw new Error(\"write fence already activated?\");                                                // 96\n    if (self.armed && !self.outstanding_writes) {                                                                     // 98\n      function invokeCallback(func) {                                                                                 // 99\n        try {                                                                                                         // 100\n          func(self);                                                                                                 // 101\n        } catch (err) {                                                                                               //\n          Meteor._debug(\"exception in write fence callback:\", err);                                                   // 103\n        }                                                                                                             //\n      }                                                                                                               //\n                                                                                                                      //\n      self.outstanding_writes++;                                                                                      // 107\n      while (self.before_fire_callbacks.length > 0) {                                                                 // 108\n        var callbacks = self.before_fire_callbacks;                                                                   // 109\n        self.before_fire_callbacks = [];                                                                              // 110\n        _.each(callbacks, invokeCallback);                                                                            // 111\n      }                                                                                                               //\n      self.outstanding_writes--;                                                                                      // 113\n                                                                                                                      //\n      if (!self.outstanding_writes) {                                                                                 // 115\n        self.fired = true;                                                                                            // 116\n        var callbacks = self.completion_callbacks;                                                                    // 117\n        self.completion_callbacks = [];                                                                               // 118\n        _.each(callbacks, invokeCallback);                                                                            // 119\n      }                                                                                                               //\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Deactivate this fence so that adding more writes has no effect.                                                  //\n  // The fence must have already fired.                                                                               //\n  retire: function () {                                                                                               // 126\n    var self = this;                                                                                                  // 127\n    if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");                                      // 128\n    self.retired = true;                                                                                              // 130\n  }                                                                                                                   //\n});                                                                                                                   //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/crossbar.js                                                                                    //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// A \"crossbar\" is a class that provides structured notification registration.                                        //\n// See _match for the definition of how a notification matches a trigger.                                             //\n// All notifications and triggers must have a string key named 'collection'.                                          //\n                                                                                                                      //\nDDPServer._Crossbar = function (options) {                                                                            // 5\n  var self = this;                                                                                                    // 6\n  options = options || {};                                                                                            // 7\n                                                                                                                      //\n  self.nextId = 1;                                                                                                    // 9\n  // map from collection name (string) -> listener id -> object. each object has                                      //\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no                                               //\n  // collection\".                                                                                                     //\n  self.listenersByCollection = {};                                                                                    // 13\n  self.factPackage = options.factPackage || \"livedata\";                                                               // 14\n  self.factName = options.factName || null;                                                                           // 15\n};                                                                                                                    //\n                                                                                                                      //\n_.extend(DDPServer._Crossbar.prototype, {                                                                             // 18\n  // msg is a trigger or a notification                                                                               //\n  _collectionForMessage: function (msg) {                                                                             // 20\n    var self = this;                                                                                                  // 21\n    if (!_.has(msg, 'collection')) {                                                                                  // 22\n      return '';                                                                                                      // 23\n    } else if (typeof msg.collection === 'string') {                                                                  //\n      if (msg.collection === '') throw Error(\"Message has empty collection!\");                                        // 25\n      return msg.collection;                                                                                          // 27\n    } else {                                                                                                          //\n      throw Error(\"Message has non-string collection!\");                                                              // 29\n    }                                                                                                                 //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Listen for notification that match 'trigger'. A notification                                                     //\n  // matches if it has the key-value pairs in trigger as a                                                            //\n  // subset. When a notification matches, call 'callback', passing                                                    //\n  // the actual notification.                                                                                         //\n  //                                                                                                                  //\n  // Returns a listen handle, which is an object with a method                                                        //\n  // stop(). Call stop() to stop listening.                                                                           //\n  //                                                                                                                  //\n  // XXX It should be legal to call fire() from inside a listen()                                                     //\n  // callback?                                                                                                        //\n  listen: function (trigger, callback) {                                                                              // 43\n    var self = this;                                                                                                  // 44\n    var id = self.nextId++;                                                                                           // 45\n                                                                                                                      //\n    var collection = self._collectionForMessage(trigger);                                                             // 47\n    var record = { trigger: EJSON.clone(trigger), callback: callback };                                               // 48\n    if (!_.has(self.listenersByCollection, collection)) {                                                             // 49\n      self.listenersByCollection[collection] = {};                                                                    // 50\n    }                                                                                                                 //\n    self.listenersByCollection[collection][id] = record;                                                              // 52\n                                                                                                                      //\n    if (self.factName && Package.facts) {                                                                             // 54\n      Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1);                                    // 55\n    }                                                                                                                 //\n                                                                                                                      //\n    return {                                                                                                          // 59\n      stop: function () {                                                                                             // 60\n        if (self.factName && Package.facts) {                                                                         // 61\n          Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1);                               // 62\n        }                                                                                                             //\n        delete self.listenersByCollection[collection][id];                                                            // 65\n        if (_.isEmpty(self.listenersByCollection[collection])) {                                                      // 66\n          delete self.listenersByCollection[collection];                                                              // 67\n        }                                                                                                             //\n      }                                                                                                               //\n    };                                                                                                                //\n  },                                                                                                                  //\n                                                                                                                      //\n  // Fire the provided 'notification' (an object whose attribute                                                      //\n  // values are all JSON-compatibile) -- inform all matching listeners                                                //\n  // (registered with listen()).                                                                                      //\n  //                                                                                                                  //\n  // If fire() is called inside a write fence, then each of the                                                       //\n  // listener callbacks will be called inside the write fence as well.                                                //\n  //                                                                                                                  //\n  // The listeners may be invoked in parallel, rather than serially.                                                  //\n  fire: function (notification) {                                                                                     // 81\n    var self = this;                                                                                                  // 82\n                                                                                                                      //\n    var collection = self._collectionForMessage(notification);                                                        // 84\n                                                                                                                      //\n    if (!_.has(self.listenersByCollection, collection)) {                                                             // 86\n      return;                                                                                                         // 87\n    }                                                                                                                 //\n                                                                                                                      //\n    var listenersForCollection = self.listenersByCollection[collection];                                              // 90\n    var callbackIds = [];                                                                                             // 91\n    _.each(listenersForCollection, function (l, id) {                                                                 // 92\n      if (self._matches(notification, l.trigger)) {                                                                   // 93\n        callbackIds.push(id);                                                                                         // 94\n      }                                                                                                               //\n    });                                                                                                               //\n                                                                                                                      //\n    // Listener callbacks can yield, so we need to first find all the ones that                                       //\n    // match in a single iteration over self.listenersByCollection (which can't                                       //\n    // be mutated during this iteration), and then invoke the matching                                                //\n    // callbacks, checking before each call to ensure they haven't stopped.                                           //\n    // Note that we don't have to check that                                                                          //\n    // self.listenersByCollection[collection] still === listenersForCollection,                                       //\n    // because the only way that stops being true is if listenersForCollection                                        //\n    // first gets reduced down to the empty object (and then never gets                                               //\n    // increased again).                                                                                              //\n    _.each(callbackIds, function (id) {                                                                               // 107\n      if (_.has(listenersForCollection, id)) {                                                                        // 108\n        listenersForCollection[id].callback(notification);                                                            // 109\n      }                                                                                                               //\n    });                                                                                                               //\n  },                                                                                                                  //\n                                                                                                                      //\n  // A notification matches a trigger if all keys that exist in both are equal.                                       //\n  //                                                                                                                  //\n  // Examples:                                                                                                        //\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}                                                                 //\n  //    (a non-targeted write to a collection matches a                                                               //\n  //     non-targeted query)                                                                                          //\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}                                                        //\n  //    (a targeted write to a collection matches a non-targeted query)                                               //\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}                                                        //\n  //    (a non-targeted write to a collection matches a                                                               //\n  //     targeted query)                                                                                              //\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}                                               //\n  //    (a targeted write to a collection matches a targeted query targeted                                           //\n  //     at the same document)                                                                                        //\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}                                        //\n  //    (a targeted write to a collection does not match a targeted query                                             //\n  //     targeted at a different document)                                                                            //\n  _matches: function (notification, trigger) {                                                                        // 131\n    // Most notifications that use the crossbar have a string `collection` and                                        //\n    // maybe an `id` that is a string or ObjectID. We're already dividing up                                          //\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and                                         //\n    // avoid the overly generic EJSON.equals). This makes a noticeable                                                //\n    // performance difference; see https://github.com/meteor/meteor/pull/3697                                         //\n    if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {    // 137\n      return false;                                                                                                   // 140\n    }                                                                                                                 //\n    if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n      return false;                                                                                                   // 145\n    }                                                                                                                 //\n                                                                                                                      //\n    return _.all(trigger, function (triggerValue, key) {                                                              // 148\n      return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);                              // 149\n    });                                                                                                               //\n  }                                                                                                                   //\n});                                                                                                                   //\n                                                                                                                      //\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to                                       //\n// implement write fence notifications. Listener callbacks on this crossbar                                           //\n// should call beginWrite on the current write fence before they return, if they                                      //\n// want to delay the write fence from firing (ie, the DDP method-data-updated                                         //\n// message from being sent).                                                                                          //\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({                                                           // 160\n  factName: \"invalidation-crossbar-listeners\"                                                                         // 161\n});                                                                                                                   //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/server_convenience.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nif (process.env.DDP_DEFAULT_CONNECTION_URL) {                                                                         // 1\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL = process.env.DDP_DEFAULT_CONNECTION_URL;                      // 2\n}                                                                                                                     //\n                                                                                                                      //\nMeteor.server = new Server();                                                                                         // 6\n                                                                                                                      //\nMeteor.refresh = function (notification) {                                                                            // 8\n  DDPServer._InvalidationCrossbar.fire(notification);                                                                 // 9\n};                                                                                                                    //\n                                                                                                                      //\n// Proxy the public methods of Meteor.server so they can                                                              //\n// be called directly on Meteor.                                                                                      //\n_.each(['publish', 'methods', 'call', 'apply', 'onConnection'], function (name) {                                     // 14\n  Meteor[name] = _.bind(Meteor.server[name], Meteor.server);                                                          // 16\n});                                                                                                                   //\n                                                                                                                      //\n// Meteor.server used to be called Meteor.default_server. Provide                                                     //\n// backcompat as a courtesy even though it was never documented.                                                      //\n// XXX COMPAT WITH 0.6.4                                                                                              //\nMeteor.default_server = Meteor.server;                                                                                // 22\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['ddp-server'] = {\n  DDPServer: DDPServer\n};\n\n})();\n","servePath":"/packages/ddp-server.js","sourceMap":{"version":3,"sources":["/stream_server.js","/livedata_server.js","/writefence.js","/crossbar.js","/server_convenience.js"],"names":[],"mappings":"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","file":"/packages/ddp-server.js","sourcesContent":["var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION\n        ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(\n      websocketCompressionConfig\n    ));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function() {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({server_id: \"0\"}));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    _.each(self.all_sockets(), function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return _.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function() {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    _.each(['request', 'upgrade'], function(event) {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function(request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        _.each(oldHttpServerListeners, function(oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});\n","DDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported.)\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = {}; // set of subscriptionHandle\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\n};\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    _.each(self.dataByKey, function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey[key];\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (_.isEmpty(precedenceList)) {\n      delete self.dataByKey[key];\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!_.has(self.dataByKey, key)) {\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,\n                              value: value}];\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey[key];\n    var elt;\n    if (!isAdd) {\n      elt = _.find(precedenceList, function (precedence) {\n        return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = {};\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\n_.extend(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return _.isEmpty(self.documents);\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffObjects(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents[id];\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents[id] = docView;\n    }\n    docView.existsIn[subscriptionHandle] = true;\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents[id];\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents[id];\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    delete docView.existsIn[subscriptionHandle];\n    if (_.isEmpty(docView.existsIn)) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      delete self.documents[id];\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      _.each(docView.dataByKey, function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // set to null when the session is destroyed. multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = {};\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = {};\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // when we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  socket.send(DDPCommon.stringifyDDP({msg: 'connected',\n                            session: self.id}));\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\n_.extend(Session.prototype, {\n\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  sendAdded: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"added\", collection: collectionName, id: id, fields: fields});\n  },\n\n  sendChanged: function (collectionName, id, fields) {\n    var self = this;\n    if (_.isEmpty(fields))\n      return;\n\n    if (self._isSending) {\n      self.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id: id,\n        fields: fields\n      });\n    }\n  },\n\n  sendRemoved: function (collectionName, id) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"removed\", collection: collectionName, id: id});\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    if (_.has(self.collectionViews, collectionName)) {\n      return self.collectionViews[collectionName];\n    }\n    var ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n    self.collectionViews[collectionName] = ret;\n    return ret;\n  },\n\n  added: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.added(subscriptionHandle, id, fields);\n  },\n\n  removed: function (subscriptionHandle, collectionName, id) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.removed(subscriptionHandle, id);\n    if (view.isEmpty()) {\n      delete self.collectionViews[collectionName];\n    }\n  },\n\n  changed: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.changed(subscriptionHandle, id, fields);\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = {};\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now.)\n  // It should be a JSON object (it will be stringified.)\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. (But as a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.)\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield.) Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other.)\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        if (_.has(self.protocol_handlers, msg.msg))\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\n        else\n          self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: function (msg) {\n      var self = this;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, \"Subscription not found\")});\n        return;\n      }\n\n      if (_.has(self._namedSubs, msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: function (msg, unblock) {\n      var self = this;\n\n      // reject malformed messages\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated', methods: [msg.id]});\n      });\n\n      // find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, \"Method not found\")});\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function(userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n\n      promise.then((result) => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, (exception) => {\n        finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    _.each(self._namedSubs, f);\n    _.each(self._universalSubs, f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffObjects(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        _.each(rightValue.documents, function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        _.each(leftValue.documents, function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session; they will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription.)\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = {};\n    self.userId = userId;\n\n    // Save the old named subs, and reset to having no subscriptions.\n    var oldNamedSubs = self._namedSubs;\n    self._namedSubs = {};\n    self._universalSubs = [];\n\n    _.each(oldNamedSubs, function (sub, subscriptionId) {\n      self._namedSubs[subscriptionId] = sub._recreate();\n      // nb: if the handler throws or calls this.error(), it will in fact\n      // immediately send its 'nosub'. This is OK, though.\n      self._namedSubs[subscriptionId]._runHandler();\n    });\n\n    // Allow newly-created universal subs to be started on our connection in\n    // parallel with the ones we're spinning up here, and spin up universal\n    // subs.\n    self._dontStartNewUniversalSubs = false;\n    self.startUniversalSubs();\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n    if (subId)\n      self._namedSubs[subId] = sub;\n    else\n      self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n\n  // tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n\n    if (subId && self._namedSubs[subId]) {\n      subName = self._namedSubs[subId]._name;\n      self._namedSubs[subId]._removeAllDocuments();\n      self._namedSubs[subId]._deactivate();\n      delete self._namedSubs[subId];\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    _.each(self._namedSubs, function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = {};\n\n    _.each(self._universalSubs, function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (! _.isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // my subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // has _deactivate been called?\n  self._deactivated = false;\n\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // the set of (collection, documentid) that this subscription has\n  // an opinion about\n  self._documents = {};\n\n  // remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a ddp consumer that isn't minimongo\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\n_.extend(Subscription.prototype, {\n  _runHandler: function () {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    var self = this;\n    try {\n      var res = maybeAuditArgumentChecks(\n        self._handler, self, EJSON.clone(self._params),\n        // It's OK that this would look weird for universal subscriptions,\n        // because they have no arguments so there can never be an\n        // audit-argument-checks failure.\n        \"publisher '\" + self._name + \"'\");\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated())\n      return;\n\n    self._publishHandlerResult(res);\n  },\n\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // check all the elements are cursors\n      if (! _.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      };\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      _.each(self._documents, function(collectionDocs, collectionName) {\n        // Iterate over _.keys instead of the dictionary itself, since we'll be\n        // mutating it.\n        _.each(_.keys(collectionDocs), function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    Meteor._ensure(self._documents, collectionName)[id] = true;\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed: function (collectionName, id) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    // We don't bother to delete sets of things in a collection if the\n    // collection is empty.  It could break _removeAllDocuments.\n    delete self._documents[collectionName][id];\n    self._session.removed(self._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = _.defaults(options || {}, {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true\n  });\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self.sessions = {}; // map from id to session\n\n  self.stream_server = new StreamServer;\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg,\n                      e.message, e.stack);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\n_.extend(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          _.isArray(msg.support) &&\n          _.all(msg.support, _.isString) &&\n          _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish.)\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @locus Server\n   * @param {String} name Name of the record set.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    options = options || {};\n\n    if (name && name in self.publish_handlers) {\n      Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n      return;\n    }\n\n    if (Package.autopublish && !options.is_auto) {\n      // They have autopublish on, yet they're trying to manually\n      // picking stuff to publish. They probably should turn off\n      // autopublish. (This check isn't perfect -- if you create a\n      // publish before you turn on autopublish, it won't catch\n      // it. But this will definitely handle the simple case where\n      // you've added the autopublish package to your app, and are\n      // calling publish from your app code.)\n      if (!self.warned_about_autopublish) {\n        self.warned_about_autopublish = true;\n        Meteor._debug(\n\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n\"** you still have autopublish turned on. Because autopublish is still\\n\" +\n\"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n\"** will still be sent to all clients.\\n\" +\n\"**\\n\" +\n\"** Turn off autopublish by removing the autopublish package:\\n\" +\n\"**\\n\" +\n\"**   $ meteor remove autopublish\\n\" +\n\"**\\n\" +\n\"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n\"** for each collection that you want clients to see.\\n\");\n      }\n    }\n\n    if (name)\n      self.publish_handlers[name] = handler;\n    else {\n      self.universal_publish_handlers.push(handler);\n      // Spin up the new publisher on any existing session too. Run each\n      // session's subscription in a new Fiber, so that there's no change for\n      // self.sessions to change while we're running this loop.\n      _.each(self.sessions, function (session) {\n        if (!session._dontStartNewUniversalSubs) {\n          Fiber(function() {\n            session._startSubscription(handler);\n          }).run();\n        }\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    if (self.sessions[session.id]) {\n      delete self.sessions[session.id];\n    }\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name /*, arguments */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  // @param callback {Optional Function}\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback)\n      // It's not really necessary to do this, since we immediately\n      // run the callback in this fiber before returning, but we do it\n      // anyway for regularity.\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n\n    // Run the handler\n    var handler = self.method_handlers[name];\n    var exception;\n    if (!handler) {\n      exception = new Meteor.Error(404, \"Method not found\");\n    } else {\n      // If this is a method call from within another method, get the\n      // user state from the outer method, otherwise don't allow\n      // setUserId to be called\n      var userId = null;\n      var setUserId = function() {\n        throw new Error(\"Can't call setUserId on a server initiated method call\");\n      };\n      var connection = null;\n      var currentInvocation = DDP._CurrentInvocation.get();\n      if (currentInvocation) {\n        userId = currentInvocation.userId;\n        setUserId = function(userId) {\n          currentInvocation.setUserId(userId);\n        };\n        connection = currentInvocation.connection;\n      }\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: userId,\n        setUserId: setUserId,\n        connection: connection,\n        randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)\n      });\n      try {\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {\n          return maybeAuditArgumentChecks(\n            handler, invocation, EJSON.clone(args), \"internal call to '\" +\n              name + \"'\");\n        });\n        result = EJSON.clone(result);\n      } catch (e) {\n        exception = e;\n      }\n    }\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case.)\n    if (callback) {\n      callback(exception, result);\n      return undefined;\n    }\n    if (exception)\n      throw exception;\n    return result;\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions[sessionId];\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception || exception instanceof Meteor.Error)\n    return exception;\n\n  // tests can set the 'expected' flag on an exception so it won't go to the\n  // server log\n  if (!exception.expected) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError instanceof Meteor.Error)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"is not a Meteor.Error; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n","var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n","// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (! _.has(msg, 'collection')) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! _.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n    }\n    self.listenersByCollection[collection][id] = record;\n\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        if (_.isEmpty(self.listenersByCollection[collection])) {\n          delete self.listenersByCollection[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (! _.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    _.each(callbackIds, function (id) {\n      if (_.has(listenersForCollection, id)) {\n        listenersForCollection[id].callback(notification);\n      }\n    });\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) ||\n        EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});\n","if (process.env.DDP_DEFAULT_CONNECTION_URL) {\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =\n    process.env.DDP_DEFAULT_CONNECTION_URL;\n}\n\nMeteor.server = new Server;\n\nMeteor.refresh = function (notification) {\n  DDPServer._InvalidationCrossbar.fire(notification);\n};\n\n// Proxy the public methods of Meteor.server so they can\n// be called directly on Meteor.\n_.each(['publish', 'methods', 'call', 'apply', 'onConnection'],\n       function (name) {\n         Meteor[name] = _.bind(Meteor.server[name], Meteor.server);\n       });\n\n// Meteor.server used to be called Meteor.default_server. Provide\n// backcompat as a courtesy even though it was never documented.\n// XXX COMPAT WITH 0.6.4\nMeteor.default_server = Meteor.server;\n"]}}]