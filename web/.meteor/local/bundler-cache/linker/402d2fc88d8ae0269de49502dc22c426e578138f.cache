[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar IdMap;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////\n//                                                                            //\n// packages/id-map/id-map.js                                                  //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n                                                                              //\nIdMap = function (idStringify, idParse) {                                     // 1\n  var self = this;                                                            // 2\n  self._map = {};                                                             // 3\n  self._idStringify = idStringify || JSON.stringify;                          // 4\n  self._idParse = idParse || JSON.parse;                                      // 5\n};                                                                            // 6\n                                                                              // 7\n// Some of these methods are designed to match methods on OrderedDict, since  // 8\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\n// (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\n// set of methods that overlap between the two.)                              // 11\n                                                                              // 12\n_.extend(IdMap.prototype, {                                                   // 13\n  get: function (id) {                                                        // 14\n    var self = this;                                                          // 15\n    var key = self._idStringify(id);                                          // 16\n    return self._map[key];                                                    // 17\n  },                                                                          // 18\n  set: function (id, value) {                                                 // 19\n    var self = this;                                                          // 20\n    var key = self._idStringify(id);                                          // 21\n    self._map[key] = value;                                                   // 22\n  },                                                                          // 23\n  remove: function (id) {                                                     // 24\n    var self = this;                                                          // 25\n    var key = self._idStringify(id);                                          // 26\n    delete self._map[key];                                                    // 27\n  },                                                                          // 28\n  has: function (id) {                                                        // 29\n    var self = this;                                                          // 30\n    var key = self._idStringify(id);                                          // 31\n    return _.has(self._map, key);                                             // 32\n  },                                                                          // 33\n  empty: function () {                                                        // 34\n    var self = this;                                                          // 35\n    return _.isEmpty(self._map);                                              // 36\n  },                                                                          // 37\n  clear: function () {                                                        // 38\n    var self = this;                                                          // 39\n    self._map = {};                                                           // 40\n  },                                                                          // 41\n  // Iterates over the items in the map. Return `false` to break the loop.    // 42\n  forEach: function (iterator) {                                              // 43\n    var self = this;                                                          // 44\n    // don't use _.each, because we can't break out of it.                    // 45\n    var keys = _.keys(self._map);                                             // 46\n    for (var i = 0; i < keys.length; i++) {                                   // 47\n      var breakIfFalse = iterator.call(null, self._map[keys[i]],              // 48\n                                       self._idParse(keys[i]));               // 49\n      if (breakIfFalse === false)                                             // 50\n        return;                                                               // 51\n    }                                                                         // 52\n  },                                                                          // 53\n  size: function () {                                                         // 54\n    var self = this;                                                          // 55\n    return _.size(self._map);                                                 // 56\n  },                                                                          // 57\n  setDefault: function (id, def) {                                            // 58\n    var self = this;                                                          // 59\n    var key = self._idStringify(id);                                          // 60\n    if (_.has(self._map, key))                                                // 61\n      return self._map[key];                                                  // 62\n    self._map[key] = def;                                                     // 63\n    return def;                                                               // 64\n  },                                                                          // 65\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\n  // IDs (ie, that nobody is going to mutate an ObjectId).                    // 67\n  clone: function () {                                                        // 68\n    var self = this;                                                          // 69\n    var clone = new IdMap(self._idStringify, self._idParse);                  // 70\n    self.forEach(function (value, id) {                                       // 71\n      clone.set(id, EJSON.clone(value));                                      // 72\n    });                                                                       // 73\n    return clone;                                                             // 74\n  }                                                                           // 75\n});                                                                           // 76\n                                                                              // 77\n                                                                              // 78\n////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['id-map'] = {\n  IdMap: IdMap\n};\n\n})();\n","servePath":"/packages/id-map.js","sourceMap":{"version":3,"sources":["/packages/id-map/id-map.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mF","file":"/packages/id-map.js","sourcesContent":["IdMap = function (idStringify, idParse) {\n  var self = this;\n  self._map = {};\n  self._idStringify = idStringify || JSON.stringify;\n  self._idParse = idParse || JSON.parse;\n};\n\n// Some of these methods are designed to match methods on OrderedDict, since\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\n// (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\n// set of methods that overlap between the two.)\n\n_.extend(IdMap.prototype, {\n  get: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return self._map[key];\n  },\n  set: function (id, value) {\n    var self = this;\n    var key = self._idStringify(id);\n    self._map[key] = value;\n  },\n  remove: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    delete self._map[key];\n  },\n  has: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return _.has(self._map, key);\n  },\n  empty: function () {\n    var self = this;\n    return _.isEmpty(self._map);\n  },\n  clear: function () {\n    var self = this;\n    self._map = {};\n  },\n  // Iterates over the items in the map. Return `false` to break the loop.\n  forEach: function (iterator) {\n    var self = this;\n    // don't use _.each, because we can't break out of it.\n    var keys = _.keys(self._map);\n    for (var i = 0; i < keys.length; i++) {\n      var breakIfFalse = iterator.call(null, self._map[keys[i]],\n                                       self._idParse(keys[i]));\n      if (breakIfFalse === false)\n        return;\n    }\n  },\n  size: function () {\n    var self = this;\n    return _.size(self._map);\n  },\n  setDefault: function (id, def) {\n    var self = this;\n    var key = self._idStringify(id);\n    if (_.has(self._map, key))\n      return self._map[key];\n    self._map[key] = def;\n    return def;\n  },\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\n  // IDs (ie, that nobody is going to mutate an ObjectId).\n  clone: function () {\n    var self = this;\n    var clone = new IdMap(self._idStringify, self._idParse);\n    self.forEach(function (value, id) {\n      clone.set(id, EJSON.clone(value));\n    });\n    return clone;\n  }\n});\n\n"]}}]