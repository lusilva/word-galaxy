[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\n\n/* Package-scope variables */\nvar module, GeoJSON;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/geojson-utils/pre.js                                                                           //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// Define an object named exports. This will cause geojson-utils.js to put `gju`                           // 1\n// as a field on it, instead of in the global namespace.  See also post.js.                                // 2\nmodule = {exports:{}};                                                                                     // 3\n                                                                                                           // 4\n                                                                                                           // 5\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/geojson-utils/geojson-utils.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n(function () {                                                                                             // 1\n  var gju = {};                                                                                            // 2\n                                                                                                           // 3\n  // Export the geojson object for **CommonJS**                                                            // 4\n  if (typeof module !== 'undefined' && module.exports) {                                                   // 5\n    module.exports = gju;                                                                                  // 6\n  }                                                                                                        // 7\n                                                                                                           // 8\n  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js                           // 9\n  gju.lineStringsIntersect = function (l1, l2) {                                                           // 10\n    var intersects = [];                                                                                   // 11\n    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {                                                 // 12\n      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {                                               // 13\n        var a1 = {                                                                                         // 14\n          x: l1.coordinates[i][1],                                                                         // 15\n          y: l1.coordinates[i][0]                                                                          // 16\n        },                                                                                                 // 17\n          a2 = {                                                                                           // 18\n            x: l1.coordinates[i + 1][1],                                                                   // 19\n            y: l1.coordinates[i + 1][0]                                                                    // 20\n          },                                                                                               // 21\n          b1 = {                                                                                           // 22\n            x: l2.coordinates[j][1],                                                                       // 23\n            y: l2.coordinates[j][0]                                                                        // 24\n          },                                                                                               // 25\n          b2 = {                                                                                           // 26\n            x: l2.coordinates[j + 1][1],                                                                   // 27\n            y: l2.coordinates[j + 1][0]                                                                    // 28\n          },                                                                                               // 29\n          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),                            // 30\n          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),                            // 31\n          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);                             // 32\n        if (u_b != 0) {                                                                                    // 33\n          var ua = ua_t / u_b,                                                                             // 34\n            ub = ub_t / u_b;                                                                               // 35\n          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {                                                  // 36\n            intersects.push({                                                                              // 37\n              'type': 'Point',                                                                             // 38\n              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]                        // 39\n            });                                                                                            // 40\n          }                                                                                                // 41\n        }                                                                                                  // 42\n      }                                                                                                    // 43\n    }                                                                                                      // 44\n    if (intersects.length == 0) intersects = false;                                                        // 45\n    return intersects;                                                                                     // 46\n  }                                                                                                        // 47\n                                                                                                           // 48\n  // Bounding Box                                                                                          // 49\n                                                                                                           // 50\n  function boundingBoxAroundPolyCoords (coords) {                                                          // 51\n    var xAll = [], yAll = []                                                                               // 52\n                                                                                                           // 53\n    for (var i = 0; i < coords[0].length; i++) {                                                           // 54\n      xAll.push(coords[0][i][1])                                                                           // 55\n      yAll.push(coords[0][i][0])                                                                           // 56\n    }                                                                                                      // 57\n                                                                                                           // 58\n    xAll = xAll.sort(function (a,b) { return a - b })                                                      // 59\n    yAll = yAll.sort(function (a,b) { return a - b })                                                      // 60\n                                                                                                           // 61\n    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]                          // 62\n  }                                                                                                        // 63\n                                                                                                           // 64\n  gju.pointInBoundingBox = function (point, bounds) {                                                      // 65\n    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) \n  }                                                                                                        // 67\n                                                                                                           // 68\n  // Point in Polygon                                                                                      // 69\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices           // 70\n                                                                                                           // 71\n  function pnpoly (x,y,coords) {                                                                           // 72\n    var vert = [ [0,0] ]                                                                                   // 73\n                                                                                                           // 74\n    for (var i = 0; i < coords.length; i++) {                                                              // 75\n      for (var j = 0; j < coords[i].length; j++) {                                                         // 76\n        vert.push(coords[i][j])                                                                            // 77\n      }                                                                                                    // 78\n      vert.push([0,0])                                                                                     // 79\n    }                                                                                                      // 80\n                                                                                                           // 81\n    var inside = false                                                                                     // 82\n    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {                                       // 83\n      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside\n    }                                                                                                      // 85\n                                                                                                           // 86\n    return inside                                                                                          // 87\n  }                                                                                                        // 88\n                                                                                                           // 89\n  gju.pointInPolygon = function (p, poly) {                                                                // 90\n    var coords = (poly.type == \"Polygon\") ? [ poly.coordinates ] : poly.coordinates                        // 91\n                                                                                                           // 92\n    var insideBox = false                                                                                  // 93\n    for (var i = 0; i < coords.length; i++) {                                                              // 94\n      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true              // 95\n    }                                                                                                      // 96\n    if (!insideBox) return false                                                                           // 97\n                                                                                                           // 98\n    var insidePoly = false                                                                                 // 99\n    for (var i = 0; i < coords.length; i++) {                                                              // 100\n      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true                         // 101\n    }                                                                                                      // 102\n                                                                                                           // 103\n    return insidePoly                                                                                      // 104\n  }                                                                                                        // 105\n                                                                                                           // 106\n  gju.numberToRadius = function (number) {                                                                 // 107\n    return number * Math.PI / 180;                                                                         // 108\n  }                                                                                                        // 109\n                                                                                                           // 110\n  gju.numberToDegree = function (number) {                                                                 // 111\n    return number * 180 / Math.PI;                                                                         // 112\n  }                                                                                                        // 113\n                                                                                                           // 114\n  // written with help from @tautologe                                                                     // 115\n  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {                                         // 116\n    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],                                 // 117\n      dist = (radiusInMeters / 1000) / 6371,                                                               // 118\n      // convert meters to radiant                                                                         // 119\n      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],                          // 120\n      steps = steps || 15,                                                                                 // 121\n      // 15 sided circle                                                                                   // 122\n      poly = [[center[0], center[1]]];                                                                     // 123\n    for (var i = 0; i < steps; i++) {                                                                      // 124\n      var brng = 2 * Math.PI * i / steps;                                                                  // 125\n      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)                                          // 126\n              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));                                 // 127\n      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),        // 128\n                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));        // 129\n      poly[i] = [];                                                                                        // 130\n      poly[i][1] = gju.numberToDegree(lat);                                                                // 131\n      poly[i][0] = gju.numberToDegree(lng);                                                                // 132\n    }                                                                                                      // 133\n    return {                                                                                               // 134\n      \"type\": \"Polygon\",                                                                                   // 135\n      \"coordinates\": [poly]                                                                                // 136\n    };                                                                                                     // 137\n  }                                                                                                        // 138\n                                                                                                           // 139\n  // assumes rectangle starts at lower left point                                                          // 140\n  gju.rectangleCentroid = function (rectangle) {                                                           // 141\n    var bbox = rectangle.coordinates[0];                                                                   // 142\n    var xmin = bbox[0][0],                                                                                 // 143\n      ymin = bbox[0][1],                                                                                   // 144\n      xmax = bbox[2][0],                                                                                   // 145\n      ymax = bbox[2][1];                                                                                   // 146\n    var xwidth = xmax - xmin;                                                                              // 147\n    var ywidth = ymax - ymin;                                                                              // 148\n    return {                                                                                               // 149\n      'type': 'Point',                                                                                     // 150\n      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]                                                // 151\n    };                                                                                                     // 152\n  }                                                                                                        // 153\n                                                                                                           // 154\n  // from http://www.movable-type.co.uk/scripts/latlong.html                                               // 155\n  gju.pointDistance = function (pt1, pt2) {                                                                // 156\n    var lon1 = pt1.coordinates[0],                                                                         // 157\n      lat1 = pt1.coordinates[1],                                                                           // 158\n      lon2 = pt2.coordinates[0],                                                                           // 159\n      lat2 = pt2.coordinates[1],                                                                           // 160\n      dLat = gju.numberToRadius(lat2 - lat1),                                                              // 161\n      dLon = gju.numberToRadius(lon2 - lon1),                                                              // 162\n      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))                             // 163\n        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),                            // 164\n      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                                                  // 165\n    // Earth radius is 6371 km                                                                             // 166\n    return (6371 * c) * 1000; // returns meters                                                            // 167\n  },                                                                                                       // 168\n                                                                                                           // 169\n  // checks if geometry lies entirely within a circle                                                      // 170\n  // works with Point, LineString, Polygon                                                                 // 171\n  gju.geometryWithinRadius = function (geometry, center, radius) {                                         // 172\n    if (geometry.type == 'Point') {                                                                        // 173\n      return gju.pointDistance(geometry, center) <= radius;                                                // 174\n    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {                              // 175\n      var point = {};                                                                                      // 176\n      var coordinates;                                                                                     // 177\n      if (geometry.type == 'Polygon') {                                                                    // 178\n        // it's enough to check the exterior ring of the Polygon                                           // 179\n        coordinates = geometry.coordinates[0];                                                             // 180\n      } else {                                                                                             // 181\n        coordinates = geometry.coordinates;                                                                // 182\n      }                                                                                                    // 183\n      for (var i in coordinates) {                                                                         // 184\n        point.coordinates = coordinates[i];                                                                // 185\n        if (gju.pointDistance(point, center) > radius) {                                                   // 186\n          return false;                                                                                    // 187\n        }                                                                                                  // 188\n      }                                                                                                    // 189\n    }                                                                                                      // 190\n    return true;                                                                                           // 191\n  }                                                                                                        // 192\n                                                                                                           // 193\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 194\n  gju.area = function (polygon) {                                                                          // 195\n    var area = 0;                                                                                          // 196\n    // TODO: polygon holes at coordinates[1]                                                               // 197\n    var points = polygon.coordinates[0];                                                                   // 198\n    var j = points.length - 1;                                                                             // 199\n    var p1, p2;                                                                                            // 200\n                                                                                                           // 201\n    for (var i = 0; i < points.length; j = i++) {                                                          // 202\n      var p1 = {                                                                                           // 203\n        x: points[i][1],                                                                                   // 204\n        y: points[i][0]                                                                                    // 205\n      };                                                                                                   // 206\n      var p2 = {                                                                                           // 207\n        x: points[j][1],                                                                                   // 208\n        y: points[j][0]                                                                                    // 209\n      };                                                                                                   // 210\n      area += p1.x * p2.y;                                                                                 // 211\n      area -= p1.y * p2.x;                                                                                 // 212\n    }                                                                                                      // 213\n                                                                                                           // 214\n    area /= 2;                                                                                             // 215\n    return area;                                                                                           // 216\n  },                                                                                                       // 217\n                                                                                                           // 218\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 219\n  gju.centroid = function (polygon) {                                                                      // 220\n    var f, x = 0,                                                                                          // 221\n      y = 0;                                                                                               // 222\n    // TODO: polygon holes at coordinates[1]                                                               // 223\n    var points = polygon.coordinates[0];                                                                   // 224\n    var j = points.length - 1;                                                                             // 225\n    var p1, p2;                                                                                            // 226\n                                                                                                           // 227\n    for (var i = 0; i < points.length; j = i++) {                                                          // 228\n      var p1 = {                                                                                           // 229\n        x: points[i][1],                                                                                   // 230\n        y: points[i][0]                                                                                    // 231\n      };                                                                                                   // 232\n      var p2 = {                                                                                           // 233\n        x: points[j][1],                                                                                   // 234\n        y: points[j][0]                                                                                    // 235\n      };                                                                                                   // 236\n      f = p1.x * p2.y - p2.x * p1.y;                                                                       // 237\n      x += (p1.x + p2.x) * f;                                                                              // 238\n      y += (p1.y + p2.y) * f;                                                                              // 239\n    }                                                                                                      // 240\n                                                                                                           // 241\n    f = gju.area(polygon) * 6;                                                                             // 242\n    return {                                                                                               // 243\n      'type': 'Point',                                                                                     // 244\n      'coordinates': [y / f, x / f]                                                                        // 245\n    };                                                                                                     // 246\n  },                                                                                                       // 247\n                                                                                                           // 248\n  gju.simplify = function (source, kink) { /* source[] array of geojson points */                          // 249\n    /* kink\tin metres, kinks above this depth kept  */                                                     // 250\n    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\n    kink = kink || 20;                                                                                     // 252\n    source = source.map(function (o) {                                                                     // 253\n      return {                                                                                             // 254\n        lng: o.coordinates[0],                                                                             // 255\n        lat: o.coordinates[1]                                                                              // 256\n      }                                                                                                    // 257\n    });                                                                                                    // 258\n                                                                                                           // 259\n    var n_source, n_stack, n_dest, start, end, i, sig;                                                     // 260\n    var dev_sqr, max_dev_sqr, band_sqr;                                                                    // 261\n    var x12, y12, d12, x13, y13, d13, x23, y23, d23;                                                       // 262\n    var F = (Math.PI / 180.0) * 0.5;                                                                       // 263\n    var index = new Array(); /* aray of indexes of source points to include in the reduced line */         // 264\n    var sig_start = new Array(); /* indices of start & end of working section */                           // 265\n    var sig_end = new Array();                                                                             // 266\n                                                                                                           // 267\n    /* check for simple cases */                                                                           // 268\n                                                                                                           // 269\n    if (source.length < 3) return (source); /* one or two points */                                        // 270\n                                                                                                           // 271\n    /* more complex case. initialize stack */                                                              // 272\n                                                                                                           // 273\n    n_source = source.length;                                                                              // 274\n    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */                            // 275\n    band_sqr *= band_sqr;                                                                                  // 276\n    n_dest = 0;                                                                                            // 277\n    sig_start[0] = 0;                                                                                      // 278\n    sig_end[0] = n_source - 1;                                                                             // 279\n    n_stack = 1;                                                                                           // 280\n                                                                                                           // 281\n    /* while the stack is not empty  ... */                                                                // 282\n    while (n_stack > 0) {                                                                                  // 283\n                                                                                                           // 284\n      /* ... pop the top-most entries off the stacks */                                                    // 285\n                                                                                                           // 286\n      start = sig_start[n_stack - 1];                                                                      // 287\n      end = sig_end[n_stack - 1];                                                                          // 288\n      n_stack--;                                                                                           // 289\n                                                                                                           // 290\n      if ((end - start) > 1) { /* any intermediate points ? */                                             // 291\n                                                                                                           // 292\n        /* ... yes, so find most deviant intermediate point to                                             // 293\n        either side of line joining start & end points */                                                  // 294\n                                                                                                           // 295\n        x12 = (source[end].lng() - source[start].lng());                                                   // 296\n        y12 = (source[end].lat() - source[start].lat());                                                   // 297\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);                                            // 298\n        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */    // 299\n        d12 = (x12 * x12) + (y12 * y12);                                                                   // 300\n                                                                                                           // 301\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {                               // 302\n                                                                                                           // 303\n          x13 = source[i].lng() - source[start].lng();                                                     // 304\n          y13 = source[i].lat() - source[start].lat();                                                     // 305\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);                                          // 306\n          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));                                    // 307\n          d13 = (x13 * x13) + (y13 * y13);                                                                 // 308\n                                                                                                           // 309\n          x23 = source[i].lng() - source[end].lng();                                                       // 310\n          y23 = source[i].lat() - source[end].lat();                                                       // 311\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);                                          // 312\n          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));                                      // 313\n          d23 = (x23 * x23) + (y23 * y23);                                                                 // 314\n                                                                                                           // 315\n          if (d13 >= (d12 + d23)) dev_sqr = d23;                                                           // 316\n          else if (d23 >= (d12 + d13)) dev_sqr = d13;                                                      // 317\n          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle        // 318\n          if (dev_sqr > max_dev_sqr) {                                                                     // 319\n            sig = i;                                                                                       // 320\n            max_dev_sqr = dev_sqr;                                                                         // 321\n          }                                                                                                // 322\n        }                                                                                                  // 323\n                                                                                                           // 324\n        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */                           // 325\n          /* ... no, so transfer current start point */                                                    // 326\n          index[n_dest] = start;                                                                           // 327\n          n_dest++;                                                                                        // 328\n        } else { /* ... yes, so push two sub-sections on stack for further processing */                   // 329\n          n_stack++;                                                                                       // 330\n          sig_start[n_stack - 1] = sig;                                                                    // 331\n          sig_end[n_stack - 1] = end;                                                                      // 332\n          n_stack++;                                                                                       // 333\n          sig_start[n_stack - 1] = start;                                                                  // 334\n          sig_end[n_stack - 1] = sig;                                                                      // 335\n        }                                                                                                  // 336\n      } else { /* ... no intermediate points, so transfer current start point */                           // 337\n        index[n_dest] = start;                                                                             // 338\n        n_dest++;                                                                                          // 339\n      }                                                                                                    // 340\n    }                                                                                                      // 341\n                                                                                                           // 342\n    /* transfer last point */                                                                              // 343\n    index[n_dest] = n_source - 1;                                                                          // 344\n    n_dest++;                                                                                              // 345\n                                                                                                           // 346\n    /* make return array */                                                                                // 347\n    var r = new Array();                                                                                   // 348\n    for (var i = 0; i < n_dest; i++)                                                                       // 349\n      r.push(source[index[i]]);                                                                            // 350\n                                                                                                           // 351\n    return r.map(function (o) {                                                                            // 352\n      return {                                                                                             // 353\n        type: \"Point\",                                                                                     // 354\n        coordinates: [o.lng, o.lat]                                                                        // 355\n      }                                                                                                    // 356\n    });                                                                                                    // 357\n  }                                                                                                        // 358\n                                                                                                           // 359\n  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint                                          // 360\n  gju.destinationPoint = function (pt, brng, dist) {                                                       // 361\n    dist = dist/6371;  // convert dist to angular distance in radians                                      // 362\n    brng = gju.numberToRadius(brng);                                                                       // 363\n                                                                                                           // 364\n    var lat1 = gju.numberToRadius(pt.coordinates[0]);                                                      // 365\n    var lon1 = gju.numberToRadius(pt.coordinates[1]);                                                      // 366\n                                                                                                           // 367\n    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +                                                  // 368\n                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );                                  // 369\n    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),                             // 370\n                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));                            // 371\n    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º                          // 372\n                                                                                                           // 373\n    return {                                                                                               // 374\n      'type': 'Point',                                                                                     // 375\n      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]                                  // 376\n    };                                                                                                     // 377\n  };                                                                                                       // 378\n                                                                                                           // 379\n})();                                                                                                      // 380\n                                                                                                           // 381\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/geojson-utils/post.js                                                                          //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// This exports object was created in pre.js.  Now copy the `exports` object                               // 1\n// from it into the package-scope variable `GeoJSON`, which will get exported.                             // 2\nGeoJSON = module.exports;                                                                                  // 3\n                                                                                                           // 4\n                                                                                                           // 5\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['geojson-utils'] = {\n  GeoJSON: GeoJSON\n};\n\n})();\n","servePath":"/packages/geojson-utils.js","sourceMap":{"version":3,"sources":["/packages/geojson-utils/pre.js","/packages/geojson-utils/geojson-utils.js","/packages/geojson-utils/post.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,+G;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;;;;;;;;AC5XA;AACA;AACA;AACA;AACA,+G","file":"/packages/geojson-utils.js","sourcesContent":["// Define an object named exports. This will cause geojson-utils.js to put `gju`\n// as a field on it, instead of in the global namespace.  See also post.js.\nmodule = {exports:{}};\n\n","(function () {\n  var gju = {};\n\n  // Export the geojson object for **CommonJS**\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = gju;\n  }\n\n  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js\n  gju.lineStringsIntersect = function (l1, l2) {\n    var intersects = [];\n    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {\n      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {\n        var a1 = {\n          x: l1.coordinates[i][1],\n          y: l1.coordinates[i][0]\n        },\n          a2 = {\n            x: l1.coordinates[i + 1][1],\n            y: l1.coordinates[i + 1][0]\n          },\n          b1 = {\n            x: l2.coordinates[j][1],\n            y: l2.coordinates[j][0]\n          },\n          b2 = {\n            x: l2.coordinates[j + 1][1],\n            y: l2.coordinates[j + 1][0]\n          },\n          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\n          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\n          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (u_b != 0) {\n          var ua = ua_t / u_b,\n            ub = ub_t / u_b;\n          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n            intersects.push({\n              'type': 'Point',\n              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]\n            });\n          }\n        }\n      }\n    }\n    if (intersects.length == 0) intersects = false;\n    return intersects;\n  }\n\n  // Bounding Box\n\n  function boundingBoxAroundPolyCoords (coords) {\n    var xAll = [], yAll = []\n\n    for (var i = 0; i < coords[0].length; i++) {\n      xAll.push(coords[0][i][1])\n      yAll.push(coords[0][i][0])\n    }\n\n    xAll = xAll.sort(function (a,b) { return a - b })\n    yAll = yAll.sort(function (a,b) { return a - b })\n\n    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]\n  }\n\n  gju.pointInBoundingBox = function (point, bounds) {\n    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) \n  }\n\n  // Point in Polygon\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices\n\n  function pnpoly (x,y,coords) {\n    var vert = [ [0,0] ]\n\n    for (var i = 0; i < coords.length; i++) {\n      for (var j = 0; j < coords[i].length; j++) {\n        vert.push(coords[i][j])\n      }\n      vert.push([0,0])\n    }\n\n    var inside = false\n    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {\n      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside\n    }\n\n    return inside\n  }\n\n  gju.pointInPolygon = function (p, poly) {\n    var coords = (poly.type == \"Polygon\") ? [ poly.coordinates ] : poly.coordinates\n\n    var insideBox = false\n    for (var i = 0; i < coords.length; i++) {\n      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true\n    }\n    if (!insideBox) return false\n\n    var insidePoly = false\n    for (var i = 0; i < coords.length; i++) {\n      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true\n    }\n\n    return insidePoly\n  }\n\n  gju.numberToRadius = function (number) {\n    return number * Math.PI / 180;\n  }\n\n  gju.numberToDegree = function (number) {\n    return number * 180 / Math.PI;\n  }\n\n  // written with help from @tautologe\n  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {\n    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],\n      dist = (radiusInMeters / 1000) / 6371,\n      // convert meters to radiant\n      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],\n      steps = steps || 15,\n      // 15 sided circle\n      poly = [[center[0], center[1]]];\n    for (var i = 0; i < steps; i++) {\n      var brng = 2 * Math.PI * i / steps;\n      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)\n              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));\n      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),\n                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));\n      poly[i] = [];\n      poly[i][1] = gju.numberToDegree(lat);\n      poly[i][0] = gju.numberToDegree(lng);\n    }\n    return {\n      \"type\": \"Polygon\",\n      \"coordinates\": [poly]\n    };\n  }\n\n  // assumes rectangle starts at lower left point\n  gju.rectangleCentroid = function (rectangle) {\n    var bbox = rectangle.coordinates[0];\n    var xmin = bbox[0][0],\n      ymin = bbox[0][1],\n      xmax = bbox[2][0],\n      ymax = bbox[2][1];\n    var xwidth = xmax - xmin;\n    var ywidth = ymax - ymin;\n    return {\n      'type': 'Point',\n      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]\n    };\n  }\n\n  // from http://www.movable-type.co.uk/scripts/latlong.html\n  gju.pointDistance = function (pt1, pt2) {\n    var lon1 = pt1.coordinates[0],\n      lat1 = pt1.coordinates[1],\n      lon2 = pt2.coordinates[0],\n      lat2 = pt2.coordinates[1],\n      dLat = gju.numberToRadius(lat2 - lat1),\n      dLon = gju.numberToRadius(lon2 - lon1),\n      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))\n        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),\n      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    // Earth radius is 6371 km\n    return (6371 * c) * 1000; // returns meters\n  },\n\n  // checks if geometry lies entirely within a circle\n  // works with Point, LineString, Polygon\n  gju.geometryWithinRadius = function (geometry, center, radius) {\n    if (geometry.type == 'Point') {\n      return gju.pointDistance(geometry, center) <= radius;\n    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {\n      var point = {};\n      var coordinates;\n      if (geometry.type == 'Polygon') {\n        // it's enough to check the exterior ring of the Polygon\n        coordinates = geometry.coordinates[0];\n      } else {\n        coordinates = geometry.coordinates;\n      }\n      for (var i in coordinates) {\n        point.coordinates = coordinates[i];\n        if (gju.pointDistance(point, center) > radius) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n  gju.area = function (polygon) {\n    var area = 0;\n    // TODO: polygon holes at coordinates[1]\n    var points = polygon.coordinates[0];\n    var j = points.length - 1;\n    var p1, p2;\n\n    for (var i = 0; i < points.length; j = i++) {\n      var p1 = {\n        x: points[i][1],\n        y: points[i][0]\n      };\n      var p2 = {\n        x: points[j][1],\n        y: points[j][0]\n      };\n      area += p1.x * p2.y;\n      area -= p1.y * p2.x;\n    }\n\n    area /= 2;\n    return area;\n  },\n\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n  gju.centroid = function (polygon) {\n    var f, x = 0,\n      y = 0;\n    // TODO: polygon holes at coordinates[1]\n    var points = polygon.coordinates[0];\n    var j = points.length - 1;\n    var p1, p2;\n\n    for (var i = 0; i < points.length; j = i++) {\n      var p1 = {\n        x: points[i][1],\n        y: points[i][0]\n      };\n      var p2 = {\n        x: points[j][1],\n        y: points[j][0]\n      };\n      f = p1.x * p2.y - p2.x * p1.y;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n    }\n\n    f = gju.area(polygon) * 6;\n    return {\n      'type': 'Point',\n      'coordinates': [y / f, x / f]\n    };\n  },\n\n  gju.simplify = function (source, kink) { /* source[] array of geojson points */\n    /* kink\tin metres, kinks above this depth kept  */\n    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\n    kink = kink || 20;\n    source = source.map(function (o) {\n      return {\n        lng: o.coordinates[0],\n        lat: o.coordinates[1]\n      }\n    });\n\n    var n_source, n_stack, n_dest, start, end, i, sig;\n    var dev_sqr, max_dev_sqr, band_sqr;\n    var x12, y12, d12, x13, y13, d13, x23, y23, d23;\n    var F = (Math.PI / 180.0) * 0.5;\n    var index = new Array(); /* aray of indexes of source points to include in the reduced line */\n    var sig_start = new Array(); /* indices of start & end of working section */\n    var sig_end = new Array();\n\n    /* check for simple cases */\n\n    if (source.length < 3) return (source); /* one or two points */\n\n    /* more complex case. initialize stack */\n\n    n_source = source.length;\n    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\n    band_sqr *= band_sqr;\n    n_dest = 0;\n    sig_start[0] = 0;\n    sig_end[0] = n_source - 1;\n    n_stack = 1;\n\n    /* while the stack is not empty  ... */\n    while (n_stack > 0) {\n\n      /* ... pop the top-most entries off the stacks */\n\n      start = sig_start[n_stack - 1];\n      end = sig_end[n_stack - 1];\n      n_stack--;\n\n      if ((end - start) > 1) { /* any intermediate points ? */\n\n        /* ... yes, so find most deviant intermediate point to\n        either side of line joining start & end points */\n\n        x12 = (source[end].lng() - source[start].lng());\n        y12 = (source[end].lat() - source[start].lat());\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */\n        d12 = (x12 * x12) + (y12 * y12);\n\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n\n          x13 = source[i].lng() - source[start].lng();\n          y13 = source[i].lat() - source[start].lat();\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));\n          d13 = (x13 * x13) + (y13 * y13);\n\n          x23 = source[i].lng() - source[end].lng();\n          y23 = source[i].lat() - source[end].lat();\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));\n          d23 = (x23 * x23) + (y23 * y23);\n\n          if (d13 >= (d12 + d23)) dev_sqr = d23;\n          else if (d23 >= (d12 + d13)) dev_sqr = d13;\n          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle\n          if (dev_sqr > max_dev_sqr) {\n            sig = i;\n            max_dev_sqr = dev_sqr;\n          }\n        }\n\n        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */\n          /* ... no, so transfer current start point */\n          index[n_dest] = start;\n          n_dest++;\n        } else { /* ... yes, so push two sub-sections on stack for further processing */\n          n_stack++;\n          sig_start[n_stack - 1] = sig;\n          sig_end[n_stack - 1] = end;\n          n_stack++;\n          sig_start[n_stack - 1] = start;\n          sig_end[n_stack - 1] = sig;\n        }\n      } else { /* ... no intermediate points, so transfer current start point */\n        index[n_dest] = start;\n        n_dest++;\n      }\n    }\n\n    /* transfer last point */\n    index[n_dest] = n_source - 1;\n    n_dest++;\n\n    /* make return array */\n    var r = new Array();\n    for (var i = 0; i < n_dest; i++)\n      r.push(source[index[i]]);\n\n    return r.map(function (o) {\n      return {\n        type: \"Point\",\n        coordinates: [o.lng, o.lat]\n      }\n    });\n  }\n\n  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n  gju.destinationPoint = function (pt, brng, dist) {\n    dist = dist/6371;  // convert dist to angular distance in radians\n    brng = gju.numberToRadius(brng);\n\n    var lat1 = gju.numberToRadius(pt.coordinates[0]);\n    var lon1 = gju.numberToRadius(pt.coordinates[1]);\n\n    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +\n                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );\n    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),\n                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));\n    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º\n\n    return {\n      'type': 'Point',\n      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]\n    };\n  };\n\n})();\n","// This exports object was created in pre.js.  Now copy the `exports` object\n// from it into the package-scope variable `GeoJSON`, which will get exported.\nGeoJSON = module.exports;\n\n"]}}]