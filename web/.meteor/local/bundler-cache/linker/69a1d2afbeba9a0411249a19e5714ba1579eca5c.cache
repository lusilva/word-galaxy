[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar Log;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                     //\n// packages/logging/logging.js                                                         //\n//                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////\n                                                                                       //\nLog = function () {                                                                    // 1\n  return Log.info.apply(this, arguments);                                              // 2\n};                                                                                     // 3\n                                                                                       // 4\n/// FOR TESTING                                                                        // 5\nvar intercept = 0;                                                                     // 6\nvar interceptedLines = [];                                                             // 7\nvar suppress = 0;                                                                      // 8\n                                                                                       // 9\n// Intercept the next 'count' calls to a Log function. The actual                      // 10\n// lines printed to the console can be cleared and read by calling                     // 11\n// Log._intercepted().                                                                 // 12\nLog._intercept = function (count) {                                                    // 13\n  intercept += count;                                                                  // 14\n};                                                                                     // 15\n                                                                                       // 16\n// Suppress the next 'count' calls to a Log function. Use this to stop                 // 17\n// tests from spamming the console, especially with red errors that                    // 18\n// might look like a failing test.                                                     // 19\nLog._suppress = function (count) {                                                     // 20\n  suppress += count;                                                                   // 21\n};                                                                                     // 22\n                                                                                       // 23\n// Returns intercepted lines and resets the intercept counter.                         // 24\nLog._intercepted = function () {                                                       // 25\n  var lines = interceptedLines;                                                        // 26\n  interceptedLines = [];                                                               // 27\n  intercept = 0;                                                                       // 28\n  return lines;                                                                        // 29\n};                                                                                     // 30\n                                                                                       // 31\n// Either 'json' or 'colored-text'.                                                    // 32\n//                                                                                     // 33\n// When this is set to 'json', print JSON documents that are parsed by another         // 34\n// process ('satellite' or 'meteor run'). This other process should call               // 35\n// 'Log.format' for nice output.                                                       // 36\n//                                                                                     // 37\n// When this is set to 'colored-text', call 'Log.format' before printing.              // 38\n// This should be used for logging from within satellite, since there is no            // 39\n// other process that will be reading its standard output.                             // 40\nLog.outputFormat = 'json';                                                             // 41\n                                                                                       // 42\nvar LEVEL_COLORS = {                                                                   // 43\n  debug: 'green',                                                                      // 44\n  // leave info as the default color                                                   // 45\n  warn: 'magenta',                                                                     // 46\n  error: 'red'                                                                         // 47\n};                                                                                     // 48\n                                                                                       // 49\nvar META_COLOR = 'blue';                                                               // 50\n                                                                                       // 51\n// XXX package                                                                         // 52\nvar RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',                 // 53\n                        'program', 'originApp', 'satellite', 'stderr'];                // 54\n                                                                                       // 55\nvar FORMATTED_KEYS = RESTRICTED_KEYS.concat(['app', 'message']);                       // 56\n                                                                                       // 57\nvar logInBrowser = function (obj) {                                                    // 58\n  var str = Log.format(obj);                                                           // 59\n                                                                                       // 60\n  // XXX Some levels should be probably be sent to the server                          // 61\n  var level = obj.level;                                                               // 62\n                                                                                       // 63\n  if ((typeof console !== 'undefined') && console[level]) {                            // 64\n    console[level](str);                                                               // 65\n  } else {                                                                             // 66\n    // XXX Uses of Meteor._debug should probably be replaced by Log.debug or           // 67\n    //     Log.info, and we should have another name for \"do your best to              // 68\n    //     call call console.log\".                                                     // 69\n    Meteor._debug(str);                                                                // 70\n  }                                                                                    // 71\n};                                                                                     // 72\n                                                                                       // 73\n// @returns {Object: { line: Number, file: String }}                                   // 74\nLog._getCallerDetails = function () {                                                  // 75\n  var getStack = function () {                                                         // 76\n    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a       // 77\n    // pre-parsed stack) since it's impossible to compose it with the use of           // 78\n    // Error.prepareStackTrace used on the server for source maps.                     // 79\n    var err = new Error;                                                               // 80\n    var stack = err.stack;                                                             // 81\n    return stack;                                                                      // 82\n  };                                                                                   // 83\n                                                                                       // 84\n  var stack = getStack();                                                              // 85\n                                                                                       // 86\n  if (!stack) return {};                                                               // 87\n                                                                                       // 88\n  var lines = stack.split('\\n');                                                       // 89\n                                                                                       // 90\n  // looking for the first line outside the logging package (or an                     // 91\n  // eval if we find that first)                                                       // 92\n  var line;                                                                            // 93\n  for (var i = 1; i < lines.length; ++i) {                                             // 94\n    line = lines[i];                                                                   // 95\n    if (line.match(/^\\s*at eval \\(eval/)) {                                            // 96\n      return {file: \"eval\"};                                                           // 97\n    }                                                                                  // 98\n                                                                                       // 99\n    if (!line.match(/packages\\/(?:local-test[:_])?logging(?:\\/|\\.js)/))                // 100\n      break;                                                                           // 101\n  }                                                                                    // 102\n                                                                                       // 103\n  var details = {};                                                                    // 104\n                                                                                       // 105\n  // The format for FF is 'functionName@filePath:lineNumber'                           // 106\n  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or           // 107\n  //                      'packages/logging/logging.js:81'                             // 108\n  var match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\\)|$)/.exec(line);                    // 109\n  if (!match)                                                                          // 110\n    return details;                                                                    // 111\n  // in case the matched block here is line:column                                     // 112\n  details.line = match[2].split(':')[0];                                               // 113\n                                                                                       // 114\n  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar                // 115\n  // XXX: if you can write the following in better way, please do it                   // 116\n  // XXX: what about evals?                                                            // 117\n  details.file = match[1].split('/').slice(-1)[0].split('?')[0];                       // 118\n                                                                                       // 119\n  return details;                                                                      // 120\n};                                                                                     // 121\n                                                                                       // 122\n_.each(['debug', 'info', 'warn', 'error'], function (level) {                          // 123\n  // @param arg {String|Object}                                                        // 124\n  Log[level] = function (arg) {                                                        // 125\n    if (suppress) {                                                                    // 126\n      suppress--;                                                                      // 127\n      return;                                                                          // 128\n    }                                                                                  // 129\n                                                                                       // 130\n    var intercepted = false;                                                           // 131\n    if (intercept) {                                                                   // 132\n      intercept--;                                                                     // 133\n      intercepted = true;                                                              // 134\n    }                                                                                  // 135\n                                                                                       // 136\n    var obj = (_.isObject(arg) && !_.isRegExp(arg) && !_.isDate(arg) ) ?               // 137\n              arg : {message: new String(arg).toString() };                            // 138\n                                                                                       // 139\n    _.each(RESTRICTED_KEYS, function (key) {                                           // 140\n      if (obj[key])                                                                    // 141\n        throw new Error(\"Can't set '\" + key + \"' in log message\");                     // 142\n    });                                                                                // 143\n                                                                                       // 144\n    if (_.has(obj, 'message') && !_.isString(obj.message))                             // 145\n      throw new Error(\"The 'message' field in log objects must be a string\");          // 146\n    if (!obj.omitCallerDetails)                                                        // 147\n      obj = _.extend(Log._getCallerDetails(), obj);                                    // 148\n    obj.time = new Date();                                                             // 149\n    obj.level = level;                                                                 // 150\n                                                                                       // 151\n    // XXX allow you to enable 'debug', probably per-package                           // 152\n    if (level === 'debug')                                                             // 153\n      return;                                                                          // 154\n                                                                                       // 155\n    if (intercepted) {                                                                 // 156\n      interceptedLines.push(EJSON.stringify(obj));                                     // 157\n    } else if (Meteor.isServer) {                                                      // 158\n      if (Log.outputFormat === 'colored-text') {                                       // 159\n        console.log(Log.format(obj, {color: true}));                                   // 160\n      } else if (Log.outputFormat === 'json') {                                        // 161\n        console.log(EJSON.stringify(obj));                                             // 162\n      } else {                                                                         // 163\n        throw new Error(\"Unknown logging output format: \" + Log.outputFormat);         // 164\n      }                                                                                // 165\n    } else {                                                                           // 166\n      logInBrowser(obj);                                                               // 167\n    }                                                                                  // 168\n  };                                                                                   // 169\n});                                                                                    // 170\n                                                                                       // 171\n// tries to parse line as EJSON. returns object if parse is successful, or null if not\nLog.parse = function (line) {                                                          // 173\n  var obj = null;                                                                      // 174\n  if (line && line.charAt(0) === '{') { // might be json generated from calling 'Log'  // 175\n    try { obj = EJSON.parse(line); } catch (e) {}                                      // 176\n  }                                                                                    // 177\n                                                                                       // 178\n  // XXX should probably check fields other than 'time'                                // 179\n  if (obj && obj.time && (obj.time instanceof Date))                                   // 180\n    return obj;                                                                        // 181\n  else                                                                                 // 182\n    return null;                                                                       // 183\n};                                                                                     // 184\n                                                                                       // 185\n// formats a log object into colored human and machine-readable text                   // 186\nLog.format = function (obj, options) {                                                 // 187\n  obj = EJSON.clone(obj); // don't mutate the argument                                 // 188\n  options = options || {};                                                             // 189\n                                                                                       // 190\n  var time = obj.time;                                                                 // 191\n  if (!(time instanceof Date))                                                         // 192\n    throw new Error(\"'time' must be a Date object\");                                   // 193\n  var timeInexact = obj.timeInexact;                                                   // 194\n                                                                                       // 195\n  // store fields that are in FORMATTED_KEYS since we strip them                       // 196\n  var level = obj.level || 'info';                                                     // 197\n  var file = obj.file;                                                                 // 198\n  var lineNumber = obj.line;                                                           // 199\n  var appName = obj.app || '';                                                         // 200\n  var originApp = obj.originApp;                                                       // 201\n  var message = obj.message || '';                                                     // 202\n  var program = obj.program || '';                                                     // 203\n  var satellite = obj.satellite;                                                       // 204\n  var stderr = obj.stderr || '';                                                       // 205\n                                                                                       // 206\n  _.each(FORMATTED_KEYS, function(key) {                                               // 207\n    delete obj[key];                                                                   // 208\n  });                                                                                  // 209\n                                                                                       // 210\n  if (!_.isEmpty(obj)) {                                                               // 211\n    if (message) message += \" \";                                                       // 212\n    message += EJSON.stringify(obj);                                                   // 213\n  }                                                                                    // 214\n                                                                                       // 215\n  var pad2 = function(n) { return n < 10 ? '0' + n : n.toString(); };                  // 216\n  var pad3 = function(n) { return n < 100 ? '0' + pad2(n) : n.toString(); };           // 217\n                                                                                       // 218\n  var dateStamp = time.getFullYear().toString() +                                      // 219\n    pad2(time.getMonth() + 1 /*0-based*/) +                                            // 220\n    pad2(time.getDate());                                                              // 221\n  var timeStamp = pad2(time.getHours()) +                                              // 222\n        ':' +                                                                          // 223\n        pad2(time.getMinutes()) +                                                      // 224\n        ':' +                                                                          // 225\n        pad2(time.getSeconds()) +                                                      // 226\n        '.' +                                                                          // 227\n        pad3(time.getMilliseconds());                                                  // 228\n                                                                                       // 229\n  // eg in San Francisco in June this will be '(-7)'                                   // 230\n  var utcOffsetStr = '(' + (-(new Date().getTimezoneOffset() / 60)) + ')';             // 231\n                                                                                       // 232\n  var appInfo = '';                                                                    // 233\n  if (appName) appInfo += appName;                                                     // 234\n  if (originApp && originApp !== appName) appInfo += ' via ' + originApp;              // 235\n  if (appInfo) appInfo = '[' + appInfo + '] ';                                         // 236\n                                                                                       // 237\n  var sourceInfoParts = [];                                                            // 238\n  if (program) sourceInfoParts.push(program);                                          // 239\n  if (file) sourceInfoParts.push(file);                                                // 240\n  if (lineNumber) sourceInfoParts.push(lineNumber);                                    // 241\n  var sourceInfo = _.isEmpty(sourceInfoParts) ?                                        // 242\n    '' : '(' + sourceInfoParts.join(':') + ') ';                                       // 243\n                                                                                       // 244\n  if (satellite)                                                                       // 245\n    sourceInfo += ['[', satellite, ']'].join('');                                      // 246\n                                                                                       // 247\n  var stderrIndicator = stderr ? '(STDERR) ' : '';                                     // 248\n                                                                                       // 249\n  var metaPrefix = [                                                                   // 250\n    level.charAt(0).toUpperCase(),                                                     // 251\n    dateStamp,                                                                         // 252\n    '-',                                                                               // 253\n    timeStamp,                                                                         // 254\n    utcOffsetStr,                                                                      // 255\n    timeInexact ? '? ' : ' ',                                                          // 256\n    appInfo,                                                                           // 257\n    sourceInfo,                                                                        // 258\n    stderrIndicator].join('');                                                         // 259\n                                                                                       // 260\n  var prettify = function (line, color) {                                              // 261\n    return (options.color && Meteor.isServer && color) ?                               // 262\n      Npm.require('cli-color')[color](line) : line;                                    // 263\n  };                                                                                   // 264\n                                                                                       // 265\n  return prettify(metaPrefix, options.metaColor || META_COLOR) +                       // 266\n    prettify(message, LEVEL_COLORS[level]);                                            // 267\n};                                                                                     // 268\n                                                                                       // 269\n// Turn a line of text into a loggable object.                                         // 270\n// @param line {String}                                                                // 271\n// @param override {Object}                                                            // 272\nLog.objFromText = function (line, override) {                                          // 273\n  var obj = {message: line, level: \"info\", time: new Date(), timeInexact: true};       // 274\n  return _.extend(obj, override);                                                      // 275\n};                                                                                     // 276\n                                                                                       // 277\n/////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.logging = {\n  Log: Log\n};\n\n})();\n","servePath":"/packages/logging.js","sourceMap":{"version":3,"sources":["/packages/logging/logging.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6F","file":"/packages/logging.js","sourcesContent":["Log = function () {\n  return Log.info.apply(this, arguments);\n};\n\n/// FOR TESTING\nvar intercept = 0;\nvar interceptedLines = [];\nvar suppress = 0;\n\n// Intercept the next 'count' calls to a Log function. The actual\n// lines printed to the console can be cleared and read by calling\n// Log._intercepted().\nLog._intercept = function (count) {\n  intercept += count;\n};\n\n// Suppress the next 'count' calls to a Log function. Use this to stop\n// tests from spamming the console, especially with red errors that\n// might look like a failing test.\nLog._suppress = function (count) {\n  suppress += count;\n};\n\n// Returns intercepted lines and resets the intercept counter.\nLog._intercepted = function () {\n  var lines = interceptedLines;\n  interceptedLines = [];\n  intercept = 0;\n  return lines;\n};\n\n// Either 'json' or 'colored-text'.\n//\n// When this is set to 'json', print JSON documents that are parsed by another\n// process ('satellite' or 'meteor run'). This other process should call\n// 'Log.format' for nice output.\n//\n// When this is set to 'colored-text', call 'Log.format' before printing.\n// This should be used for logging from within satellite, since there is no\n// other process that will be reading its standard output.\nLog.outputFormat = 'json';\n\nvar LEVEL_COLORS = {\n  debug: 'green',\n  // leave info as the default color\n  warn: 'magenta',\n  error: 'red'\n};\n\nvar META_COLOR = 'blue';\n\n// XXX package\nvar RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',\n                        'program', 'originApp', 'satellite', 'stderr'];\n\nvar FORMATTED_KEYS = RESTRICTED_KEYS.concat(['app', 'message']);\n\nvar logInBrowser = function (obj) {\n  var str = Log.format(obj);\n\n  // XXX Some levels should be probably be sent to the server\n  var level = obj.level;\n\n  if ((typeof console !== 'undefined') && console[level]) {\n    console[level](str);\n  } else {\n    // XXX Uses of Meteor._debug should probably be replaced by Log.debug or\n    //     Log.info, and we should have another name for \"do your best to\n    //     call call console.log\".\n    Meteor._debug(str);\n  }\n};\n\n// @returns {Object: { line: Number, file: String }}\nLog._getCallerDetails = function () {\n  var getStack = function () {\n    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a\n    // pre-parsed stack) since it's impossible to compose it with the use of\n    // Error.prepareStackTrace used on the server for source maps.\n    var err = new Error;\n    var stack = err.stack;\n    return stack;\n  };\n\n  var stack = getStack();\n\n  if (!stack) return {};\n\n  var lines = stack.split('\\n');\n\n  // looking for the first line outside the logging package (or an\n  // eval if we find that first)\n  var line;\n  for (var i = 1; i < lines.length; ++i) {\n    line = lines[i];\n    if (line.match(/^\\s*at eval \\(eval/)) {\n      return {file: \"eval\"};\n    }\n\n    if (!line.match(/packages\\/(?:local-test[:_])?logging(?:\\/|\\.js)/))\n      break;\n  }\n\n  var details = {};\n\n  // The format for FF is 'functionName@filePath:lineNumber'\n  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or\n  //                      'packages/logging/logging.js:81'\n  var match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\\)|$)/.exec(line);\n  if (!match)\n    return details;\n  // in case the matched block here is line:column\n  details.line = match[2].split(':')[0];\n\n  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar\n  // XXX: if you can write the following in better way, please do it\n  // XXX: what about evals?\n  details.file = match[1].split('/').slice(-1)[0].split('?')[0];\n\n  return details;\n};\n\n_.each(['debug', 'info', 'warn', 'error'], function (level) {\n  // @param arg {String|Object}\n  Log[level] = function (arg) {\n    if (suppress) {\n      suppress--;\n      return;\n    }\n\n    var intercepted = false;\n    if (intercept) {\n      intercept--;\n      intercepted = true;\n    }\n\n    var obj = (_.isObject(arg) && !_.isRegExp(arg) && !_.isDate(arg) ) ?\n              arg : {message: new String(arg).toString() };\n\n    _.each(RESTRICTED_KEYS, function (key) {\n      if (obj[key])\n        throw new Error(\"Can't set '\" + key + \"' in log message\");\n    });\n\n    if (_.has(obj, 'message') && !_.isString(obj.message))\n      throw new Error(\"The 'message' field in log objects must be a string\");\n    if (!obj.omitCallerDetails)\n      obj = _.extend(Log._getCallerDetails(), obj);\n    obj.time = new Date();\n    obj.level = level;\n\n    // XXX allow you to enable 'debug', probably per-package\n    if (level === 'debug')\n      return;\n\n    if (intercepted) {\n      interceptedLines.push(EJSON.stringify(obj));\n    } else if (Meteor.isServer) {\n      if (Log.outputFormat === 'colored-text') {\n        console.log(Log.format(obj, {color: true}));\n      } else if (Log.outputFormat === 'json') {\n        console.log(EJSON.stringify(obj));\n      } else {\n        throw new Error(\"Unknown logging output format: \" + Log.outputFormat);\n      }\n    } else {\n      logInBrowser(obj);\n    }\n  };\n});\n\n// tries to parse line as EJSON. returns object if parse is successful, or null if not\nLog.parse = function (line) {\n  var obj = null;\n  if (line && line.charAt(0) === '{') { // might be json generated from calling 'Log'\n    try { obj = EJSON.parse(line); } catch (e) {}\n  }\n\n  // XXX should probably check fields other than 'time'\n  if (obj && obj.time && (obj.time instanceof Date))\n    return obj;\n  else\n    return null;\n};\n\n// formats a log object into colored human and machine-readable text\nLog.format = function (obj, options) {\n  obj = EJSON.clone(obj); // don't mutate the argument\n  options = options || {};\n\n  var time = obj.time;\n  if (!(time instanceof Date))\n    throw new Error(\"'time' must be a Date object\");\n  var timeInexact = obj.timeInexact;\n\n  // store fields that are in FORMATTED_KEYS since we strip them\n  var level = obj.level || 'info';\n  var file = obj.file;\n  var lineNumber = obj.line;\n  var appName = obj.app || '';\n  var originApp = obj.originApp;\n  var message = obj.message || '';\n  var program = obj.program || '';\n  var satellite = obj.satellite;\n  var stderr = obj.stderr || '';\n\n  _.each(FORMATTED_KEYS, function(key) {\n    delete obj[key];\n  });\n\n  if (!_.isEmpty(obj)) {\n    if (message) message += \" \";\n    message += EJSON.stringify(obj);\n  }\n\n  var pad2 = function(n) { return n < 10 ? '0' + n : n.toString(); };\n  var pad3 = function(n) { return n < 100 ? '0' + pad2(n) : n.toString(); };\n\n  var dateStamp = time.getFullYear().toString() +\n    pad2(time.getMonth() + 1 /*0-based*/) +\n    pad2(time.getDate());\n  var timeStamp = pad2(time.getHours()) +\n        ':' +\n        pad2(time.getMinutes()) +\n        ':' +\n        pad2(time.getSeconds()) +\n        '.' +\n        pad3(time.getMilliseconds());\n\n  // eg in San Francisco in June this will be '(-7)'\n  var utcOffsetStr = '(' + (-(new Date().getTimezoneOffset() / 60)) + ')';\n\n  var appInfo = '';\n  if (appName) appInfo += appName;\n  if (originApp && originApp !== appName) appInfo += ' via ' + originApp;\n  if (appInfo) appInfo = '[' + appInfo + '] ';\n\n  var sourceInfoParts = [];\n  if (program) sourceInfoParts.push(program);\n  if (file) sourceInfoParts.push(file);\n  if (lineNumber) sourceInfoParts.push(lineNumber);\n  var sourceInfo = _.isEmpty(sourceInfoParts) ?\n    '' : '(' + sourceInfoParts.join(':') + ') ';\n\n  if (satellite)\n    sourceInfo += ['[', satellite, ']'].join('');\n\n  var stderrIndicator = stderr ? '(STDERR) ' : '';\n\n  var metaPrefix = [\n    level.charAt(0).toUpperCase(),\n    dateStamp,\n    '-',\n    timeStamp,\n    utcOffsetStr,\n    timeInexact ? '? ' : ' ',\n    appInfo,\n    sourceInfo,\n    stderrIndicator].join('');\n\n  var prettify = function (line, color) {\n    return (options.color && Meteor.isServer && color) ?\n      Npm.require('cli-color')[color](line) : line;\n  };\n\n  return prettify(metaPrefix, options.metaColor || META_COLOR) +\n    prettify(message, LEVEL_COLORS[level]);\n};\n\n// Turn a line of text into a loggable object.\n// @param line {String}\n// @param override {Object}\nLog.objFromText = function (line, override) {\n  var obj = {message: line, level: \"info\", time: new Date(), timeInexact: true};\n  return _.extend(obj, override);\n};\n"]}}]