[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar $ = Package.jquery.$;\nvar jQuery = Package.jquery.jQuery;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar HTML = Package.htmljs.HTML;\nvar ObserveSequence = Package['observe-sequence'].ObserveSequence;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\n\n/* Package-scope variables */\nvar Blaze, AttributeHandler, makeAttributeHandler, ElementAttributesUpdater, UI, Handlebars;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/preamble.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    // 1\n * @namespace Blaze                                                                                                    // 2\n * @summary The namespace for all Blaze-related methods and classes.                                                   // 3\n */                                                                                                                    // 4\nBlaze = {};                                                                                                            // 5\n                                                                                                                       // 6\n// Utility to HTML-escape a string.  Included for legacy reasons.                                                      // 7\nBlaze._escape = (function() {                                                                                          // 8\n  var escape_map = {                                                                                                   // 9\n    \"<\": \"&lt;\",                                                                                                       // 10\n    \">\": \"&gt;\",                                                                                                       // 11\n    '\"': \"&quot;\",                                                                                                     // 12\n    \"'\": \"&#x27;\",                                                                                                     // 13\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */                                                     // 14\n    \"&\": \"&amp;\"                                                                                                       // 15\n  };                                                                                                                   // 16\n  var escape_one = function(c) {                                                                                       // 17\n    return escape_map[c];                                                                                              // 18\n  };                                                                                                                   // 19\n                                                                                                                       // 20\n  return function (x) {                                                                                                // 21\n    return x.replace(/[&<>\"'`]/g, escape_one);                                                                         // 22\n  };                                                                                                                   // 23\n})();                                                                                                                  // 24\n                                                                                                                       // 25\nBlaze._warn = function (msg) {                                                                                         // 26\n  msg = 'Warning: ' + msg;                                                                                             // 27\n                                                                                                                       // 28\n  if ((typeof console !== 'undefined') && console.warn) {                                                              // 29\n    console.warn(msg);                                                                                                 // 30\n  }                                                                                                                    // 31\n};                                                                                                                     // 32\n                                                                                                                       // 33\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/dombackend.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar DOMBackend = {};                                                                                                   // 1\nBlaze._DOMBackend = DOMBackend;                                                                                        // 2\n                                                                                                                       // 3\nvar $jq = (typeof jQuery !== 'undefined' ? jQuery :                                                                    // 4\n           (typeof Package !== 'undefined' ?                                                                           // 5\n            Package.jquery && Package.jquery.jQuery : null));                                                          // 6\nif (! $jq)                                                                                                             // 7\n  throw new Error(\"jQuery not found\");                                                                                 // 8\n                                                                                                                       // 9\nDOMBackend._$jq = $jq;                                                                                                 // 10\n                                                                                                                       // 11\nDOMBackend.parseHTML = function (html) {                                                                               // 12\n  // Return an array of nodes.                                                                                         // 13\n  //                                                                                                                   // 14\n  // jQuery does fancy stuff like creating an appropriate                                                              // 15\n  // container element and setting innerHTML on it, as well                                                            // 16\n  // as working around various IE quirks.                                                                              // 17\n  return $jq.parseHTML(html) || [];                                                                                    // 18\n};                                                                                                                     // 19\n                                                                                                                       // 20\nDOMBackend.Events = {                                                                                                  // 21\n  // `selector` is non-null.  `type` is one type (but                                                                  // 22\n  // may be in backend-specific form, e.g. have namespaces).                                                           // 23\n  // Order fired must be order bound.                                                                                  // 24\n  delegateEvents: function (elem, type, selector, handler) {                                                           // 25\n    $jq(elem).on(type, selector, handler);                                                                             // 26\n  },                                                                                                                   // 27\n                                                                                                                       // 28\n  undelegateEvents: function (elem, type, handler) {                                                                   // 29\n    $jq(elem).off(type, '**', handler);                                                                                // 30\n  },                                                                                                                   // 31\n                                                                                                                       // 32\n  bindEventCapturer: function (elem, type, selector, handler) {                                                        // 33\n    var $elem = $jq(elem);                                                                                             // 34\n                                                                                                                       // 35\n    var wrapper = function (event) {                                                                                   // 36\n      event = $jq.event.fix(event);                                                                                    // 37\n      event.currentTarget = event.target;                                                                              // 38\n                                                                                                                       // 39\n      // Note: It might improve jQuery interop if we called into jQuery                                                // 40\n      // here somehow.  Since we don't use jQuery to dispatch the event,                                               // 41\n      // we don't fire any of jQuery's event hooks or anything.  However,                                              // 42\n      // since jQuery can't bind capturing handlers, it's not clear                                                    // 43\n      // where we would hook in.  Internal jQuery functions like `dispatch`                                            // 44\n      // are too high-level.                                                                                           // 45\n      var $target = $jq(event.currentTarget);                                                                          // 46\n      if ($target.is($elem.find(selector)))                                                                            // 47\n        handler.call(elem, event);                                                                                     // 48\n    };                                                                                                                 // 49\n                                                                                                                       // 50\n    handler._meteorui_wrapper = wrapper;                                                                               // 51\n                                                                                                                       // 52\n    type = DOMBackend.Events.parseEventType(type);                                                                     // 53\n    // add *capturing* event listener                                                                                  // 54\n    elem.addEventListener(type, wrapper, true);                                                                        // 55\n  },                                                                                                                   // 56\n                                                                                                                       // 57\n  unbindEventCapturer: function (elem, type, handler) {                                                                // 58\n    type = DOMBackend.Events.parseEventType(type);                                                                     // 59\n    elem.removeEventListener(type, handler._meteorui_wrapper, true);                                                   // 60\n  },                                                                                                                   // 61\n                                                                                                                       // 62\n  parseEventType: function (type) {                                                                                    // 63\n    // strip off namespaces                                                                                            // 64\n    var dotLoc = type.indexOf('.');                                                                                    // 65\n    if (dotLoc >= 0)                                                                                                   // 66\n      return type.slice(0, dotLoc);                                                                                    // 67\n    return type;                                                                                                       // 68\n  }                                                                                                                    // 69\n};                                                                                                                     // 70\n                                                                                                                       // 71\n                                                                                                                       // 72\n///// Removal detection and interoperability.                                                                          // 73\n                                                                                                                       // 74\n// For an explanation of this technique, see:                                                                          // 75\n// http://bugs.jquery.com/ticket/12213#comment:23 .                                                                    // 76\n//                                                                                                                     // 77\n// In short, an element is considered \"removed\" when jQuery                                                            // 78\n// cleans up its *private* userdata on the element,                                                                    // 79\n// which we can detect using a custom event with a teardown                                                            // 80\n// hook.                                                                                                               // 81\n                                                                                                                       // 82\nvar NOOP = function () {};                                                                                             // 83\n                                                                                                                       // 84\n// Circular doubly-linked list                                                                                         // 85\nvar TeardownCallback = function (func) {                                                                               // 86\n  this.next = this;                                                                                                    // 87\n  this.prev = this;                                                                                                    // 88\n  this.func = func;                                                                                                    // 89\n};                                                                                                                     // 90\n                                                                                                                       // 91\n// Insert newElt before oldElt in the circular list                                                                    // 92\nTeardownCallback.prototype.linkBefore = function(oldElt) {                                                             // 93\n  this.prev = oldElt.prev;                                                                                             // 94\n  this.next = oldElt;                                                                                                  // 95\n  oldElt.prev.next = this;                                                                                             // 96\n  oldElt.prev = this;                                                                                                  // 97\n};                                                                                                                     // 98\n                                                                                                                       // 99\nTeardownCallback.prototype.unlink = function () {                                                                      // 100\n  this.prev.next = this.next;                                                                                          // 101\n  this.next.prev = this.prev;                                                                                          // 102\n};                                                                                                                     // 103\n                                                                                                                       // 104\nTeardownCallback.prototype.go = function () {                                                                          // 105\n  var func = this.func;                                                                                                // 106\n  func && func();                                                                                                      // 107\n};                                                                                                                     // 108\n                                                                                                                       // 109\nTeardownCallback.prototype.stop = TeardownCallback.prototype.unlink;                                                   // 110\n                                                                                                                       // 111\nDOMBackend.Teardown = {                                                                                                // 112\n  _JQUERY_EVENT_NAME: 'blaze_teardown_watcher',                                                                        // 113\n  _CB_PROP: '$blaze_teardown_callbacks',                                                                               // 114\n  // Registers a callback function to be called when the given element or                                              // 115\n  // one of its ancestors is removed from the DOM via the backend library.                                             // 116\n  // The callback function is called at most once, and it receives the element                                         // 117\n  // in question as an argument.                                                                                       // 118\n  onElementTeardown: function (elem, func) {                                                                           // 119\n    var elt = new TeardownCallback(func);                                                                              // 120\n                                                                                                                       // 121\n    var propName = DOMBackend.Teardown._CB_PROP;                                                                       // 122\n    if (! elem[propName]) {                                                                                            // 123\n      // create an empty node that is never unlinked                                                                   // 124\n      elem[propName] = new TeardownCallback;                                                                           // 125\n                                                                                                                       // 126\n      // Set up the event, only the first time.                                                                        // 127\n      $jq(elem).on(DOMBackend.Teardown._JQUERY_EVENT_NAME, NOOP);                                                      // 128\n    }                                                                                                                  // 129\n                                                                                                                       // 130\n    elt.linkBefore(elem[propName]);                                                                                    // 131\n                                                                                                                       // 132\n    return elt; // so caller can call stop()                                                                           // 133\n  },                                                                                                                   // 134\n  // Recursively call all teardown hooks, in the backend and registered                                                // 135\n  // through DOMBackend.onElementTeardown.                                                                             // 136\n  tearDownElement: function (elem) {                                                                                   // 137\n    var elems = [];                                                                                                    // 138\n    // Array.prototype.slice.call doesn't work when given a NodeList in                                                // 139\n    // IE8 (\"JScript object expected\").                                                                                // 140\n    var nodeList = elem.getElementsByTagName('*');                                                                     // 141\n    for (var i = 0; i < nodeList.length; i++) {                                                                        // 142\n      elems.push(nodeList[i]);                                                                                         // 143\n    }                                                                                                                  // 144\n    elems.push(elem);                                                                                                  // 145\n    $jq.cleanData(elems);                                                                                              // 146\n  }                                                                                                                    // 147\n};                                                                                                                     // 148\n                                                                                                                       // 149\n$jq.event.special[DOMBackend.Teardown._JQUERY_EVENT_NAME] = {                                                          // 150\n  setup: function () {                                                                                                 // 151\n    // This \"setup\" callback is important even though it is empty!                                                     // 152\n    // Without it, jQuery will call addEventListener, which is a                                                       // 153\n    // performance hit, especially with Chrome's async stack trace                                                     // 154\n    // feature enabled.                                                                                                // 155\n  },                                                                                                                   // 156\n  teardown: function() {                                                                                               // 157\n    var elem = this;                                                                                                   // 158\n    var callbacks = elem[DOMBackend.Teardown._CB_PROP];                                                                // 159\n    if (callbacks) {                                                                                                   // 160\n      var elt = callbacks.next;                                                                                        // 161\n      while (elt !== callbacks) {                                                                                      // 162\n        elt.go();                                                                                                      // 163\n        elt = elt.next;                                                                                                // 164\n      }                                                                                                                // 165\n      callbacks.go();                                                                                                  // 166\n                                                                                                                       // 167\n      elem[DOMBackend.Teardown._CB_PROP] = null;                                                                       // 168\n    }                                                                                                                  // 169\n  }                                                                                                                    // 170\n};                                                                                                                     // 171\n                                                                                                                       // 172\n                                                                                                                       // 173\n// Must use jQuery semantics for `context`, not                                                                        // 174\n// querySelectorAll's.  In other words, all the parts                                                                  // 175\n// of `selector` must be found under `context`.                                                                        // 176\nDOMBackend.findBySelector = function (selector, context) {                                                             // 177\n  return $jq(selector, context);                                                                                       // 178\n};                                                                                                                     // 179\n                                                                                                                       // 180\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/domrange.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n                                                                                                                       // 1\n// A constant empty array (frozen if the JS engine supports it).                                                       // 2\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];                                                              // 3\n                                                                                                                       // 4\n// `[new] Blaze._DOMRange([nodeAndRangeArray])`                                                                        // 5\n//                                                                                                                     // 6\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,                                                 // 7\n// which may be replaced at any time with a new array.  If the DOMRange                                                // 8\n// has been attached to the DOM at some location, then updating                                                        // 9\n// the array will cause the DOM to be updated at that location.                                                        // 10\nBlaze._DOMRange = function (nodeAndRangeArray) {                                                                       // 11\n  if (! (this instanceof DOMRange))                                                                                    // 12\n    // called without `new`                                                                                            // 13\n    return new DOMRange(nodeAndRangeArray);                                                                            // 14\n                                                                                                                       // 15\n  var members = (nodeAndRangeArray || _emptyArray);                                                                    // 16\n  if (! (members && (typeof members.length) === 'number'))                                                             // 17\n    throw new Error(\"Expected array\");                                                                                 // 18\n                                                                                                                       // 19\n  for (var i = 0; i < members.length; i++)                                                                             // 20\n    this._memberIn(members[i]);                                                                                        // 21\n                                                                                                                       // 22\n  this.members = members;                                                                                              // 23\n  this.emptyRangePlaceholder = null;                                                                                   // 24\n  this.attached = false;                                                                                               // 25\n  this.parentElement = null;                                                                                           // 26\n  this.parentRange = null;                                                                                             // 27\n  this.attachedCallbacks = _emptyArray;                                                                                // 28\n};                                                                                                                     // 29\nvar DOMRange = Blaze._DOMRange;                                                                                        // 30\n                                                                                                                       // 31\n// In IE 8, don't use empty text nodes as placeholders                                                                 // 32\n// in empty DOMRanges, use comment nodes instead.  Using                                                               // 33\n// empty text nodes in modern browsers is great because                                                                // 34\n// it doesn't clutter the web inspector.  In IE 8, however,                                                            // 35\n// it seems to lead in some roundabout way to the OAuth                                                                // 36\n// pop-up crashing the browser completely.  In the past,                                                               // 37\n// we didn't use empty text nodes on IE 8 because they                                                                 // 38\n// don't accept JS properties, so just use the same logic                                                              // 39\n// even though we don't need to set properties on the                                                                  // 40\n// placeholder anymore.                                                                                                // 41\nDOMRange._USE_COMMENT_PLACEHOLDERS = (function () {                                                                    // 42\n  var result = false;                                                                                                  // 43\n  var textNode = document.createTextNode(\"\");                                                                          // 44\n  try {                                                                                                                // 45\n    textNode.someProp = true;                                                                                          // 46\n  } catch (e) {                                                                                                        // 47\n    // IE 8                                                                                                            // 48\n    result = true;                                                                                                     // 49\n  }                                                                                                                    // 50\n  return result;                                                                                                       // 51\n})();                                                                                                                  // 52\n                                                                                                                       // 53\n// static methods                                                                                                      // 54\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {                                          // 55\n  var m = rangeOrNode;                                                                                                 // 56\n  if (m instanceof DOMRange) {                                                                                         // 57\n    m.attach(parentElement, nextNode, _isMove);                                                                        // 58\n  } else {                                                                                                             // 59\n    if (_isMove)                                                                                                       // 60\n      DOMRange._moveNodeWithHooks(m, parentElement, nextNode);                                                         // 61\n    else                                                                                                               // 62\n      DOMRange._insertNodeWithHooks(m, parentElement, nextNode);                                                       // 63\n  }                                                                                                                    // 64\n};                                                                                                                     // 65\n                                                                                                                       // 66\nDOMRange._remove = function (rangeOrNode) {                                                                            // 67\n  var m = rangeOrNode;                                                                                                 // 68\n  if (m instanceof DOMRange) {                                                                                         // 69\n    m.detach();                                                                                                        // 70\n  } else {                                                                                                             // 71\n    DOMRange._removeNodeWithHooks(m);                                                                                  // 72\n  }                                                                                                                    // 73\n};                                                                                                                     // 74\n                                                                                                                       // 75\nDOMRange._removeNodeWithHooks = function (n) {                                                                         // 76\n  if (! n.parentNode)                                                                                                  // 77\n    return;                                                                                                            // 78\n  if (n.nodeType === 1 &&                                                                                              // 79\n      n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {                                                  // 80\n    n.parentNode._uihooks.removeElement(n);                                                                            // 81\n  } else {                                                                                                             // 82\n    n.parentNode.removeChild(n);                                                                                       // 83\n  }                                                                                                                    // 84\n};                                                                                                                     // 85\n                                                                                                                       // 86\nDOMRange._insertNodeWithHooks = function (n, parent, next) {                                                           // 87\n  // `|| null` because IE throws an error if 'next' is undefined                                                       // 88\n  next = next || null;                                                                                                 // 89\n  if (n.nodeType === 1 &&                                                                                              // 90\n      parent._uihooks && parent._uihooks.insertElement) {                                                              // 91\n    parent._uihooks.insertElement(n, next);                                                                            // 92\n  } else {                                                                                                             // 93\n    parent.insertBefore(n, next);                                                                                      // 94\n  }                                                                                                                    // 95\n};                                                                                                                     // 96\n                                                                                                                       // 97\nDOMRange._moveNodeWithHooks = function (n, parent, next) {                                                             // 98\n  if (n.parentNode !== parent)                                                                                         // 99\n    return;                                                                                                            // 100\n  // `|| null` because IE throws an error if 'next' is undefined                                                       // 101\n  next = next || null;                                                                                                 // 102\n  if (n.nodeType === 1 &&                                                                                              // 103\n      parent._uihooks && parent._uihooks.moveElement) {                                                                // 104\n    parent._uihooks.moveElement(n, next);                                                                              // 105\n  } else {                                                                                                             // 106\n    parent.insertBefore(n, next);                                                                                      // 107\n  }                                                                                                                    // 108\n};                                                                                                                     // 109\n                                                                                                                       // 110\nDOMRange.forElement = function (elem) {                                                                                // 111\n  if (elem.nodeType !== 1)                                                                                             // 112\n    throw new Error(\"Expected element, found: \" + elem);                                                               // 113\n  var range = null;                                                                                                    // 114\n  while (elem && ! range) {                                                                                            // 115\n    range = (elem.$blaze_range || null);                                                                               // 116\n    if (! range)                                                                                                       // 117\n      elem = elem.parentNode;                                                                                          // 118\n  }                                                                                                                    // 119\n  return range;                                                                                                        // 120\n};                                                                                                                     // 121\n                                                                                                                       // 122\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {                                  // 123\n  // This method is called to insert the DOMRange into the DOM for                                                     // 124\n  // the first time, but it's also used internally when                                                                // 125\n  // updating the DOM.                                                                                                 // 126\n  //                                                                                                                   // 127\n  // If _isMove is true, move this attached range to a different                                                       // 128\n  // location under the same parentElement.                                                                            // 129\n  if (_isMove || _isReplace) {                                                                                         // 130\n    if (! (this.parentElement === parentElement &&                                                                     // 131\n           this.attached))                                                                                             // 132\n      throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");        // 133\n  }                                                                                                                    // 134\n                                                                                                                       // 135\n  var members = this.members;                                                                                          // 136\n  if (members.length) {                                                                                                // 137\n    this.emptyRangePlaceholder = null;                                                                                 // 138\n    for (var i = 0; i < members.length; i++) {                                                                         // 139\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);                                                  // 140\n    }                                                                                                                  // 141\n  } else {                                                                                                             // 142\n    var placeholder = (                                                                                                // 143\n      DOMRange._USE_COMMENT_PLACEHOLDERS ?                                                                             // 144\n        document.createComment(\"\") :                                                                                   // 145\n        document.createTextNode(\"\"));                                                                                  // 146\n    this.emptyRangePlaceholder = placeholder;                                                                          // 147\n    parentElement.insertBefore(placeholder, nextNode || null);                                                         // 148\n  }                                                                                                                    // 149\n  this.attached = true;                                                                                                // 150\n  this.parentElement = parentElement;                                                                                  // 151\n                                                                                                                       // 152\n  if (! (_isMove || _isReplace)) {                                                                                     // 153\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {                                                           // 154\n      var obj = this.attachedCallbacks[i];                                                                             // 155\n      obj.attached && obj.attached(this, parentElement);                                                               // 156\n    }                                                                                                                  // 157\n  }                                                                                                                    // 158\n};                                                                                                                     // 159\n                                                                                                                       // 160\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {                                                      // 161\n  var newMembers = newNodeAndRangeArray;                                                                               // 162\n  if (! (newMembers && (typeof newMembers.length) === 'number'))                                                       // 163\n    throw new Error(\"Expected array\");                                                                                 // 164\n                                                                                                                       // 165\n  var oldMembers = this.members;                                                                                       // 166\n                                                                                                                       // 167\n  for (var i = 0; i < oldMembers.length; i++)                                                                          // 168\n    this._memberOut(oldMembers[i]);                                                                                    // 169\n  for (var i = 0; i < newMembers.length; i++)                                                                          // 170\n    this._memberIn(newMembers[i]);                                                                                     // 171\n                                                                                                                       // 172\n  if (! this.attached) {                                                                                               // 173\n    this.members = newMembers;                                                                                         // 174\n  } else {                                                                                                             // 175\n    // don't do anything if we're going from empty to empty                                                            // 176\n    if (newMembers.length || oldMembers.length) {                                                                      // 177\n      // detach the old members and insert the new members                                                             // 178\n      var nextNode = this.lastNode().nextSibling;                                                                      // 179\n      var parentElement = this.parentElement;                                                                          // 180\n      // Use detach/attach, but don't fire attached/detached hooks                                                     // 181\n      this.detach(true /*_isReplace*/);                                                                                // 182\n      this.members = newMembers;                                                                                       // 183\n      this.attach(parentElement, nextNode, false, true /*_isReplace*/);                                                // 184\n    }                                                                                                                  // 185\n  }                                                                                                                    // 186\n};                                                                                                                     // 187\n                                                                                                                       // 188\nDOMRange.prototype.firstNode = function () {                                                                           // 189\n  if (! this.attached)                                                                                                 // 190\n    throw new Error(\"Must be attached\");                                                                               // 191\n                                                                                                                       // 192\n  if (! this.members.length)                                                                                           // 193\n    return this.emptyRangePlaceholder;                                                                                 // 194\n                                                                                                                       // 195\n  var m = this.members[0];                                                                                             // 196\n  return (m instanceof DOMRange) ? m.firstNode() : m;                                                                  // 197\n};                                                                                                                     // 198\n                                                                                                                       // 199\nDOMRange.prototype.lastNode = function () {                                                                            // 200\n  if (! this.attached)                                                                                                 // 201\n    throw new Error(\"Must be attached\");                                                                               // 202\n                                                                                                                       // 203\n  if (! this.members.length)                                                                                           // 204\n    return this.emptyRangePlaceholder;                                                                                 // 205\n                                                                                                                       // 206\n  var m = this.members[this.members.length - 1];                                                                       // 207\n  return (m instanceof DOMRange) ? m.lastNode() : m;                                                                   // 208\n};                                                                                                                     // 209\n                                                                                                                       // 210\nDOMRange.prototype.detach = function (_isReplace) {                                                                    // 211\n  if (! this.attached)                                                                                                 // 212\n    throw new Error(\"Must be attached\");                                                                               // 213\n                                                                                                                       // 214\n  var oldParentElement = this.parentElement;                                                                           // 215\n  var members = this.members;                                                                                          // 216\n  if (members.length) {                                                                                                // 217\n    for (var i = 0; i < members.length; i++) {                                                                         // 218\n      DOMRange._remove(members[i]);                                                                                    // 219\n    }                                                                                                                  // 220\n  } else {                                                                                                             // 221\n    var placeholder = this.emptyRangePlaceholder;                                                                      // 222\n    this.parentElement.removeChild(placeholder);                                                                       // 223\n    this.emptyRangePlaceholder = null;                                                                                 // 224\n  }                                                                                                                    // 225\n                                                                                                                       // 226\n  if (! _isReplace) {                                                                                                  // 227\n    this.attached = false;                                                                                             // 228\n    this.parentElement = null;                                                                                         // 229\n                                                                                                                       // 230\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {                                                           // 231\n      var obj = this.attachedCallbacks[i];                                                                             // 232\n      obj.detached && obj.detached(this, oldParentElement);                                                            // 233\n    }                                                                                                                  // 234\n  }                                                                                                                    // 235\n};                                                                                                                     // 236\n                                                                                                                       // 237\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {                                                // 238\n  var members = this.members;                                                                                          // 239\n  if (! (atIndex >= 0 && atIndex <= members.length))                                                                   // 240\n    throw new Error(\"Bad index in range.addMember: \" + atIndex);                                                       // 241\n                                                                                                                       // 242\n  if (! _isMove)                                                                                                       // 243\n    this._memberIn(newMember);                                                                                         // 244\n                                                                                                                       // 245\n  if (! this.attached) {                                                                                               // 246\n    // currently detached; just updated members                                                                        // 247\n    members.splice(atIndex, 0, newMember);                                                                             // 248\n  } else if (members.length === 0) {                                                                                   // 249\n    // empty; use the empty-to-nonempty handling of setMembers                                                         // 250\n    this.setMembers([newMember]);                                                                                      // 251\n  } else {                                                                                                             // 252\n    var nextNode;                                                                                                      // 253\n    if (atIndex === members.length) {                                                                                  // 254\n      // insert at end                                                                                                 // 255\n      nextNode = this.lastNode().nextSibling;                                                                          // 256\n    } else {                                                                                                           // 257\n      var m = members[atIndex];                                                                                        // 258\n      nextNode = (m instanceof DOMRange) ? m.firstNode() : m;                                                          // 259\n    }                                                                                                                  // 260\n    members.splice(atIndex, 0, newMember);                                                                             // 261\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);                                                // 262\n  }                                                                                                                    // 263\n};                                                                                                                     // 264\n                                                                                                                       // 265\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {                                                        // 266\n  var members = this.members;                                                                                          // 267\n  if (! (atIndex >= 0 && atIndex < members.length))                                                                    // 268\n    throw new Error(\"Bad index in range.removeMember: \" + atIndex);                                                    // 269\n                                                                                                                       // 270\n  if (_isMove) {                                                                                                       // 271\n    members.splice(atIndex, 1);                                                                                        // 272\n  } else {                                                                                                             // 273\n    var oldMember = members[atIndex];                                                                                  // 274\n    this._memberOut(oldMember);                                                                                        // 275\n                                                                                                                       // 276\n    if (members.length === 1) {                                                                                        // 277\n      // becoming empty; use the logic in setMembers                                                                   // 278\n      this.setMembers(_emptyArray);                                                                                    // 279\n    } else {                                                                                                           // 280\n      members.splice(atIndex, 1);                                                                                      // 281\n      if (this.attached)                                                                                               // 282\n        DOMRange._remove(oldMember);                                                                                   // 283\n    }                                                                                                                  // 284\n  }                                                                                                                    // 285\n};                                                                                                                     // 286\n                                                                                                                       // 287\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {                                                        // 288\n  var member = this.members[oldIndex];                                                                                 // 289\n  this.removeMember(oldIndex, true /*_isMove*/);                                                                       // 290\n  this.addMember(member, newIndex, true /*_isMove*/);                                                                  // 291\n};                                                                                                                     // 292\n                                                                                                                       // 293\nDOMRange.prototype.getMember = function (atIndex) {                                                                    // 294\n  var members = this.members;                                                                                          // 295\n  if (! (atIndex >= 0 && atIndex < members.length))                                                                    // 296\n    throw new Error(\"Bad index in range.getMember: \" + atIndex);                                                       // 297\n  return this.members[atIndex];                                                                                        // 298\n};                                                                                                                     // 299\n                                                                                                                       // 300\nDOMRange.prototype._memberIn = function (m) {                                                                          // 301\n  if (m instanceof DOMRange)                                                                                           // 302\n    m.parentRange = this;                                                                                              // 303\n  else if (m.nodeType === 1) // DOM Element                                                                            // 304\n    m.$blaze_range = this;                                                                                             // 305\n};                                                                                                                     // 306\n                                                                                                                       // 307\nDOMRange._destroy = function (m, _skipNodes) {                                                                         // 308\n  if (m instanceof DOMRange) {                                                                                         // 309\n    if (m.view)                                                                                                        // 310\n      Blaze._destroyView(m.view, _skipNodes);                                                                          // 311\n  } else if ((! _skipNodes) && m.nodeType === 1) {                                                                     // 312\n    // DOM Element                                                                                                     // 313\n    if (m.$blaze_range) {                                                                                              // 314\n      Blaze._destroyNode(m);                                                                                           // 315\n      m.$blaze_range = null;                                                                                           // 316\n    }                                                                                                                  // 317\n  }                                                                                                                    // 318\n};                                                                                                                     // 319\n                                                                                                                       // 320\nDOMRange.prototype._memberOut = DOMRange._destroy;                                                                     // 321\n                                                                                                                       // 322\n// Tear down, but don't remove, the members.  Used when chunks                                                         // 323\n// of DOM are being torn down or replaced.                                                                             // 324\nDOMRange.prototype.destroyMembers = function (_skipNodes) {                                                            // 325\n  var members = this.members;                                                                                          // 326\n  for (var i = 0; i < members.length; i++)                                                                             // 327\n    this._memberOut(members[i], _skipNodes);                                                                           // 328\n};                                                                                                                     // 329\n                                                                                                                       // 330\nDOMRange.prototype.destroy = function (_skipNodes) {                                                                   // 331\n  DOMRange._destroy(this, _skipNodes);                                                                                 // 332\n};                                                                                                                     // 333\n                                                                                                                       // 334\nDOMRange.prototype.containsElement = function (elem) {                                                                 // 335\n  if (! this.attached)                                                                                                 // 336\n    throw new Error(\"Must be attached\");                                                                               // 337\n                                                                                                                       // 338\n  // An element is contained in this DOMRange if it's possible to                                                      // 339\n  // reach it by walking parent pointers, first through the DOM and                                                    // 340\n  // then parentRange pointers.  In other words, the element or some                                                   // 341\n  // ancestor of it is at our level of the DOM (a child of our                                                         // 342\n  // parentElement), and this element is one of our members or                                                         // 343\n  // is a member of a descendant Range.                                                                                // 344\n                                                                                                                       // 345\n  // First check that elem is a descendant of this.parentElement,                                                      // 346\n  // according to the DOM.                                                                                             // 347\n  if (! Blaze._elementContains(this.parentElement, elem))                                                              // 348\n    return false;                                                                                                      // 349\n                                                                                                                       // 350\n  // If elem is not an immediate child of this.parentElement,                                                          // 351\n  // walk up to its ancestor that is.                                                                                  // 352\n  while (elem.parentNode !== this.parentElement)                                                                       // 353\n    elem = elem.parentNode;                                                                                            // 354\n                                                                                                                       // 355\n  var range = elem.$blaze_range;                                                                                       // 356\n  while (range && range !== this)                                                                                      // 357\n    range = range.parentRange;                                                                                         // 358\n                                                                                                                       // 359\n  return range === this;                                                                                               // 360\n};                                                                                                                     // 361\n                                                                                                                       // 362\nDOMRange.prototype.containsRange = function (range) {                                                                  // 363\n  if (! this.attached)                                                                                                 // 364\n    throw new Error(\"Must be attached\");                                                                               // 365\n                                                                                                                       // 366\n  if (! range.attached)                                                                                                // 367\n    return false;                                                                                                      // 368\n                                                                                                                       // 369\n  // A DOMRange is contained in this DOMRange if it's possible                                                         // 370\n  // to reach this range by following parent pointers.  If the                                                         // 371\n  // DOMRange has the same parentElement, then it should be                                                            // 372\n  // a member, or a member of a member etc.  Otherwise, we must                                                        // 373\n  // contain its parentElement.                                                                                        // 374\n                                                                                                                       // 375\n  if (range.parentElement !== this.parentElement)                                                                      // 376\n    return this.containsElement(range.parentElement);                                                                  // 377\n                                                                                                                       // 378\n  if (range === this)                                                                                                  // 379\n    return false; // don't contain self                                                                                // 380\n                                                                                                                       // 381\n  while (range && range !== this)                                                                                      // 382\n    range = range.parentRange;                                                                                         // 383\n                                                                                                                       // 384\n  return range === this;                                                                                               // 385\n};                                                                                                                     // 386\n                                                                                                                       // 387\nDOMRange.prototype.onAttached = function (attached) {                                                                  // 388\n  this.onAttachedDetached({ attached: attached });                                                                     // 389\n};                                                                                                                     // 390\n                                                                                                                       // 391\n// callbacks are `attached(range, element)` and                                                                        // 392\n// `detached(range, element)`, and they may                                                                            // 393\n// access the `callbacks` object in `this`.                                                                            // 394\n// The arguments to `detached` are the same                                                                            // 395\n// range and element that were passed to `attached`.                                                                   // 396\nDOMRange.prototype.onAttachedDetached = function (callbacks) {                                                         // 397\n  if (this.attachedCallbacks === _emptyArray)                                                                          // 398\n    this.attachedCallbacks = [];                                                                                       // 399\n  this.attachedCallbacks.push(callbacks);                                                                              // 400\n};                                                                                                                     // 401\n                                                                                                                       // 402\nDOMRange.prototype.$ = function (selector) {                                                                           // 403\n  var self = this;                                                                                                     // 404\n                                                                                                                       // 405\n  var parentNode = this.parentElement;                                                                                 // 406\n  if (! parentNode)                                                                                                    // 407\n    throw new Error(\"Can't select in removed DomRange\");                                                               // 408\n                                                                                                                       // 409\n  // Strategy: Find all selector matches under parentNode,                                                             // 410\n  // then filter out the ones that aren't in this DomRange                                                             // 411\n  // using `DOMRange#containsElement`.  This is                                                                        // 412\n  // asymptotically slow in the presence of O(N) sibling                                                               // 413\n  // content that is under parentNode but not in our range,                                                            // 414\n  // so if performance is an issue, the selector should be                                                             // 415\n  // run on a child element.                                                                                           // 416\n                                                                                                                       // 417\n  // Since jQuery can't run selectors on a DocumentFragment,                                                           // 418\n  // we don't expect findBySelector to work.                                                                           // 419\n  if (parentNode.nodeType === 11 /* DocumentFragment */)                                                               // 420\n    throw new Error(\"Can't use $ on an offscreen range\");                                                              // 421\n                                                                                                                       // 422\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode);                                                // 423\n                                                                                                                       // 424\n  // We don't assume `results` has jQuery API; a plain array                                                           // 425\n  // should do just as well.  However, if we do have a jQuery                                                          // 426\n  // array, we want to end up with one also, so we use                                                                 // 427\n  // `.filter`.                                                                                                        // 428\n                                                                                                                       // 429\n  // Function that selects only elements that are actually                                                             // 430\n  // in this DomRange, rather than simply descending from                                                              // 431\n  // `parentNode`.                                                                                                     // 432\n  var filterFunc = function (elem) {                                                                                   // 433\n    // handle jQuery's arguments to filter, where the node                                                             // 434\n    // is in `this` and the index is the first argument.                                                               // 435\n    if (typeof elem === 'number')                                                                                      // 436\n      elem = this;                                                                                                     // 437\n                                                                                                                       // 438\n    return self.containsElement(elem);                                                                                 // 439\n  };                                                                                                                   // 440\n                                                                                                                       // 441\n  if (! results.filter) {                                                                                              // 442\n    // not a jQuery array, and not a browser with                                                                      // 443\n    // Array.prototype.filter (e.g. IE <9)                                                                             // 444\n    var newResults = [];                                                                                               // 445\n    for (var i = 0; i < results.length; i++) {                                                                         // 446\n      var x = results[i];                                                                                              // 447\n      if (filterFunc(x))                                                                                               // 448\n        newResults.push(x);                                                                                            // 449\n    }                                                                                                                  // 450\n    results = newResults;                                                                                              // 451\n  } else {                                                                                                             // 452\n    // `results.filter` is either jQuery's or ECMAScript's `filter`                                                    // 453\n    results = results.filter(filterFunc);                                                                              // 454\n  }                                                                                                                    // 455\n                                                                                                                       // 456\n  return results;                                                                                                      // 457\n};                                                                                                                     // 458\n                                                                                                                       // 459\n// Returns true if element a contains node b and is not node b.                                                        // 460\n//                                                                                                                     // 461\n// The restriction that `a` be an element (not a document fragment,                                                    // 462\n// say) is based on what's easy to implement cross-browser.                                                            // 463\nBlaze._elementContains = function (a, b) {                                                                             // 464\n  if (a.nodeType !== 1) // ELEMENT                                                                                     // 465\n    return false;                                                                                                      // 466\n  if (a === b)                                                                                                         // 467\n    return false;                                                                                                      // 468\n                                                                                                                       // 469\n  if (a.compareDocumentPosition) {                                                                                     // 470\n    return a.compareDocumentPosition(b) & 0x10;                                                                        // 471\n  } else {                                                                                                             // 472\n    // Should be only old IE and maybe other old browsers here.                                                        // 473\n    // Modern Safari has both functions but seems to get contains() wrong.                                             // 474\n    // IE can't handle b being a text node.  We work around this                                                       // 475\n    // by doing a direct parent test now.                                                                              // 476\n    b = b.parentNode;                                                                                                  // 477\n    if (! (b && b.nodeType === 1)) // ELEMENT                                                                          // 478\n      return false;                                                                                                    // 479\n    if (a === b)                                                                                                       // 480\n      return true;                                                                                                     // 481\n                                                                                                                       // 482\n    return a.contains(b);                                                                                              // 483\n  }                                                                                                                    // 484\n};                                                                                                                     // 485\n                                                                                                                       // 486\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/events.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar EventSupport = Blaze._EventSupport = {};                                                                           // 1\n                                                                                                                       // 2\nvar DOMBackend = Blaze._DOMBackend;                                                                                    // 3\n                                                                                                                       // 4\n// List of events to always delegate, never capture.                                                                   // 5\n// Since jQuery fakes bubbling for certain events in                                                                   // 6\n// certain browsers (like `submit`), we don't want to                                                                  // 7\n// get in its way.                                                                                                     // 8\n//                                                                                                                     // 9\n// We could list all known bubbling                                                                                    // 10\n// events here to avoid creating speculative capturers                                                                 // 11\n// for them, but it would only be an optimization.                                                                     // 12\nvar eventsToDelegate = EventSupport.eventsToDelegate = {                                                               // 13\n  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,                                                                  // 14\n  focusout: 1, reset: 1, submit: 1                                                                                     // 15\n};                                                                                                                     // 16\n                                                                                                                       // 17\nvar EVENT_MODE = EventSupport.EVENT_MODE = {                                                                           // 18\n  TBD: 0,                                                                                                              // 19\n  BUBBLING: 1,                                                                                                         // 20\n  CAPTURING: 2                                                                                                         // 21\n};                                                                                                                     // 22\n                                                                                                                       // 23\nvar NEXT_HANDLERREC_ID = 1;                                                                                            // 24\n                                                                                                                       // 25\nvar HandlerRec = function (elem, type, selector, handler, recipient) {                                                 // 26\n  this.elem = elem;                                                                                                    // 27\n  this.type = type;                                                                                                    // 28\n  this.selector = selector;                                                                                            // 29\n  this.handler = handler;                                                                                              // 30\n  this.recipient = recipient;                                                                                          // 31\n  this.id = (NEXT_HANDLERREC_ID++);                                                                                    // 32\n                                                                                                                       // 33\n  this.mode = EVENT_MODE.TBD;                                                                                          // 34\n                                                                                                                       // 35\n  // It's important that delegatedHandler be a different                                                               // 36\n  // instance for each handlerRecord, because its identity                                                             // 37\n  // is used to remove it.                                                                                             // 38\n  //                                                                                                                   // 39\n  // It's also important that the closure have access to                                                               // 40\n  // `this` when it is not called with it set.                                                                         // 41\n  this.delegatedHandler = (function (h) {                                                                              // 42\n    return function (evt) {                                                                                            // 43\n      if ((! h.selector) && evt.currentTarget !== evt.target)                                                          // 44\n        // no selector means only fire on target                                                                       // 45\n        return;                                                                                                        // 46\n      return h.handler.apply(h.recipient, arguments);                                                                  // 47\n    };                                                                                                                 // 48\n  })(this);                                                                                                            // 49\n                                                                                                                       // 50\n  // WHY CAPTURE AND DELEGATE: jQuery can't delegate                                                                   // 51\n  // non-bubbling events, because                                                                                      // 52\n  // event capture doesn't work in IE 8.  However, there                                                               // 53\n  // are all sorts of new-fangled non-bubbling events                                                                  // 54\n  // like \"play\" and \"touchenter\".  We delegate these                                                                  // 55\n  // events using capture in all browsers except IE 8.                                                                 // 56\n  // IE 8 doesn't support these events anyway.                                                                         // 57\n                                                                                                                       // 58\n  var tryCapturing = elem.addEventListener &&                                                                          // 59\n        (! _.has(eventsToDelegate,                                                                                     // 60\n                 DOMBackend.Events.parseEventType(type)));                                                             // 61\n                                                                                                                       // 62\n  if (tryCapturing) {                                                                                                  // 63\n    this.capturingHandler = (function (h) {                                                                            // 64\n      return function (evt) {                                                                                          // 65\n        if (h.mode === EVENT_MODE.TBD) {                                                                               // 66\n          // must be first time we're called.                                                                          // 67\n          if (evt.bubbles) {                                                                                           // 68\n            // this type of event bubbles, so don't                                                                    // 69\n            // get called again.                                                                                       // 70\n            h.mode = EVENT_MODE.BUBBLING;                                                                              // 71\n            DOMBackend.Events.unbindEventCapturer(                                                                     // 72\n              h.elem, h.type, h.capturingHandler);                                                                     // 73\n            return;                                                                                                    // 74\n          } else {                                                                                                     // 75\n            // this type of event doesn't bubble,                                                                      // 76\n            // so unbind the delegation, preventing                                                                    // 77\n            // it from ever firing.                                                                                    // 78\n            h.mode = EVENT_MODE.CAPTURING;                                                                             // 79\n            DOMBackend.Events.undelegateEvents(                                                                        // 80\n              h.elem, h.type, h.delegatedHandler);                                                                     // 81\n          }                                                                                                            // 82\n        }                                                                                                              // 83\n                                                                                                                       // 84\n        h.delegatedHandler(evt);                                                                                       // 85\n      };                                                                                                               // 86\n    })(this);                                                                                                          // 87\n                                                                                                                       // 88\n  } else {                                                                                                             // 89\n    this.mode = EVENT_MODE.BUBBLING;                                                                                   // 90\n  }                                                                                                                    // 91\n};                                                                                                                     // 92\nEventSupport.HandlerRec = HandlerRec;                                                                                  // 93\n                                                                                                                       // 94\nHandlerRec.prototype.bind = function () {                                                                              // 95\n  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in                                                 // 96\n  // this case, 'capturingHandler' is in charge of detecting the                                                       // 97\n  // correct mode and turning off one or the other handlers.                                                           // 98\n  if (this.mode !== EVENT_MODE.BUBBLING) {                                                                             // 99\n    DOMBackend.Events.bindEventCapturer(                                                                               // 100\n      this.elem, this.type, this.selector || '*',                                                                      // 101\n      this.capturingHandler);                                                                                          // 102\n  }                                                                                                                    // 103\n                                                                                                                       // 104\n  if (this.mode !== EVENT_MODE.CAPTURING)                                                                              // 105\n    DOMBackend.Events.delegateEvents(                                                                                  // 106\n      this.elem, this.type,                                                                                            // 107\n      this.selector || '*', this.delegatedHandler);                                                                    // 108\n};                                                                                                                     // 109\n                                                                                                                       // 110\nHandlerRec.prototype.unbind = function () {                                                                            // 111\n  if (this.mode !== EVENT_MODE.BUBBLING)                                                                               // 112\n    DOMBackend.Events.unbindEventCapturer(this.elem, this.type,                                                        // 113\n                                          this.capturingHandler);                                                      // 114\n                                                                                                                       // 115\n  if (this.mode !== EVENT_MODE.CAPTURING)                                                                              // 116\n    DOMBackend.Events.undelegateEvents(this.elem, this.type,                                                           // 117\n                                       this.delegatedHandler);                                                         // 118\n};                                                                                                                     // 119\n                                                                                                                       // 120\nEventSupport.listen = function (element, events, selector, handler, recipient, getParentRecipient) {                   // 121\n                                                                                                                       // 122\n  // Prevent this method from being JITed by Safari.  Due to a                                                         // 123\n  // presumed JIT bug in Safari -- observed in Version 7.0.6                                                           // 124\n  // (9537.78.2) -- this method may crash the Safari render process if                                                 // 125\n  // it is JITed.                                                                                                      // 126\n  // Repro: https://github.com/dgreensp/public/tree/master/safari-crash                                                // 127\n  try { element = element; } finally {}                                                                                // 128\n                                                                                                                       // 129\n  var eventTypes = [];                                                                                                 // 130\n  events.replace(/[^ /]+/g, function (e) {                                                                             // 131\n    eventTypes.push(e);                                                                                                // 132\n  });                                                                                                                  // 133\n                                                                                                                       // 134\n  var newHandlerRecs = [];                                                                                             // 135\n  for (var i = 0, N = eventTypes.length; i < N; i++) {                                                                 // 136\n    var type = eventTypes[i];                                                                                          // 137\n                                                                                                                       // 138\n    var eventDict = element.$blaze_events;                                                                             // 139\n    if (! eventDict)                                                                                                   // 140\n      eventDict = (element.$blaze_events = {});                                                                        // 141\n                                                                                                                       // 142\n    var info = eventDict[type];                                                                                        // 143\n    if (! info) {                                                                                                      // 144\n      info = eventDict[type] = {};                                                                                     // 145\n      info.handlers = [];                                                                                              // 146\n    }                                                                                                                  // 147\n    var handlerList = info.handlers;                                                                                   // 148\n    var handlerRec = new HandlerRec(                                                                                   // 149\n      element, type, selector, handler, recipient);                                                                    // 150\n    newHandlerRecs.push(handlerRec);                                                                                   // 151\n    handlerRec.bind();                                                                                                 // 152\n    handlerList.push(handlerRec);                                                                                      // 153\n    // Move handlers of enclosing ranges to end, by unbinding and rebinding                                            // 154\n    // them.  In jQuery (or other DOMBackend) this causes them to fire                                                 // 155\n    // later when the backend dispatches event handlers.                                                               // 156\n    if (getParentRecipient) {                                                                                          // 157\n      for (var r = getParentRecipient(recipient); r;                                                                   // 158\n           r = getParentRecipient(r)) {                                                                                // 159\n        // r is an enclosing range (recipient)                                                                         // 160\n        for (var j = 0, Nj = handlerList.length;                                                                       // 161\n             j < Nj; j++) {                                                                                            // 162\n          var h = handlerList[j];                                                                                      // 163\n          if (h.recipient === r) {                                                                                     // 164\n            h.unbind();                                                                                                // 165\n            h.bind();                                                                                                  // 166\n            handlerList.splice(j, 1); // remove handlerList[j]                                                         // 167\n            handlerList.push(h);                                                                                       // 168\n            j--; // account for removed handler                                                                        // 169\n            Nj--; // don't visit appended handlers                                                                     // 170\n          }                                                                                                            // 171\n        }                                                                                                              // 172\n      }                                                                                                                // 173\n    }                                                                                                                  // 174\n  }                                                                                                                    // 175\n                                                                                                                       // 176\n  return {                                                                                                             // 177\n    // closes over just `element` and `newHandlerRecs`                                                                 // 178\n    stop: function () {                                                                                                // 179\n      var eventDict = element.$blaze_events;                                                                           // 180\n      if (! eventDict)                                                                                                 // 181\n        return;                                                                                                        // 182\n      // newHandlerRecs has only one item unless you specify multiple                                                  // 183\n      // event types.  If this code is slow, it's because we have to                                                   // 184\n      // iterate over handlerList here.  Clearing a whole handlerList                                                  // 185\n      // via stop() methods is O(N^2) in the number of handlers on                                                     // 186\n      // an element.                                                                                                   // 187\n      for (var i = 0; i < newHandlerRecs.length; i++) {                                                                // 188\n        var handlerToRemove = newHandlerRecs[i];                                                                       // 189\n        var info = eventDict[handlerToRemove.type];                                                                    // 190\n        if (! info)                                                                                                    // 191\n          continue;                                                                                                    // 192\n        var handlerList = info.handlers;                                                                               // 193\n        for (var j = handlerList.length - 1; j >= 0; j--) {                                                            // 194\n          if (handlerList[j] === handlerToRemove) {                                                                    // 195\n            handlerToRemove.unbind();                                                                                  // 196\n            handlerList.splice(j, 1); // remove handlerList[j]                                                         // 197\n          }                                                                                                            // 198\n        }                                                                                                              // 199\n      }                                                                                                                // 200\n      newHandlerRecs.length = 0;                                                                                       // 201\n    }                                                                                                                  // 202\n  };                                                                                                                   // 203\n};                                                                                                                     // 204\n                                                                                                                       // 205\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/attrs.js                                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar jsUrlsAllowed = false;                                                                                             // 1\nBlaze._allowJavascriptUrls = function () {                                                                             // 2\n  jsUrlsAllowed = true;                                                                                                // 3\n};                                                                                                                     // 4\nBlaze._javascriptUrlsAllowed = function () {                                                                           // 5\n  return jsUrlsAllowed;                                                                                                // 6\n};                                                                                                                     // 7\n                                                                                                                       // 8\n// An AttributeHandler object is responsible for updating a particular attribute                                       // 9\n// of a particular element.  AttributeHandler subclasses implement                                                     // 10\n// browser-specific logic for dealing with particular attributes across                                                // 11\n// different browsers.                                                                                                 // 12\n//                                                                                                                     // 13\n// To define a new type of AttributeHandler, use                                                                       // 14\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`                                                // 15\n// where the `update` function takes arguments `(element, oldValue, value)`.                                           // 16\n// The `element` argument is always the same between calls to `update` on                                              // 17\n// the same instance.  `oldValue` and `value` are each either `null` or                                                // 18\n// a Unicode string of the type that might be passed to the value argument                                             // 19\n// of `setAttribute` (i.e. not an HTML string with character references).                                              // 20\n// When an AttributeHandler is installed, an initial call to `update` is                                               // 21\n// always made with `oldValue = null`.  The `update` method can access                                                 // 22\n// `this.name` if the AttributeHandler class is a generic one that applies                                             // 23\n// to multiple attribute names.                                                                                        // 24\n//                                                                                                                     // 25\n// AttributeHandlers can store custom properties on `this`, as long as they                                            // 26\n// don't use the names `element`, `name`, `value`, and `oldValue`.                                                     // 27\n//                                                                                                                     // 28\n// AttributeHandlers can't influence how attributes appear in rendered HTML,                                           // 29\n// only how they are updated after materialization as DOM.                                                             // 30\n                                                                                                                       // 31\nAttributeHandler = function (name, value) {                                                                            // 32\n  this.name = name;                                                                                                    // 33\n  this.value = value;                                                                                                  // 34\n};                                                                                                                     // 35\nBlaze._AttributeHandler = AttributeHandler;                                                                            // 36\n                                                                                                                       // 37\nAttributeHandler.prototype.update = function (element, oldValue, value) {                                              // 38\n  if (value === null) {                                                                                                // 39\n    if (oldValue !== null)                                                                                             // 40\n      element.removeAttribute(this.name);                                                                              // 41\n  } else {                                                                                                             // 42\n    element.setAttribute(this.name, value);                                                                            // 43\n  }                                                                                                                    // 44\n};                                                                                                                     // 45\n                                                                                                                       // 46\nAttributeHandler.extend = function (options) {                                                                         // 47\n  var curType = this;                                                                                                  // 48\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {                                                      // 49\n    AttributeHandler.apply(this, arguments);                                                                           // 50\n  };                                                                                                                   // 51\n  subType.prototype = new curType;                                                                                     // 52\n  subType.extend = curType.extend;                                                                                     // 53\n  if (options)                                                                                                         // 54\n    _.extend(subType.prototype, options);                                                                              // 55\n  return subType;                                                                                                      // 56\n};                                                                                                                     // 57\n                                                                                                                       // 58\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"                                      // 59\n//                                                                                                                     // 60\n// Each subclass must implement a parseValue method which takes a string                                               // 61\n// as an input and returns a dict of attributes. The keys of the dict                                                  // 62\n// are unique identifiers (ie. css properties in the case of styles), and the                                          // 63\n// values are the entire attribute which will be injected into the element.                                            // 64\n//                                                                                                                     // 65\n// Extended below to support classes, SVG elements and styles.                                                         // 66\n                                                                                                                       // 67\nvar DiffingAttributeHandler = AttributeHandler.extend({                                                                // 68\n  update: function (element, oldValue, value) {                                                                        // 69\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)                                                   // 70\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");                                     // 71\n                                                                                                                       // 72\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};                                                       // 73\n    var newAttrsMap = value ? this.parseValue(value) : {};                                                             // 74\n                                                                                                                       // 75\n    // the current attributes on the element, which we will mutate.                                                    // 76\n                                                                                                                       // 77\n    var attrString = this.getCurrentValue(element);                                                                    // 78\n    var attrsMap = attrString ? this.parseValue(attrString) : {};                                                      // 79\n                                                                                                                       // 80\n    _.each(_.keys(oldAttrsMap), function (t) {                                                                         // 81\n      if (! (t in newAttrsMap))                                                                                        // 82\n        delete attrsMap[t];                                                                                            // 83\n    });                                                                                                                // 84\n                                                                                                                       // 85\n    _.each(_.keys(newAttrsMap), function (t) {                                                                         // 86\n      attrsMap[t] = newAttrsMap[t];                                                                                    // 87\n    });                                                                                                                // 88\n                                                                                                                       // 89\n    this.setValue(element, _.values(attrsMap).join(' '));                                                              // 90\n  }                                                                                                                    // 91\n});                                                                                                                    // 92\n                                                                                                                       // 93\nvar ClassHandler = DiffingAttributeHandler.extend({                                                                    // 94\n  // @param rawValue {String}                                                                                          // 95\n  getCurrentValue: function (element) {                                                                                // 96\n    return element.className;                                                                                          // 97\n  },                                                                                                                   // 98\n  setValue: function (element, className) {                                                                            // 99\n    element.className = className;                                                                                     // 100\n  },                                                                                                                   // 101\n  parseValue: function (attrString) {                                                                                  // 102\n    var tokens = {};                                                                                                   // 103\n                                                                                                                       // 104\n    _.each(attrString.split(' '), function(token) {                                                                    // 105\n      if (token)                                                                                                       // 106\n        tokens[token] = token;                                                                                         // 107\n    });                                                                                                                // 108\n    return tokens;                                                                                                     // 109\n  }                                                                                                                    // 110\n});                                                                                                                    // 111\n                                                                                                                       // 112\nvar SVGClassHandler = ClassHandler.extend({                                                                            // 113\n  getCurrentValue: function (element) {                                                                                // 114\n    return element.className.baseVal;                                                                                  // 115\n  },                                                                                                                   // 116\n  setValue: function (element, className) {                                                                            // 117\n    element.setAttribute('class', className);                                                                          // 118\n  }                                                                                                                    // 119\n});                                                                                                                    // 120\n                                                                                                                       // 121\nvar StyleHandler = DiffingAttributeHandler.extend({                                                                    // 122\n  getCurrentValue: function (element) {                                                                                // 123\n    return element.getAttribute('style');                                                                              // 124\n  },                                                                                                                   // 125\n  setValue: function (element, style) {                                                                                // 126\n    if (style === '') {                                                                                                // 127\n      element.removeAttribute('style');                                                                                // 128\n    } else {                                                                                                           // 129\n      element.setAttribute('style', style);                                                                            // 130\n    }                                                                                                                  // 131\n  },                                                                                                                   // 132\n                                                                                                                       // 133\n  // Parse a string to produce a map from property to attribute string.                                                // 134\n  //                                                                                                                   // 135\n  // Example:                                                                                                          // 136\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}                                       // 137\n  parseValue: function (attrString) {                                                                                  // 138\n    var tokens = {};                                                                                                   // 139\n                                                                                                                       // 140\n    // Regex for parsing a css attribute declaration, taken from css-parse:                                            // 141\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219              // 142\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\n    var match = regex.exec(attrString);                                                                                // 144\n    while (match) {                                                                                                    // 145\n      // match[0] = entire matching string                                                                             // 146\n      // match[1] = css property                                                                                       // 147\n      // Prefix the token to prevent conflicts with existing properties.                                               // 148\n                                                                                                                       // 149\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to                                               // 150\n      // remove strong dep on jquery.                                                                                  // 151\n      tokens[' ' + match[1]] = match[0].trim ?                                                                         // 152\n        match[0].trim() : $.trim(match[0]);                                                                            // 153\n                                                                                                                       // 154\n      match = regex.exec(attrString);                                                                                  // 155\n    }                                                                                                                  // 156\n                                                                                                                       // 157\n    return tokens;                                                                                                     // 158\n  }                                                                                                                    // 159\n});                                                                                                                    // 160\n                                                                                                                       // 161\nvar BooleanHandler = AttributeHandler.extend({                                                                         // 162\n  update: function (element, oldValue, value) {                                                                        // 163\n    var name = this.name;                                                                                              // 164\n    if (value == null) {                                                                                               // 165\n      if (oldValue != null)                                                                                            // 166\n        element[name] = false;                                                                                         // 167\n    } else {                                                                                                           // 168\n      element[name] = true;                                                                                            // 169\n    }                                                                                                                  // 170\n  }                                                                                                                    // 171\n});                                                                                                                    // 172\n                                                                                                                       // 173\nvar DOMPropertyHandler = AttributeHandler.extend({                                                                     // 174\n  update: function (element, oldValue, value) {                                                                        // 175\n    var name = this.name;                                                                                              // 176\n    if (value !== element[name])                                                                                       // 177\n      element[name] = value;                                                                                           // 178\n  }                                                                                                                    // 179\n});                                                                                                                    // 180\n                                                                                                                       // 181\n// attributes of the type 'xlink:something' should be set using                                                        // 182\n// the correct namespace in order to work                                                                              // 183\nvar XlinkHandler = AttributeHandler.extend({                                                                           // 184\n  update: function(element, oldValue, value) {                                                                         // 185\n    var NS = 'http://www.w3.org/1999/xlink';                                                                           // 186\n    if (value === null) {                                                                                              // 187\n      if (oldValue !== null)                                                                                           // 188\n        element.removeAttributeNS(NS, this.name);                                                                      // 189\n    } else {                                                                                                           // 190\n      element.setAttributeNS(NS, this.name, this.value);                                                               // 191\n    }                                                                                                                  // 192\n  }                                                                                                                    // 193\n});                                                                                                                    // 194\n                                                                                                                       // 195\n// cross-browser version of `instanceof SVGElement`                                                                    // 196\nvar isSVGElement = function (elem) {                                                                                   // 197\n  return 'ownerSVGElement' in elem;                                                                                    // 198\n};                                                                                                                     // 199\n                                                                                                                       // 200\nvar isUrlAttribute = function (tagName, attrName) {                                                                    // 201\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html                                               // 202\n  // and                                                                                                               // 203\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1                                              // 204\n  var urlAttrs = {                                                                                                     // 205\n    FORM: ['action'],                                                                                                  // 206\n    BODY: ['background'],                                                                                              // 207\n    BLOCKQUOTE: ['cite'],                                                                                              // 208\n    Q: ['cite'],                                                                                                       // 209\n    DEL: ['cite'],                                                                                                     // 210\n    INS: ['cite'],                                                                                                     // 211\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],                                                                 // 212\n    APPLET: ['codebase'],                                                                                              // 213\n    A: ['href'],                                                                                                       // 214\n    AREA: ['href'],                                                                                                    // 215\n    LINK: ['href'],                                                                                                    // 216\n    BASE: ['href'],                                                                                                    // 217\n    IMG: ['longdesc', 'src', 'usemap'],                                                                                // 218\n    FRAME: ['longdesc', 'src'],                                                                                        // 219\n    IFRAME: ['longdesc', 'src'],                                                                                       // 220\n    HEAD: ['profile'],                                                                                                 // 221\n    SCRIPT: ['src'],                                                                                                   // 222\n    INPUT: ['src', 'usemap', 'formaction'],                                                                            // 223\n    BUTTON: ['formaction'],                                                                                            // 224\n    BASE: ['href'],                                                                                                    // 225\n    MENUITEM: ['icon'],                                                                                                // 226\n    HTML: ['manifest'],                                                                                                // 227\n    VIDEO: ['poster']                                                                                                  // 228\n  };                                                                                                                   // 229\n                                                                                                                       // 230\n  if (attrName === 'itemid') {                                                                                         // 231\n    return true;                                                                                                       // 232\n  }                                                                                                                    // 233\n                                                                                                                       // 234\n  var urlAttrNames = urlAttrs[tagName] || [];                                                                          // 235\n  return _.contains(urlAttrNames, attrName);                                                                           // 236\n};                                                                                                                     // 237\n                                                                                                                       // 238\n// To get the protocol for a URL, we let the browser normalize it for                                                  // 239\n// us, by setting it as the href for an anchor tag and then reading out                                                // 240\n// the 'protocol' property.                                                                                            // 241\nif (Meteor.isClient) {                                                                                                 // 242\n  var anchorForNormalization = document.createElement('A');                                                            // 243\n}                                                                                                                      // 244\n                                                                                                                       // 245\nvar getUrlProtocol = function (url) {                                                                                  // 246\n  if (Meteor.isClient) {                                                                                               // 247\n    anchorForNormalization.href = url;                                                                                 // 248\n    return (anchorForNormalization.protocol || \"\").toLowerCase();                                                      // 249\n  } else {                                                                                                             // 250\n    throw new Error('getUrlProtocol not implemented on the server');                                                   // 251\n  }                                                                                                                    // 252\n};                                                                                                                     // 253\n                                                                                                                       // 254\n// UrlHandler is an attribute handler for all HTML attributes that take                                                // 255\n// URL values. It disallows javascript: URLs, unless                                                                   // 256\n// Blaze._allowJavascriptUrls() has been called. To detect javascript:                                                 // 257\n// urls, we set the attribute on a dummy anchor element and then read                                                  // 258\n// out the 'protocol' property of the attribute.                                                                       // 259\nvar origUpdate = AttributeHandler.prototype.update;                                                                    // 260\nvar UrlHandler = AttributeHandler.extend({                                                                             // 261\n  update: function (element, oldValue, value) {                                                                        // 262\n    var self = this;                                                                                                   // 263\n    var args = arguments;                                                                                              // 264\n                                                                                                                       // 265\n    if (Blaze._javascriptUrlsAllowed()) {                                                                              // 266\n      origUpdate.apply(self, args);                                                                                    // 267\n    } else {                                                                                                           // 268\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");                                            // 269\n      if (isJavascriptProtocol) {                                                                                      // 270\n        Blaze._warn(\"URLs that use the 'javascript:' protocol are not \" +                                              // 271\n                    \"allowed in URL attribute values. \" +                                                              // 272\n                    \"Call Blaze._allowJavascriptUrls() \" +                                                             // 273\n                    \"to enable them.\");                                                                                // 274\n        origUpdate.apply(self, [element, oldValue, null]);                                                             // 275\n      } else {                                                                                                         // 276\n        origUpdate.apply(self, args);                                                                                  // 277\n      }                                                                                                                // 278\n    }                                                                                                                  // 279\n  }                                                                                                                    // 280\n});                                                                                                                    // 281\n                                                                                                                       // 282\n// XXX make it possible for users to register attribute handlers!                                                      // 283\nmakeAttributeHandler = function (elem, name, value) {                                                                  // 284\n  // generally, use setAttribute but certain attributes need to be set                                                 // 285\n  // by directly setting a JavaScript property on the DOM element.                                                     // 286\n  if (name === 'class') {                                                                                              // 287\n    if (isSVGElement(elem)) {                                                                                          // 288\n      return new SVGClassHandler(name, value);                                                                         // 289\n    } else {                                                                                                           // 290\n      return new ClassHandler(name, value);                                                                            // 291\n    }                                                                                                                  // 292\n  } else if (name === 'style') {                                                                                       // 293\n    return new StyleHandler(name, value);                                                                              // 294\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||                                                     // 295\n             (elem.tagName === 'INPUT' && name === 'checked')) {                                                       // 296\n    return new BooleanHandler(name, value);                                                                            // 297\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')                                                 // 298\n             && name === 'value') {                                                                                    // 299\n    // internally, TEXTAREAs tracks their value in the 'value'                                                         // 300\n    // attribute just like INPUTs.                                                                                     // 301\n    return new DOMPropertyHandler(name, value);                                                                        // 302\n  } else if (name.substring(0,6) === 'xlink:') {                                                                       // 303\n    return new XlinkHandler(name.substring(6), value);                                                                 // 304\n  } else if (isUrlAttribute(elem.tagName, name)) {                                                                     // 305\n    return new UrlHandler(name, value);                                                                                // 306\n  } else {                                                                                                             // 307\n    return new AttributeHandler(name, value);                                                                          // 308\n  }                                                                                                                    // 309\n                                                                                                                       // 310\n  // XXX will need one for 'style' on IE, though modern browsers                                                       // 311\n  // seem to handle setAttribute ok.                                                                                   // 312\n};                                                                                                                     // 313\n                                                                                                                       // 314\n                                                                                                                       // 315\nElementAttributesUpdater = function (elem) {                                                                           // 316\n  this.elem = elem;                                                                                                    // 317\n  this.handlers = {};                                                                                                  // 318\n};                                                                                                                     // 319\n                                                                                                                       // 320\n// Update attributes on `elem` to the dictionary `attrs`, whose                                                        // 321\n// values are strings.                                                                                                 // 322\nElementAttributesUpdater.prototype.update = function(newAttrs) {                                                       // 323\n  var elem = this.elem;                                                                                                // 324\n  var handlers = this.handlers;                                                                                        // 325\n                                                                                                                       // 326\n  for (var k in handlers) {                                                                                            // 327\n    if (! _.has(newAttrs, k)) {                                                                                        // 328\n      // remove attributes (and handlers) for attribute names                                                          // 329\n      // that don't exist as keys of `newAttrs` and so won't                                                           // 330\n      // be visited when traversing it.  (Attributes that                                                              // 331\n      // exist in the `newAttrs` object but are `null`                                                                 // 332\n      // are handled later.)                                                                                           // 333\n      var handler = handlers[k];                                                                                       // 334\n      var oldValue = handler.value;                                                                                    // 335\n      handler.value = null;                                                                                            // 336\n      handler.update(elem, oldValue, null);                                                                            // 337\n      delete handlers[k];                                                                                              // 338\n    }                                                                                                                  // 339\n  }                                                                                                                    // 340\n                                                                                                                       // 341\n  for (var k in newAttrs) {                                                                                            // 342\n    var handler = null;                                                                                                // 343\n    var oldValue;                                                                                                      // 344\n    var value = newAttrs[k];                                                                                           // 345\n    if (! _.has(handlers, k)) {                                                                                        // 346\n      if (value !== null) {                                                                                            // 347\n        // make new handler                                                                                            // 348\n        handler = makeAttributeHandler(elem, k, value);                                                                // 349\n        handlers[k] = handler;                                                                                         // 350\n        oldValue = null;                                                                                               // 351\n      }                                                                                                                // 352\n    } else {                                                                                                           // 353\n      handler = handlers[k];                                                                                           // 354\n      oldValue = handler.value;                                                                                        // 355\n    }                                                                                                                  // 356\n    if (oldValue !== value) {                                                                                          // 357\n      handler.value = value;                                                                                           // 358\n      handler.update(elem, oldValue, value);                                                                           // 359\n      if (value === null)                                                                                              // 360\n        delete handlers[k];                                                                                            // 361\n    }                                                                                                                  // 362\n  }                                                                                                                    // 363\n};                                                                                                                     // 364\n                                                                                                                       // 365\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/materializer.js                                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Turns HTMLjs into DOM nodes and DOMRanges.                                                                          // 1\n//                                                                                                                     // 2\n// - `htmljs`: the value to materialize, which may be any of the htmljs                                                // 3\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,                                                // 4\n//   null, or undefined) or a View or Template (which will be used to                                                  // 5\n//   construct a View).                                                                                                // 6\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output                                              // 7\n//   into (required)                                                                                                   // 8\n// - `parentView`: the View we are materializing content for (optional)                                                // 9\n// - `_existingWorkStack`: optional argument, only used for recursive                                                  // 10\n//   calls when there is some other _materializeDOM on the call stack.                                                 // 11\n//   If _materializeDOM called your function and passed in a workStack,                                                // 12\n//   pass it back when you call _materializeDOM (such as from a workStack                                              // 13\n//   task).                                                                                                            // 14\n//                                                                                                                     // 15\n// Returns `intoArray`, which is especially useful if you pass in `[]`.                                                // 16\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,                                                       // 17\n                                  _existingWorkStack) {                                                                // 18\n  // In order to use fewer stack frames, materializeDOMInner can push                                                  // 19\n  // tasks onto `workStack`, and they will be popped off                                                               // 20\n  // and run, last first, after materializeDOMInner returns.  The                                                      // 21\n  // reason we use a stack instead of a queue is so that we recurse                                                    // 22\n  // depth-first, doing newer tasks first.                                                                             // 23\n  var workStack = (_existingWorkStack || []);                                                                          // 24\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);                                                       // 25\n                                                                                                                       // 26\n  if (! _existingWorkStack) {                                                                                          // 27\n    // We created the work stack, so we are responsible for finishing                                                  // 28\n    // the work.  Call each \"task\" function, starting with the top                                                     // 29\n    // of the stack.                                                                                                   // 30\n    while (workStack.length) {                                                                                         // 31\n      // Note that running task() may push new items onto workStack.                                                   // 32\n      var task = workStack.pop();                                                                                      // 33\n      task();                                                                                                          // 34\n    }                                                                                                                  // 35\n  }                                                                                                                    // 36\n                                                                                                                       // 37\n  return intoArray;                                                                                                    // 38\n};                                                                                                                     // 39\n                                                                                                                       // 40\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {                                        // 41\n  if (htmljs == null) {                                                                                                // 42\n    // null or undefined                                                                                               // 43\n    return;                                                                                                            // 44\n  }                                                                                                                    // 45\n                                                                                                                       // 46\n  switch (typeof htmljs) {                                                                                             // 47\n  case 'string': case 'boolean': case 'number':                                                                        // 48\n    intoArray.push(document.createTextNode(String(htmljs)));                                                           // 49\n    return;                                                                                                            // 50\n  case 'object':                                                                                                       // 51\n    if (htmljs.htmljsType) {                                                                                           // 52\n      switch (htmljs.htmljsType) {                                                                                     // 53\n      case HTML.Tag.htmljsType:                                                                                        // 54\n        intoArray.push(materializeTag(htmljs, parentView, workStack));                                                 // 55\n        return;                                                                                                        // 56\n      case HTML.CharRef.htmljsType:                                                                                    // 57\n        intoArray.push(document.createTextNode(htmljs.str));                                                           // 58\n        return;                                                                                                        // 59\n      case HTML.Comment.htmljsType:                                                                                    // 60\n        intoArray.push(document.createComment(htmljs.sanitizedValue));                                                 // 61\n        return;                                                                                                        // 62\n      case HTML.Raw.htmljsType:                                                                                        // 63\n        // Get an array of DOM nodes by using the browser's HTML parser                                                // 64\n        // (like innerHTML).                                                                                           // 65\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);                                                         // 66\n        for (var i = 0; i < nodes.length; i++)                                                                         // 67\n          intoArray.push(nodes[i]);                                                                                    // 68\n        return;                                                                                                        // 69\n      }                                                                                                                // 70\n    } else if (HTML.isArray(htmljs)) {                                                                                 // 71\n      for (var i = htmljs.length-1; i >= 0; i--) {                                                                     // 72\n        workStack.push(_.bind(Blaze._materializeDOM, null,                                                             // 73\n                              htmljs[i], intoArray, parentView, workStack));                                           // 74\n      }                                                                                                                // 75\n      return;                                                                                                          // 76\n    } else {                                                                                                           // 77\n      if (htmljs instanceof Blaze.Template) {                                                                          // 78\n        htmljs = htmljs.constructView();                                                                               // 79\n        // fall through to Blaze.View case below                                                                       // 80\n      }                                                                                                                // 81\n      if (htmljs instanceof Blaze.View) {                                                                              // 82\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);                                              // 83\n        return;                                                                                                        // 84\n      }                                                                                                                // 85\n    }                                                                                                                  // 86\n  }                                                                                                                    // 87\n                                                                                                                       // 88\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);                                                           // 89\n};                                                                                                                     // 90\n                                                                                                                       // 91\nvar materializeTag = function (tag, parentView, workStack) {                                                           // 92\n  var tagName = tag.tagName;                                                                                           // 93\n  var elem;                                                                                                            // 94\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))                                                            // 95\n      && document.createElementNS) {                                                                                   // 96\n    // inline SVG                                                                                                      // 97\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);                                            // 98\n  } else {                                                                                                             // 99\n    // normal elements                                                                                                 // 100\n    elem = document.createElement(tagName);                                                                            // 101\n  }                                                                                                                    // 102\n                                                                                                                       // 103\n  var rawAttrs = tag.attrs;                                                                                            // 104\n  var children = tag.children;                                                                                         // 105\n  if (tagName === 'textarea' && tag.children.length &&                                                                 // 106\n      ! (rawAttrs && ('value' in rawAttrs))) {                                                                         // 107\n    // Provide very limited support for TEXTAREA tags with children                                                    // 108\n    // rather than a \"value\" attribute.                                                                                // 109\n    // Reactivity in the form of Views nested in the tag's children                                                    // 110\n    // won't work.  Compilers should compile textarea contents into                                                    // 111\n    // the \"value\" attribute of the tag, wrapped in a function if there                                                // 112\n    // is reactivity.                                                                                                  // 113\n    if (typeof rawAttrs === 'function' ||                                                                              // 114\n        HTML.isArray(rawAttrs)) {                                                                                      // 115\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +                                              // 116\n                      \"use the 'value' attribute instead.\");                                                           // 117\n    }                                                                                                                  // 118\n    rawAttrs = _.extend({}, rawAttrs || null);                                                                         // 119\n    rawAttrs.value = Blaze._expand(children, parentView);                                                              // 120\n    children = [];                                                                                                     // 121\n  }                                                                                                                    // 122\n                                                                                                                       // 123\n  if (rawAttrs) {                                                                                                      // 124\n    var attrUpdater = new ElementAttributesUpdater(elem);                                                              // 125\n    var updateAttributes = function () {                                                                               // 126\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);                                               // 127\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);                                                      // 128\n      var stringAttrs = {};                                                                                            // 129\n      for (var attrName in flattenedAttrs) {                                                                           // 130\n        stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],                                                // 131\n                                              parentView,                                                              // 132\n                                              HTML.TEXTMODE.STRING);                                                   // 133\n      }                                                                                                                // 134\n      attrUpdater.update(stringAttrs);                                                                                 // 135\n    };                                                                                                                 // 136\n    var updaterComputation;                                                                                            // 137\n    if (parentView) {                                                                                                  // 138\n      updaterComputation =                                                                                             // 139\n        parentView.autorun(updateAttributes, undefined, 'updater');                                                    // 140\n    } else {                                                                                                           // 141\n      updaterComputation = Tracker.nonreactive(function () {                                                           // 142\n        return Tracker.autorun(function () {                                                                           // 143\n          Tracker._withCurrentView(parentView, updateAttributes);                                                      // 144\n        });                                                                                                            // 145\n      });                                                                                                              // 146\n    }                                                                                                                  // 147\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {                                       // 148\n      updaterComputation.stop();                                                                                       // 149\n    });                                                                                                                // 150\n  }                                                                                                                    // 151\n                                                                                                                       // 152\n  if (children.length) {                                                                                               // 153\n    var childNodesAndRanges = [];                                                                                      // 154\n    // push this function first so that it's done last                                                                 // 155\n    workStack.push(function () {                                                                                       // 156\n      for (var i = 0; i < childNodesAndRanges.length; i++) {                                                           // 157\n        var x = childNodesAndRanges[i];                                                                                // 158\n        if (x instanceof Blaze._DOMRange)                                                                              // 159\n          x.attach(elem);                                                                                              // 160\n        else                                                                                                           // 161\n          elem.appendChild(x);                                                                                         // 162\n      }                                                                                                                // 163\n    });                                                                                                                // 164\n    // now push the task that calculates childNodesAndRanges                                                           // 165\n    workStack.push(_.bind(Blaze._materializeDOM, null,                                                                 // 166\n                          children, childNodesAndRanges, parentView,                                                   // 167\n                          workStack));                                                                                 // 168\n  }                                                                                                                    // 169\n                                                                                                                       // 170\n  return elem;                                                                                                         // 171\n};                                                                                                                     // 172\n                                                                                                                       // 173\n                                                                                                                       // 174\nvar isSVGAnchor = function (node) {                                                                                    // 175\n  // We generally aren't able to detect SVG <a> elements because                                                       // 176\n  // if \"A\" were in our list of known svg element names, then all                                                      // 177\n  // <a> nodes would be created using                                                                                  // 178\n  // `document.createElementNS`. But in the special case of <a                                                         // 179\n  // xlink:href=\"...\">, we can at least detect that attribute and                                                      // 180\n  // create an SVG <a> tag in that case.                                                                               // 181\n  //                                                                                                                   // 182\n  // However, we still have a general problem of knowing when to                                                       // 183\n  // use document.createElementNS and when to use                                                                      // 184\n  // document.createElement; for example, font tags will always                                                        // 185\n  // be created as SVG elements which can cause other                                                                  // 186\n  // problems. #1977                                                                                                   // 187\n  return (node.tagName === \"a\" &&                                                                                      // 188\n          node.attrs &&                                                                                                // 189\n          node.attrs[\"xlink:href\"] !== undefined);                                                                     // 190\n};                                                                                                                     // 191\n                                                                                                                       // 192\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/exceptions.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar debugFunc;                                                                                                         // 1\n                                                                                                                       // 2\n// We call into user code in many places, and it's nice to catch exceptions                                            // 3\n// propagated from user code immediately so that the whole system doesn't just                                         // 4\n// break.  Catching exceptions is easy; reporting them is hard.  This helper                                           // 5\n// reports exceptions.                                                                                                 // 6\n//                                                                                                                     // 7\n// Usage:                                                                                                              // 8\n//                                                                                                                     // 9\n// ```                                                                                                                 // 10\n// try {                                                                                                               // 11\n//   // ... someStuff ...                                                                                              // 12\n// } catch (e) {                                                                                                       // 13\n//   reportUIException(e);                                                                                             // 14\n// }                                                                                                                   // 15\n// ```                                                                                                                 // 16\n//                                                                                                                     // 17\n// An optional second argument overrides the default message.                                                          // 18\n                                                                                                                       // 19\n// Set this to `true` to cause `reportException` to throw                                                              // 20\n// the next exception rather than reporting it.  This is                                                               // 21\n// useful in unit tests that test error messages.                                                                      // 22\nBlaze._throwNextException = false;                                                                                     // 23\n                                                                                                                       // 24\nBlaze._reportException = function (e, msg) {                                                                           // 25\n  if (Blaze._throwNextException) {                                                                                     // 26\n    Blaze._throwNextException = false;                                                                                 // 27\n    throw e;                                                                                                           // 28\n  }                                                                                                                    // 29\n                                                                                                                       // 30\n  if (! debugFunc)                                                                                                     // 31\n    // adapted from Tracker                                                                                            // 32\n    debugFunc = function () {                                                                                          // 33\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :                                                          // 34\n              ((typeof console !== \"undefined\") && console.log ? console.log :                                         // 35\n               function () {}));                                                                                       // 36\n    };                                                                                                                 // 37\n                                                                                                                       // 38\n  // In Chrome, `e.stack` is a multiline string that starts with the message                                           // 39\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.                                       // 40\n  // `console.log` supplies the space between the two arguments.                                                       // 41\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message || e);                                      // 42\n};                                                                                                                     // 43\n                                                                                                                       // 44\nBlaze._wrapCatchingExceptions = function (f, where) {                                                                  // 45\n  if (typeof f !== 'function')                                                                                         // 46\n    return f;                                                                                                          // 47\n                                                                                                                       // 48\n  return function () {                                                                                                 // 49\n    try {                                                                                                              // 50\n      return f.apply(this, arguments);                                                                                 // 51\n    } catch (e) {                                                                                                      // 52\n      Blaze._reportException(e, 'Exception in ' + where + ':');                                                        // 53\n    }                                                                                                                  // 54\n  };                                                                                                                   // 55\n};                                                                                                                     // 56\n                                                                                                                       // 57\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/view.js                                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/// [new] Blaze.View([name], renderMethod)                                                                             // 1\n///                                                                                                                    // 2\n/// Blaze.View is the building block of reactive DOM.  Views have                                                      // 3\n/// the following features:                                                                                            // 4\n///                                                                                                                    // 5\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,                                                // 6\n///   and callbacks can be registered to fire when these things happen.                                                // 7\n///                                                                                                                    // 8\n/// * parent pointer - A View points to its parentView, which is the                                                   // 9\n///   View that caused it to be rendered.  These pointers form a                                                       // 10\n///   hierarchy or tree of Views.                                                                                      // 11\n///                                                                                                                    // 12\n/// * render() method - A View's render() method specifies the DOM                                                     // 13\n///   (or HTML) content of the View.  If the method establishes                                                        // 14\n///   reactive dependencies, it may be re-run.                                                                         // 15\n///                                                                                                                    // 16\n/// * a DOMRange - If a View is rendered to DOM, its position and                                                      // 17\n///   extent in the DOM are tracked using a DOMRange object.                                                           // 18\n///                                                                                                                    // 19\n/// When a View is constructed by calling Blaze.View, the View is                                                      // 20\n/// not yet considered \"created.\"  It doesn't have a parentView yet,                                                   // 21\n/// and no logic has been run to initialize the View.  All real                                                        // 22\n/// work is deferred until at least creation time, when the onViewCreated                                              // 23\n/// callbacks are fired, which happens when the View is \"used\" in                                                      // 24\n/// some way that requires it to be rendered.                                                                          // 25\n///                                                                                                                    // 26\n/// ...more lifecycle stuff                                                                                            // 27\n///                                                                                                                    // 28\n/// `name` is an optional string tag identifying the View.  The only                                                   // 29\n/// time it's used is when looking in the View tree for a View of a                                                    // 30\n/// particular name; for example, data contexts are stored on Views                                                    // 31\n/// of name \"with\".  Names are also useful when debugging, so in                                                       // 32\n/// general it's good for functions that create Views to set the name.                                                 // 33\n/// Views associated with templates have names of the form \"Template.foo\".                                             // 34\n                                                                                                                       // 35\n/**                                                                                                                    // 36\n * @class                                                                                                              // 37\n * @summary Constructor for a View, which represents a reactive region of DOM.                                         // 38\n * @locus Client                                                                                                       // 39\n * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).                     // 40\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  In this function, `this` is bound to the View.\n */                                                                                                                    // 42\nBlaze.View = function (name, render) {                                                                                 // 43\n  if (! (this instanceof Blaze.View))                                                                                  // 44\n    // called without `new`                                                                                            // 45\n    return new Blaze.View(name, render);                                                                               // 46\n                                                                                                                       // 47\n  if (typeof name === 'function') {                                                                                    // 48\n    // omitted \"name\" argument                                                                                         // 49\n    render = name;                                                                                                     // 50\n    name = '';                                                                                                         // 51\n  }                                                                                                                    // 52\n  this.name = name;                                                                                                    // 53\n  this._render = render;                                                                                               // 54\n                                                                                                                       // 55\n  this._callbacks = {                                                                                                  // 56\n    created: null,                                                                                                     // 57\n    rendered: null,                                                                                                    // 58\n    destroyed: null                                                                                                    // 59\n  };                                                                                                                   // 60\n                                                                                                                       // 61\n  // Setting all properties here is good for readability,                                                              // 62\n  // and also may help Chrome optimize the code by keeping                                                             // 63\n  // the View object from changing shape too much.                                                                     // 64\n  this.isCreated = false;                                                                                              // 65\n  this._isCreatedForExpansion = false;                                                                                 // 66\n  this.isRendered = false;                                                                                             // 67\n  this._isAttached = false;                                                                                            // 68\n  this.isDestroyed = false;                                                                                            // 69\n  this._isInRender = false;                                                                                            // 70\n  this.parentView = null;                                                                                              // 71\n  this._domrange = null;                                                                                               // 72\n  // This flag is normally set to false except for the cases when view's parent                                        // 73\n  // was generated as part of expanding some syntactic sugar expressions or                                            // 74\n  // methods.                                                                                                          // 75\n  // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular                                        // 76\n  // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the                                         // 77\n  // users don't know anything about these generated parent views, Blaze needs                                         // 78\n  // this information to be available on views to make smarter decisions. For                                          // 79\n  // example: removing the generated parent view with the view on Blaze.remove.                                        // 80\n  this._hasGeneratedParent = false;                                                                                    // 81\n  // Bindings accessible to children views (via view.lookup('name')) within the                                        // 82\n  // closest template view.                                                                                            // 83\n  this._scopeBindings = {};                                                                                            // 84\n                                                                                                                       // 85\n  this.renderCount = 0;                                                                                                // 86\n};                                                                                                                     // 87\n                                                                                                                       // 88\nBlaze.View.prototype._render = function () { return null; };                                                           // 89\n                                                                                                                       // 90\nBlaze.View.prototype.onViewCreated = function (cb) {                                                                   // 91\n  this._callbacks.created = this._callbacks.created || [];                                                             // 92\n  this._callbacks.created.push(cb);                                                                                    // 93\n};                                                                                                                     // 94\n                                                                                                                       // 95\nBlaze.View.prototype._onViewRendered = function (cb) {                                                                 // 96\n  this._callbacks.rendered = this._callbacks.rendered || [];                                                           // 97\n  this._callbacks.rendered.push(cb);                                                                                   // 98\n};                                                                                                                     // 99\n                                                                                                                       // 100\nBlaze.View.prototype.onViewReady = function (cb) {                                                                     // 101\n  var self = this;                                                                                                     // 102\n  var fire = function () {                                                                                             // 103\n    Tracker.afterFlush(function () {                                                                                   // 104\n      if (! self.isDestroyed) {                                                                                        // 105\n        Blaze._withCurrentView(self, function () {                                                                     // 106\n          cb.call(self);                                                                                               // 107\n        });                                                                                                            // 108\n      }                                                                                                                // 109\n    });                                                                                                                // 110\n  };                                                                                                                   // 111\n  self._onViewRendered(function onViewRendered() {                                                                     // 112\n    if (self.isDestroyed)                                                                                              // 113\n      return;                                                                                                          // 114\n    if (! self._domrange.attached)                                                                                     // 115\n      self._domrange.onAttached(fire);                                                                                 // 116\n    else                                                                                                               // 117\n      fire();                                                                                                          // 118\n  });                                                                                                                  // 119\n};                                                                                                                     // 120\n                                                                                                                       // 121\nBlaze.View.prototype.onViewDestroyed = function (cb) {                                                                 // 122\n  this._callbacks.destroyed = this._callbacks.destroyed || [];                                                         // 123\n  this._callbacks.destroyed.push(cb);                                                                                  // 124\n};                                                                                                                     // 125\nBlaze.View.prototype.removeViewDestroyedListener = function (cb) {                                                     // 126\n  var destroyed = this._callbacks.destroyed;                                                                           // 127\n  if (! destroyed)                                                                                                     // 128\n    return;                                                                                                            // 129\n  var index = _.lastIndexOf(destroyed, cb);                                                                            // 130\n  if (index !== -1) {                                                                                                  // 131\n    // XXX You'd think the right thing to do would be splice, but _fireCallbacks                                       // 132\n    // gets sad if you remove callbacks while iterating over the list.  Should                                         // 133\n    // change this to use callback-hook or EventEmitter or something else that                                         // 134\n    // properly supports removal.                                                                                      // 135\n    destroyed[index] = null;                                                                                           // 136\n  }                                                                                                                    // 137\n};                                                                                                                     // 138\n                                                                                                                       // 139\n/// View#autorun(func)                                                                                                 // 140\n///                                                                                                                    // 141\n/// Sets up a Tracker autorun that is \"scoped\" to this View in two                                                     // 142\n/// important ways: 1) Blaze.currentView is automatically set                                                          // 143\n/// on every re-run, and 2) the autorun is stopped when the                                                            // 144\n/// View is destroyed.  As with Tracker.autorun, the first run of                                                      // 145\n/// the function is immediate, and a Computation object that can                                                       // 146\n/// be used to stop the autorun is returned.                                                                           // 147\n///                                                                                                                    // 148\n/// View#autorun is meant to be called from View callbacks like                                                        // 149\n/// onViewCreated, or from outside the rendering process.  It may not                                                  // 150\n/// be called before the onViewCreated callbacks are fired (too early),                                                // 151\n/// or from a render() method (too confusing).                                                                         // 152\n///                                                                                                                    // 153\n/// Typically, autoruns that update the state                                                                          // 154\n/// of the View (as in Blaze.With) should be started from an onViewCreated                                             // 155\n/// callback.  Autoruns that update the DOM should be started                                                          // 156\n/// from either onViewCreated (guarded against the absence of                                                          // 157\n/// view._domrange), or onViewReady.                                                                                   // 158\nBlaze.View.prototype.autorun = function (f, _inViewScope, displayName) {                                               // 159\n  var self = this;                                                                                                     // 160\n                                                                                                                       // 161\n  // The restrictions on when View#autorun can be called are in order                                                  // 162\n  // to avoid bad patterns, like creating a Blaze.View and immediately                                                 // 163\n  // calling autorun on it.  A freshly created View is not ready to                                                    // 164\n  // have logic run on it; it doesn't have a parentView, for example.                                                  // 165\n  // It's when the View is materialized or expanded that the onViewCreated                                             // 166\n  // handlers are fired and the View starts up.                                                                        // 167\n  //                                                                                                                   // 168\n  // Letting the render() method call `this.autorun()` is problematic                                                  // 169\n  // because of re-render.  The best we can do is to stop the old                                                      // 170\n  // autorun and start a new one for each render, but that's a pattern                                                 // 171\n  // we try to avoid internally because it leads to helpers being                                                      // 172\n  // called extra times, in the case where the autorun causes the                                                      // 173\n  // view to re-render (and thus the autorun to be torn down and a                                                     // 174\n  // new one established).                                                                                             // 175\n  //                                                                                                                   // 176\n  // We could lift these restrictions in various ways.  One interesting                                                // 177\n  // idea is to allow you to call `view.autorun` after instantiating                                                   // 178\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring                                              // 179\n  // the autorun so that it starts at an appropriate time.  However,                                                   // 180\n  // then we can't return the Computation object to the caller, because                                                // 181\n  // it doesn't exist yet.                                                                                             // 182\n  if (! self.isCreated) {                                                                                              // 183\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");                          // 184\n  }                                                                                                                    // 185\n  if (this._isInRender) {                                                                                              // 186\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }                                                                                                                    // 188\n  if (Tracker.active) {                                                                                                // 189\n    throw new Error(\"Can't call View#autorun from a Tracker Computation; try calling it from the created or rendered callback\");\n  }                                                                                                                    // 191\n                                                                                                                       // 192\n  var templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;                                              // 193\n                                                                                                                       // 194\n  var func = function viewAutorun(c) {                                                                                 // 195\n    return Blaze._withCurrentView(_inViewScope || self, function () {                                                  // 196\n      return Blaze.Template._withTemplateInstanceFunc(                                                                 // 197\n        templateInstanceFunc, function () {                                                                            // 198\n          return f.call(self, c);                                                                                      // 199\n        });                                                                                                            // 200\n    });                                                                                                                // 201\n  };                                                                                                                   // 202\n                                                                                                                       // 203\n  // Give the autorun function a better name for debugging and profiling.                                              // 204\n  // The `displayName` property is not part of the spec but browsers like Chrome                                       // 205\n  // and Firefox prefer it in debuggers over the name function was declared by.                                        // 206\n  func.displayName =                                                                                                   // 207\n    (self.name || 'anonymous') + ':' + (displayName || 'anonymous');                                                   // 208\n  var comp = Tracker.autorun(func);                                                                                    // 209\n                                                                                                                       // 210\n  var stopComputation = function () { comp.stop(); };                                                                  // 211\n  self.onViewDestroyed(stopComputation);                                                                               // 212\n  comp.onStop(function () {                                                                                            // 213\n    self.removeViewDestroyedListener(stopComputation);                                                                 // 214\n  });                                                                                                                  // 215\n                                                                                                                       // 216\n  return comp;                                                                                                         // 217\n};                                                                                                                     // 218\n                                                                                                                       // 219\nBlaze.View.prototype._errorIfShouldntCallSubscribe = function () {                                                     // 220\n  var self = this;                                                                                                     // 221\n                                                                                                                       // 222\n  if (! self.isCreated) {                                                                                              // 223\n    throw new Error(\"View#subscribe must be called from the created callback at the earliest\");                        // 224\n  }                                                                                                                    // 225\n  if (self._isInRender) {                                                                                              // 226\n    throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n  }                                                                                                                    // 228\n  if (self.isDestroyed) {                                                                                              // 229\n    throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n  }                                                                                                                    // 231\n};                                                                                                                     // 232\n                                                                                                                       // 233\n/**                                                                                                                    // 234\n * Just like Blaze.View#autorun, but with Meteor.subscribe instead of                                                  // 235\n * Tracker.autorun. Stop the subscription when the view is destroyed.                                                  // 236\n * @return {SubscriptionHandle} A handle to the subscription so that you can                                           // 237\n * see if it is ready, or stop it manually                                                                             // 238\n */                                                                                                                    // 239\nBlaze.View.prototype.subscribe = function (args, options) {                                                            // 240\n  var self = this;                                                                                                     // 241\n  options = options || {};                                                                                             // 242\n                                                                                                                       // 243\n  self._errorIfShouldntCallSubscribe();                                                                                // 244\n                                                                                                                       // 245\n  var subHandle;                                                                                                       // 246\n  if (options.connection) {                                                                                            // 247\n    subHandle = options.connection.subscribe.apply(options.connection, args);                                          // 248\n  } else {                                                                                                             // 249\n    subHandle = Meteor.subscribe.apply(Meteor, args);                                                                  // 250\n  }                                                                                                                    // 251\n                                                                                                                       // 252\n  self.onViewDestroyed(function () {                                                                                   // 253\n    subHandle.stop();                                                                                                  // 254\n  });                                                                                                                  // 255\n                                                                                                                       // 256\n  return subHandle;                                                                                                    // 257\n};                                                                                                                     // 258\n                                                                                                                       // 259\nBlaze.View.prototype.firstNode = function () {                                                                         // 260\n  if (! this._isAttached)                                                                                              // 261\n    throw new Error(\"View must be attached before accessing its DOM\");                                                 // 262\n                                                                                                                       // 263\n  return this._domrange.firstNode();                                                                                   // 264\n};                                                                                                                     // 265\n                                                                                                                       // 266\nBlaze.View.prototype.lastNode = function () {                                                                          // 267\n  if (! this._isAttached)                                                                                              // 268\n    throw new Error(\"View must be attached before accessing its DOM\");                                                 // 269\n                                                                                                                       // 270\n  return this._domrange.lastNode();                                                                                    // 271\n};                                                                                                                     // 272\n                                                                                                                       // 273\nBlaze._fireCallbacks = function (view, which) {                                                                        // 274\n  Blaze._withCurrentView(view, function () {                                                                           // 275\n    Tracker.nonreactive(function fireCallbacks() {                                                                     // 276\n      var cbs = view._callbacks[which];                                                                                // 277\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)                                                             // 278\n        cbs[i] && cbs[i].call(view);                                                                                   // 279\n    });                                                                                                                // 280\n  });                                                                                                                  // 281\n};                                                                                                                     // 282\n                                                                                                                       // 283\nBlaze._createView = function (view, parentView, forExpansion) {                                                        // 284\n  if (view.isCreated)                                                                                                  // 285\n    throw new Error(\"Can't render the same View twice\");                                                               // 286\n                                                                                                                       // 287\n  view.parentView = (parentView || null);                                                                              // 288\n  view.isCreated = true;                                                                                               // 289\n  if (forExpansion)                                                                                                    // 290\n    view._isCreatedForExpansion = true;                                                                                // 291\n                                                                                                                       // 292\n  Blaze._fireCallbacks(view, 'created');                                                                               // 293\n};                                                                                                                     // 294\n                                                                                                                       // 295\nvar doFirstRender = function (view, initialContent) {                                                                  // 296\n  var domrange = new Blaze._DOMRange(initialContent);                                                                  // 297\n  view._domrange = domrange;                                                                                           // 298\n  domrange.view = view;                                                                                                // 299\n  view.isRendered = true;                                                                                              // 300\n  Blaze._fireCallbacks(view, 'rendered');                                                                              // 301\n                                                                                                                       // 302\n  var teardownHook = null;                                                                                             // 303\n                                                                                                                       // 304\n  domrange.onAttached(function attached(range, element) {                                                              // 305\n    view._isAttached = true;                                                                                           // 306\n                                                                                                                       // 307\n    teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(                                                       // 308\n      element, function teardown() {                                                                                   // 309\n        Blaze._destroyView(view, true /* _skipNodes */);                                                               // 310\n      });                                                                                                              // 311\n  });                                                                                                                  // 312\n                                                                                                                       // 313\n  // tear down the teardown hook                                                                                       // 314\n  view.onViewDestroyed(function () {                                                                                   // 315\n    teardownHook && teardownHook.stop();                                                                               // 316\n    teardownHook = null;                                                                                               // 317\n  });                                                                                                                  // 318\n                                                                                                                       // 319\n  return domrange;                                                                                                     // 320\n};                                                                                                                     // 321\n                                                                                                                       // 322\n// Take an uncreated View `view` and create and render it to DOM,                                                      // 323\n// setting up the autorun that updates the View.  Returns a new                                                        // 324\n// DOMRange, which has been associated with the View.                                                                  // 325\n//                                                                                                                     // 326\n// The private arguments `_workStack` and `_intoArray` are passed in                                                   // 327\n// by Blaze._materializeDOM and are only present for recursive calls                                                   // 328\n// (when there is some other _materializeView on the stack).  If                                                       // 329\n// provided, then we avoid the mutual recursion of calling back into                                                   // 330\n// Blaze._materializeDOM so that deep View hierarchies don't blow the                                                  // 331\n// stack.  Instead, we push tasks onto workStack for the initial                                                       // 332\n// rendering and subsequent setup of the View, and they are done after                                                 // 333\n// we return.  When there is a _workStack, we do not return the new                                                    // 334\n// DOMRange, but instead push it into _intoArray from a _workStack                                                     // 335\n// task.                                                                                                               // 336\nBlaze._materializeView = function (view, parentView, _workStack, _intoArray) {                                         // 337\n  Blaze._createView(view, parentView);                                                                                 // 338\n                                                                                                                       // 339\n  var domrange;                                                                                                        // 340\n  var lastHtmljs;                                                                                                      // 341\n  // We don't expect to be called in a Computation, but just in case,                                                  // 342\n  // wrap in Tracker.nonreactive.                                                                                      // 343\n  Tracker.nonreactive(function () {                                                                                    // 344\n    view.autorun(function doRender(c) {                                                                                // 345\n      // `view.autorun` sets the current view.                                                                         // 346\n      view.renderCount++;                                                                                              // 347\n      view._isInRender = true;                                                                                         // 348\n      // Any dependencies that should invalidate this Computation come                                                 // 349\n      // from this line:                                                                                               // 350\n      var htmljs = view._render();                                                                                     // 351\n      view._isInRender = false;                                                                                        // 352\n                                                                                                                       // 353\n      if (! c.firstRun) {                                                                                              // 354\n        Tracker.nonreactive(function doMaterialize() {                                                                 // 355\n          // re-render                                                                                                 // 356\n          var rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);                                                // 357\n          if (! Blaze._isContentEqual(lastHtmljs, htmljs)) {                                                           // 358\n            domrange.setMembers(rangesAndNodes);                                                                       // 359\n            Blaze._fireCallbacks(view, 'rendered');                                                                    // 360\n          }                                                                                                            // 361\n        });                                                                                                            // 362\n      }                                                                                                                // 363\n      lastHtmljs = htmljs;                                                                                             // 364\n                                                                                                                       // 365\n      // Causes any nested views to stop immediately, not when we call                                                 // 366\n      // `setMembers` the next time around the autorun.  Otherwise,                                                    // 367\n      // helpers in the DOM tree to be replaced might be scheduled                                                     // 368\n      // to re-run before we have a chance to stop them.                                                               // 369\n      Tracker.onInvalidate(function () {                                                                               // 370\n        if (domrange) {                                                                                                // 371\n          domrange.destroyMembers();                                                                                   // 372\n        }                                                                                                              // 373\n      });                                                                                                              // 374\n    }, undefined, 'materialize');                                                                                      // 375\n                                                                                                                       // 376\n    // first render.  lastHtmljs is the first htmljs.                                                                  // 377\n    var initialContents;                                                                                               // 378\n    if (! _workStack) {                                                                                                // 379\n      initialContents = Blaze._materializeDOM(lastHtmljs, [], view);                                                   // 380\n      domrange = doFirstRender(view, initialContents);                                                                 // 381\n      initialContents = null; // help GC because we close over this scope a lot                                        // 382\n    } else {                                                                                                           // 383\n      // We're being called from Blaze._materializeDOM, so to avoid                                                    // 384\n      // recursion and save stack space, provide a description of the                                                  // 385\n      // work to be done instead of doing it.  Tasks pushed onto                                                       // 386\n      // _workStack will be done in LIFO order after we return.                                                        // 387\n      // The work will still be done within a Tracker.nonreactive,                                                     // 388\n      // because it will be done by some call to Blaze._materializeDOM                                                 // 389\n      // (which is always called in a Tracker.nonreactive).                                                            // 390\n      initialContents = [];                                                                                            // 391\n      // push this function first so that it happens last                                                              // 392\n      _workStack.push(function () {                                                                                    // 393\n        domrange = doFirstRender(view, initialContents);                                                               // 394\n        initialContents = null; // help GC because of all the closures here                                            // 395\n        _intoArray.push(domrange);                                                                                     // 396\n      });                                                                                                              // 397\n      // now push the task that calculates initialContents                                                             // 398\n      _workStack.push(_.bind(Blaze._materializeDOM, null,                                                              // 399\n                             lastHtmljs, initialContents, view, _workStack));                                          // 400\n    }                                                                                                                  // 401\n  });                                                                                                                  // 402\n                                                                                                                       // 403\n  if (! _workStack) {                                                                                                  // 404\n    return domrange;                                                                                                   // 405\n  } else {                                                                                                             // 406\n    return null;                                                                                                       // 407\n  }                                                                                                                    // 408\n};                                                                                                                     // 409\n                                                                                                                       // 410\n// Expands a View to HTMLjs, calling `render` recursively on all                                                       // 411\n// Views and evaluating any dynamic attributes.  Calls the `created`                                                   // 412\n// callback, but not the `materialized` or `rendered` callbacks.                                                       // 413\n// Destroys the view immediately, unless called in a Tracker Computation,                                              // 414\n// in which case the view will be destroyed when the Computation is                                                    // 415\n// invalidated.  If called in a Tracker Computation, the result is a                                                   // 416\n// reactive string; that is, the Computation will be invalidated                                                       // 417\n// if any changes are made to the view or subviews that might affect                                                   // 418\n// the HTML.                                                                                                           // 419\nBlaze._expandView = function (view, parentView) {                                                                      // 420\n  Blaze._createView(view, parentView, true /*forExpansion*/);                                                          // 421\n                                                                                                                       // 422\n  view._isInRender = true;                                                                                             // 423\n  var htmljs = Blaze._withCurrentView(view, function () {                                                              // 424\n    return view._render();                                                                                             // 425\n  });                                                                                                                  // 426\n  view._isInRender = false;                                                                                            // 427\n                                                                                                                       // 428\n  var result = Blaze._expand(htmljs, view);                                                                            // 429\n                                                                                                                       // 430\n  if (Tracker.active) {                                                                                                // 431\n    Tracker.onInvalidate(function () {                                                                                 // 432\n      Blaze._destroyView(view);                                                                                        // 433\n    });                                                                                                                // 434\n  } else {                                                                                                             // 435\n    Blaze._destroyView(view);                                                                                          // 436\n  }                                                                                                                    // 437\n                                                                                                                       // 438\n  return result;                                                                                                       // 439\n};                                                                                                                     // 440\n                                                                                                                       // 441\n// Options: `parentView`                                                                                               // 442\nBlaze._HTMLJSExpander = HTML.TransformingVisitor.extend();                                                             // 443\nBlaze._HTMLJSExpander.def({                                                                                            // 444\n  visitObject: function (x) {                                                                                          // 445\n    if (x instanceof Blaze.Template)                                                                                   // 446\n      x = x.constructView();                                                                                           // 447\n    if (x instanceof Blaze.View)                                                                                       // 448\n      return Blaze._expandView(x, this.parentView);                                                                    // 449\n                                                                                                                       // 450\n    // this will throw an error; other objects are not allowed!                                                        // 451\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);                                               // 452\n  },                                                                                                                   // 453\n  visitAttributes: function (attrs) {                                                                                  // 454\n    // expand dynamic attributes                                                                                       // 455\n    if (typeof attrs === 'function')                                                                                   // 456\n      attrs = Blaze._withCurrentView(this.parentView, attrs);                                                          // 457\n                                                                                                                       // 458\n    // call super (e.g. for case where `attrs` is an array)                                                            // 459\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);                                       // 460\n  },                                                                                                                   // 461\n  visitAttribute: function (name, value, tag) {                                                                        // 462\n    // expand attribute values that are functions.  Any attribute value                                                // 463\n    // that contains Views must be wrapped in a function.                                                              // 464\n    if (typeof value === 'function')                                                                                   // 465\n      value = Blaze._withCurrentView(this.parentView, value);                                                          // 466\n                                                                                                                       // 467\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(                                                     // 468\n      this, name, value, tag);                                                                                         // 469\n  }                                                                                                                    // 470\n});                                                                                                                    // 471\n                                                                                                                       // 472\n// Return Blaze.currentView, but only if it is being rendered                                                          // 473\n// (i.e. we are in its render() method).                                                                               // 474\nvar currentViewIfRendering = function () {                                                                             // 475\n  var view = Blaze.currentView;                                                                                        // 476\n  return (view && view._isInRender) ? view : null;                                                                     // 477\n};                                                                                                                     // 478\n                                                                                                                       // 479\nBlaze._expand = function (htmljs, parentView) {                                                                        // 480\n  parentView = parentView || currentViewIfRendering();                                                                 // 481\n  return (new Blaze._HTMLJSExpander(                                                                                   // 482\n    {parentView: parentView})).visit(htmljs);                                                                          // 483\n};                                                                                                                     // 484\n                                                                                                                       // 485\nBlaze._expandAttributes = function (attrs, parentView) {                                                               // 486\n  parentView = parentView || currentViewIfRendering();                                                                 // 487\n  return (new Blaze._HTMLJSExpander(                                                                                   // 488\n    {parentView: parentView})).visitAttributes(attrs);                                                                 // 489\n};                                                                                                                     // 490\n                                                                                                                       // 491\nBlaze._destroyView = function (view, _skipNodes) {                                                                     // 492\n  if (view.isDestroyed)                                                                                                // 493\n    return;                                                                                                            // 494\n  view.isDestroyed = true;                                                                                             // 495\n                                                                                                                       // 496\n  Blaze._fireCallbacks(view, 'destroyed');                                                                             // 497\n                                                                                                                       // 498\n  // Destroy views and elements recursively.  If _skipNodes,                                                           // 499\n  // only recurse up to views, not elements, for the case where                                                        // 500\n  // the backend (jQuery) is recursing over the elements already.                                                      // 501\n                                                                                                                       // 502\n  if (view._domrange)                                                                                                  // 503\n    view._domrange.destroyMembers(_skipNodes);                                                                         // 504\n};                                                                                                                     // 505\n                                                                                                                       // 506\nBlaze._destroyNode = function (node) {                                                                                 // 507\n  if (node.nodeType === 1)                                                                                             // 508\n    Blaze._DOMBackend.Teardown.tearDownElement(node);                                                                  // 509\n};                                                                                                                     // 510\n                                                                                                                       // 511\n// Are the HTMLjs entities `a` and `b` the same?  We could be                                                          // 512\n// more elaborate here but the point is to catch the most basic                                                        // 513\n// cases.                                                                                                              // 514\nBlaze._isContentEqual = function (a, b) {                                                                              // 515\n  if (a instanceof HTML.Raw) {                                                                                         // 516\n    return (b instanceof HTML.Raw) && (a.value === b.value);                                                           // 517\n  } else if (a == null) {                                                                                              // 518\n    return (b == null);                                                                                                // 519\n  } else {                                                                                                             // 520\n    return (a === b) &&                                                                                                // 521\n      ((typeof a === 'number') || (typeof a === 'boolean') ||                                                          // 522\n       (typeof a === 'string'));                                                                                       // 523\n  }                                                                                                                    // 524\n};                                                                                                                     // 525\n                                                                                                                       // 526\n/**                                                                                                                    // 527\n * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client                                                                                                       // 529\n * @type {Blaze.View}                                                                                                  // 530\n */                                                                                                                    // 531\nBlaze.currentView = null;                                                                                              // 532\n                                                                                                                       // 533\nBlaze._withCurrentView = function (view, func) {                                                                       // 534\n  var oldView = Blaze.currentView;                                                                                     // 535\n  try {                                                                                                                // 536\n    Blaze.currentView = view;                                                                                          // 537\n    return func();                                                                                                     // 538\n  } finally {                                                                                                          // 539\n    Blaze.currentView = oldView;                                                                                       // 540\n  }                                                                                                                    // 541\n};                                                                                                                     // 542\n                                                                                                                       // 543\n// Blaze.render publicly takes a View or a Template.                                                                   // 544\n// Privately, it takes any HTMLJS (extended with Views and Templates)                                                  // 545\n// except null or undefined, or a function that returns any extended                                                   // 546\n// HTMLJS.                                                                                                             // 547\nvar checkRenderContent = function (content) {                                                                          // 548\n  if (content === null)                                                                                                // 549\n    throw new Error(\"Can't render null\");                                                                              // 550\n  if (typeof content === 'undefined')                                                                                  // 551\n    throw new Error(\"Can't render undefined\");                                                                         // 552\n                                                                                                                       // 553\n  if ((content instanceof Blaze.View) ||                                                                               // 554\n      (content instanceof Blaze.Template) ||                                                                           // 555\n      (typeof content === 'function'))                                                                                 // 556\n    return;                                                                                                            // 557\n                                                                                                                       // 558\n  try {                                                                                                                // 559\n    // Throw if content doesn't look like HTMLJS at the top level                                                      // 560\n    // (i.e. verify that this is an HTML.Tag, or an array,                                                             // 561\n    // or a primitive, etc.)                                                                                           // 562\n    (new HTML.Visitor).visit(content);                                                                                 // 563\n  } catch (e) {                                                                                                        // 564\n    // Make error message suitable for public API                                                                      // 565\n    throw new Error(\"Expected Template or View\");                                                                      // 566\n  }                                                                                                                    // 567\n};                                                                                                                     // 568\n                                                                                                                       // 569\n// For Blaze.render and Blaze.toHTML, take content and                                                                 // 570\n// wrap it in a View, unless it's a single View or                                                                     // 571\n// Template already.                                                                                                   // 572\nvar contentAsView = function (content) {                                                                               // 573\n  checkRenderContent(content);                                                                                         // 574\n                                                                                                                       // 575\n  if (content instanceof Blaze.Template) {                                                                             // 576\n    return content.constructView();                                                                                    // 577\n  } else if (content instanceof Blaze.View) {                                                                          // 578\n    return content;                                                                                                    // 579\n  } else {                                                                                                             // 580\n    var func = content;                                                                                                // 581\n    if (typeof func !== 'function') {                                                                                  // 582\n      func = function () {                                                                                             // 583\n        return content;                                                                                                // 584\n      };                                                                                                               // 585\n    }                                                                                                                  // 586\n    return Blaze.View('render', func);                                                                                 // 587\n  }                                                                                                                    // 588\n};                                                                                                                     // 589\n                                                                                                                       // 590\n// For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content                                                     // 591\n// in a function, if necessary, so it can be a content arg to                                                          // 592\n// a Blaze.With.                                                                                                       // 593\nvar contentAsFunc = function (content) {                                                                               // 594\n  checkRenderContent(content);                                                                                         // 595\n                                                                                                                       // 596\n  if (typeof content !== 'function') {                                                                                 // 597\n    return function () {                                                                                               // 598\n      return content;                                                                                                  // 599\n    };                                                                                                                 // 600\n  } else {                                                                                                             // 601\n    return content;                                                                                                    // 602\n  }                                                                                                                    // 603\n};                                                                                                                     // 604\n                                                                                                                       // 605\n/**                                                                                                                    // 606\n * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#blaze_view) which can be passed to [`Blaze.remove`](#blaze_remove).\n * @locus Client                                                                                                       // 608\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */                                                                                                                    // 613\nBlaze.render = function (content, parentElement, nextNode, parentView) {                                               // 614\n  if (! parentElement) {                                                                                               // 615\n    Blaze._warn(\"Blaze.render without a parent element is deprecated. \" +                                              // 616\n                \"You must specify where to insert the rendered content.\");                                             // 617\n  }                                                                                                                    // 618\n                                                                                                                       // 619\n  if (nextNode instanceof Blaze.View) {                                                                                // 620\n    // handle omitted nextNode                                                                                         // 621\n    parentView = nextNode;                                                                                             // 622\n    nextNode = null;                                                                                                   // 623\n  }                                                                                                                    // 624\n                                                                                                                       // 625\n  // parentElement must be a DOM node. in particular, can't be the                                                     // 626\n  // result of a call to `$`. Can't check if `parentElement instanceof                                                 // 627\n  // Node` since 'Node' is undefined in IE8.                                                                           // 628\n  if (parentElement && typeof parentElement.nodeType !== 'number')                                                     // 629\n    throw new Error(\"'parentElement' must be a DOM node\");                                                             // 630\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional                                     // 631\n    throw new Error(\"'nextNode' must be a DOM node\");                                                                  // 632\n                                                                                                                       // 633\n  parentView = parentView || currentViewIfRendering();                                                                 // 634\n                                                                                                                       // 635\n  var view = contentAsView(content);                                                                                   // 636\n  Blaze._materializeView(view, parentView);                                                                            // 637\n                                                                                                                       // 638\n  if (parentElement) {                                                                                                 // 639\n    view._domrange.attach(parentElement, nextNode);                                                                    // 640\n  }                                                                                                                    // 641\n                                                                                                                       // 642\n  return view;                                                                                                         // 643\n};                                                                                                                     // 644\n                                                                                                                       // 645\nBlaze.insert = function (view, parentElement, nextNode) {                                                              // 646\n  Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" +                                      // 647\n              \"rendered content in the call to Blaze.render.\");                                                        // 648\n                                                                                                                       // 649\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))                                                         // 650\n    throw new Error(\"Expected template rendered with Blaze.render\");                                                   // 651\n                                                                                                                       // 652\n  view._domrange.attach(parentElement, nextNode);                                                                      // 653\n};                                                                                                                     // 654\n                                                                                                                       // 655\n/**                                                                                                                    // 656\n * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.       // 657\n * @locus Client                                                                                                       // 658\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.     // 659\n * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */                                                                                                                    // 664\nBlaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {                                 // 665\n  // We defer the handling of optional arguments to Blaze.render.  At this point,                                      // 666\n  // `nextNode` may actually be `parentView`.                                                                          // 667\n  return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)),                                               // 668\n                          parentElement, nextNode, parentView);                                                        // 669\n};                                                                                                                     // 670\n                                                                                                                       // 671\n/**                                                                                                                    // 672\n * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it.             // 673\n * @locus Client                                                                                                       // 674\n * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`.                    // 675\n */                                                                                                                    // 676\nBlaze.remove = function (view) {                                                                                       // 677\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))                                                         // 678\n    throw new Error(\"Expected template rendered with Blaze.render\");                                                   // 679\n                                                                                                                       // 680\n  while (view) {                                                                                                       // 681\n    if (! view.isDestroyed) {                                                                                          // 682\n      var range = view._domrange;                                                                                      // 683\n      if (range.attached && ! range.parentRange)                                                                       // 684\n        range.detach();                                                                                                // 685\n      range.destroy();                                                                                                 // 686\n    }                                                                                                                  // 687\n                                                                                                                       // 688\n    view = view._hasGeneratedParent && view.parentView;                                                                // 689\n  }                                                                                                                    // 690\n};                                                                                                                     // 691\n                                                                                                                       // 692\n/**                                                                                                                    // 693\n * @summary Renders a template or View to a string of HTML.                                                            // 694\n * @locus Client                                                                                                       // 695\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n */                                                                                                                    // 697\nBlaze.toHTML = function (content, parentView) {                                                                        // 698\n  parentView = parentView || currentViewIfRendering();                                                                 // 699\n                                                                                                                       // 700\n  return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));                                           // 701\n};                                                                                                                     // 702\n                                                                                                                       // 703\n/**                                                                                                                    // 704\n * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.            // 705\n * @locus Client                                                                                                       // 706\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n * @param {Object|Function} data The data context to use, or a function returning a data context.                      // 708\n */                                                                                                                    // 709\nBlaze.toHTMLWithData = function (content, data, parentView) {                                                          // 710\n  parentView = parentView || currentViewIfRendering();                                                                 // 711\n                                                                                                                       // 712\n  return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(                                                            // 713\n    data, contentAsFunc(content)), parentView));                                                                       // 714\n};                                                                                                                     // 715\n                                                                                                                       // 716\nBlaze._toText = function (htmljs, parentView, textMode) {                                                              // 717\n  if (typeof htmljs === 'function')                                                                                    // 718\n    throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");                                             // 719\n                                                                                                                       // 720\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {                                                  // 721\n    // omitted parentView argument                                                                                     // 722\n    textMode = parentView;                                                                                             // 723\n    parentView = null;                                                                                                 // 724\n  }                                                                                                                    // 725\n  parentView = parentView || currentViewIfRendering();                                                                 // 726\n                                                                                                                       // 727\n  if (! textMode)                                                                                                      // 728\n    throw new Error(\"textMode required\");                                                                              // 729\n  if (! (textMode === HTML.TEXTMODE.STRING ||                                                                          // 730\n         textMode === HTML.TEXTMODE.RCDATA ||                                                                          // 731\n         textMode === HTML.TEXTMODE.ATTRIBUTE))                                                                        // 732\n    throw new Error(\"Unknown textMode: \" + textMode);                                                                  // 733\n                                                                                                                       // 734\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);                                                     // 735\n};                                                                                                                     // 736\n                                                                                                                       // 737\n/**                                                                                                                    // 738\n * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n * @locus Client                                                                                                       // 740\n * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.      // 741\n */                                                                                                                    // 742\nBlaze.getData = function (elementOrView) {                                                                             // 743\n  var theWith;                                                                                                         // 744\n                                                                                                                       // 745\n  if (! elementOrView) {                                                                                               // 746\n    theWith = Blaze.getView('with');                                                                                   // 747\n  } else if (elementOrView instanceof Blaze.View) {                                                                    // 748\n    var view = elementOrView;                                                                                          // 749\n    theWith = (view.name === 'with' ? view :                                                                           // 750\n               Blaze.getView(view, 'with'));                                                                           // 751\n  } else if (typeof elementOrView.nodeType === 'number') {                                                             // 752\n    if (elementOrView.nodeType !== 1)                                                                                  // 753\n      throw new Error(\"Expected DOM element\");                                                                         // 754\n    theWith = Blaze.getView(elementOrView, 'with');                                                                    // 755\n  } else {                                                                                                             // 756\n    throw new Error(\"Expected DOM element or View\");                                                                   // 757\n  }                                                                                                                    // 758\n                                                                                                                       // 759\n  return theWith ? theWith.dataVar.get() : null;                                                                       // 760\n};                                                                                                                     // 761\n                                                                                                                       // 762\n// For back-compat                                                                                                     // 763\nBlaze.getElementData = function (element) {                                                                            // 764\n  Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" +                                                      // 765\n              \"Blaze.getData(element) instead.\");                                                                      // 766\n                                                                                                                       // 767\n  if (element.nodeType !== 1)                                                                                          // 768\n    throw new Error(\"Expected DOM element\");                                                                           // 769\n                                                                                                                       // 770\n  return Blaze.getData(element);                                                                                       // 771\n};                                                                                                                     // 772\n                                                                                                                       // 773\n// Both arguments are optional.                                                                                        // 774\n                                                                                                                       // 775\n/**                                                                                                                    // 776\n * @summary Gets either the current View, or the View enclosing the given DOM element.                                 // 777\n * @locus Client                                                                                                       // 778\n * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.                    // 779\n */                                                                                                                    // 780\nBlaze.getView = function (elementOrView, _viewName) {                                                                  // 781\n  var viewName = _viewName;                                                                                            // 782\n                                                                                                                       // 783\n  if ((typeof elementOrView) === 'string') {                                                                           // 784\n    // omitted elementOrView; viewName present                                                                         // 785\n    viewName = elementOrView;                                                                                          // 786\n    elementOrView = null;                                                                                              // 787\n  }                                                                                                                    // 788\n                                                                                                                       // 789\n  // We could eventually shorten the code by folding the logic                                                         // 790\n  // from the other methods into this method.                                                                          // 791\n  if (! elementOrView) {                                                                                               // 792\n    return Blaze._getCurrentView(viewName);                                                                            // 793\n  } else if (elementOrView instanceof Blaze.View) {                                                                    // 794\n    return Blaze._getParentView(elementOrView, viewName);                                                              // 795\n  } else if (typeof elementOrView.nodeType === 'number') {                                                             // 796\n    return Blaze._getElementView(elementOrView, viewName);                                                             // 797\n  } else {                                                                                                             // 798\n    throw new Error(\"Expected DOM element or View\");                                                                   // 799\n  }                                                                                                                    // 800\n};                                                                                                                     // 801\n                                                                                                                       // 802\n// Gets the current view or its nearest ancestor of name                                                               // 803\n// `name`.                                                                                                             // 804\nBlaze._getCurrentView = function (name) {                                                                              // 805\n  var view = Blaze.currentView;                                                                                        // 806\n  // Better to fail in cases where it doesn't make sense                                                               // 807\n  // to use Blaze._getCurrentView().  There will be a current                                                          // 808\n  // view anywhere it does.  You can check Blaze.currentView                                                           // 809\n  // if you want to know whether there is one or not.                                                                  // 810\n  if (! view)                                                                                                          // 811\n    throw new Error(\"There is no current view\");                                                                       // 812\n                                                                                                                       // 813\n  if (name) {                                                                                                          // 814\n    while (view && view.name !== name)                                                                                 // 815\n      view = view.parentView;                                                                                          // 816\n    return view || null;                                                                                               // 817\n  } else {                                                                                                             // 818\n    // Blaze._getCurrentView() with no arguments just returns                                                          // 819\n    // Blaze.currentView.                                                                                              // 820\n    return view;                                                                                                       // 821\n  }                                                                                                                    // 822\n};                                                                                                                     // 823\n                                                                                                                       // 824\nBlaze._getParentView = function (view, name) {                                                                         // 825\n  var v = view.parentView;                                                                                             // 826\n                                                                                                                       // 827\n  if (name) {                                                                                                          // 828\n    while (v && v.name !== name)                                                                                       // 829\n      v = v.parentView;                                                                                                // 830\n  }                                                                                                                    // 831\n                                                                                                                       // 832\n  return v || null;                                                                                                    // 833\n};                                                                                                                     // 834\n                                                                                                                       // 835\nBlaze._getElementView = function (elem, name) {                                                                        // 836\n  var range = Blaze._DOMRange.forElement(elem);                                                                        // 837\n  var view = null;                                                                                                     // 838\n  while (range && ! view) {                                                                                            // 839\n    view = (range.view || null);                                                                                       // 840\n    if (! view) {                                                                                                      // 841\n      if (range.parentRange)                                                                                           // 842\n        range = range.parentRange;                                                                                     // 843\n      else                                                                                                             // 844\n        range = Blaze._DOMRange.forElement(range.parentElement);                                                       // 845\n    }                                                                                                                  // 846\n  }                                                                                                                    // 847\n                                                                                                                       // 848\n  if (name) {                                                                                                          // 849\n    while (view && view.name !== name)                                                                                 // 850\n      view = view.parentView;                                                                                          // 851\n    return view || null;                                                                                               // 852\n  } else {                                                                                                             // 853\n    return view;                                                                                                       // 854\n  }                                                                                                                    // 855\n};                                                                                                                     // 856\n                                                                                                                       // 857\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {                                                        // 858\n  thisInHandler = (thisInHandler || null);                                                                             // 859\n  var handles = [];                                                                                                    // 860\n                                                                                                                       // 861\n  if (! view._domrange)                                                                                                // 862\n    throw new Error(\"View must have a DOMRange\");                                                                      // 863\n                                                                                                                       // 864\n  view._domrange.onAttached(function attached_eventMaps(range, element) {                                              // 865\n    _.each(eventMap, function (handler, spec) {                                                                        // 866\n      var clauses = spec.split(/,\\s+/);                                                                                // 867\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']                                               // 868\n      _.each(clauses, function (clause) {                                                                              // 869\n        var parts = clause.split(/\\s+/);                                                                               // 870\n        if (parts.length === 0)                                                                                        // 871\n          return;                                                                                                      // 872\n                                                                                                                       // 873\n        var newEvents = parts.shift();                                                                                 // 874\n        var selector = parts.join(' ');                                                                                // 875\n        handles.push(Blaze._EventSupport.listen(                                                                       // 876\n          element, newEvents, selector,                                                                                // 877\n          function (evt) {                                                                                             // 878\n            if (! range.containsElement(evt.currentTarget))                                                            // 879\n              return null;                                                                                             // 880\n            var handlerThis = thisInHandler || this;                                                                   // 881\n            var handlerArgs = arguments;                                                                               // 882\n            return Blaze._withCurrentView(view, function () {                                                          // 883\n              return handler.apply(handlerThis, handlerArgs);                                                          // 884\n            });                                                                                                        // 885\n          },                                                                                                           // 886\n          range, function (r) {                                                                                        // 887\n            return r.parentRange;                                                                                      // 888\n          }));                                                                                                         // 889\n      });                                                                                                              // 890\n    });                                                                                                                // 891\n  });                                                                                                                  // 892\n                                                                                                                       // 893\n  view.onViewDestroyed(function () {                                                                                   // 894\n    _.each(handles, function (h) {                                                                                     // 895\n      h.stop();                                                                                                        // 896\n    });                                                                                                                // 897\n    handles.length = 0;                                                                                                // 898\n  });                                                                                                                  // 899\n};                                                                                                                     // 900\n                                                                                                                       // 901\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/builtins.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nBlaze._calculateCondition = function (cond) {                                                                          // 1\n  if (cond instanceof Array && cond.length === 0)                                                                      // 2\n    cond = false;                                                                                                      // 3\n  return !! cond;                                                                                                      // 4\n};                                                                                                                     // 5\n                                                                                                                       // 6\n/**                                                                                                                    // 7\n * @summary Constructs a View that renders content with a data context.                                                // 8\n * @locus Client                                                                                                       // 9\n * @param {Object|Function} data An object to use as the data context, or a function returning such an object.  If a function is provided, it will be reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).                  // 11\n */                                                                                                                    // 12\nBlaze.With = function (data, contentFunc) {                                                                            // 13\n  var view = Blaze.View('with', contentFunc);                                                                          // 14\n                                                                                                                       // 15\n  view.dataVar = new ReactiveVar;                                                                                      // 16\n                                                                                                                       // 17\n  view.onViewCreated(function () {                                                                                     // 18\n    if (typeof data === 'function') {                                                                                  // 19\n      // `data` is a reactive function                                                                                 // 20\n      view.autorun(function () {                                                                                       // 21\n        view.dataVar.set(data());                                                                                      // 22\n      }, view.parentView, 'setData');                                                                                  // 23\n    } else {                                                                                                           // 24\n      view.dataVar.set(data);                                                                                          // 25\n    }                                                                                                                  // 26\n  });                                                                                                                  // 27\n                                                                                                                       // 28\n  return view;                                                                                                         // 29\n};                                                                                                                     // 30\n                                                                                                                       // 31\n/**                                                                                                                    // 32\n * Attaches bindings to the instantiated view.                                                                         // 33\n * @param {Object} bindings A dictionary of bindings, each binding name                                                // 34\n * corresponds to a value or a function that will be reactively re-run.                                                // 35\n * @param {View} view The target.                                                                                      // 36\n */                                                                                                                    // 37\nBlaze._attachBindingsToView = function (bindings, view) {                                                              // 38\n  view.onViewCreated(function () {                                                                                     // 39\n    _.each(bindings, function (binding, name) {                                                                        // 40\n      view._scopeBindings[name] = new ReactiveVar;                                                                     // 41\n      if (typeof binding === 'function') {                                                                             // 42\n        view.autorun(function () {                                                                                     // 43\n          view._scopeBindings[name].set(binding());                                                                    // 44\n        }, view.parentView);                                                                                           // 45\n      } else {                                                                                                         // 46\n        view._scopeBindings[name].set(binding);                                                                        // 47\n      }                                                                                                                // 48\n    });                                                                                                                // 49\n  });                                                                                                                  // 50\n};                                                                                                                     // 51\n                                                                                                                       // 52\n/**                                                                                                                    // 53\n * @summary Constructs a View setting the local lexical scope in the block.                                            // 54\n * @param {Function} bindings Dictionary mapping names of bindings to                                                  // 55\n * values or computations to reactively re-run.                                                                        // 56\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).                  // 57\n */                                                                                                                    // 58\nBlaze.Let = function (bindings, contentFunc) {                                                                         // 59\n  var view = Blaze.View('let', contentFunc);                                                                           // 60\n  Blaze._attachBindingsToView(bindings, view);                                                                         // 61\n                                                                                                                       // 62\n  return view;                                                                                                         // 63\n};                                                                                                                     // 64\n                                                                                                                       // 65\n/**                                                                                                                    // 66\n * @summary Constructs a View that renders content conditionally.                                                      // 67\n * @locus Client                                                                                                       // 68\n * @param {Function} conditionFunc A function to reactively re-run.  Whether the result is truthy or falsy determines whether `contentFunc` or `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).                  // 70\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */                                                                                                                    // 72\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {                                                     // 73\n  var conditionVar = new ReactiveVar;                                                                                  // 74\n                                                                                                                       // 75\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {                                                          // 76\n    return conditionVar.get() ? contentFunc() :                                                                        // 77\n      (elseFunc ? elseFunc() : null);                                                                                  // 78\n  });                                                                                                                  // 79\n  view.__conditionVar = conditionVar;                                                                                  // 80\n  view.onViewCreated(function () {                                                                                     // 81\n    this.autorun(function () {                                                                                         // 82\n      var cond = Blaze._calculateCondition(conditionFunc());                                                           // 83\n      conditionVar.set(_not ? (! cond) : cond);                                                                        // 84\n    }, this.parentView, 'condition');                                                                                  // 85\n  });                                                                                                                  // 86\n                                                                                                                       // 87\n  return view;                                                                                                         // 88\n};                                                                                                                     // 89\n                                                                                                                       // 90\n/**                                                                                                                    // 91\n * @summary An inverted [`Blaze.If`](#blaze_if).                                                                       // 92\n * @locus Client                                                                                                       // 93\n * @param {Function} conditionFunc A function to reactively re-run.  If the result is falsy, `contentFunc` is shown, otherwise `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).                  // 95\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */                                                                                                                    // 97\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {                                                       // 98\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);                                                // 99\n};                                                                                                                     // 100\n                                                                                                                       // 101\n/**                                                                                                                    // 102\n * @summary Constructs a View that renders `contentFunc` for each item in a sequence.                                  // 103\n * @locus Client                                                                                                       // 104\n * @param {Function} argFunc A function to reactively re-run. The function can                                         // 105\n * return one of two options:                                                                                          // 106\n *                                                                                                                     // 107\n * 1. An object with two fields: '_variable' and '_sequence'. Each iterates over                                       // 108\n *   '_sequence', it may be a Cursor, an array, null, or undefined. Inside the                                         // 109\n *   Each body you will be able to get the current item from the sequence using                                        // 110\n *   the name specified in the '_variable' field.                                                                      // 111\n *                                                                                                                     // 112\n * 2. Just a sequence (Cursor, array, null, or undefined) not wrapped into an                                          // 113\n *   object. Inside the Each body, the current item will be set as the data                                            // 114\n *   context.                                                                                                          // 115\n * @param {Function} contentFunc A Function that returns  [*renderable                                                 // 116\n * content*](#renderable_content).                                                                                     // 117\n * @param {Function} [elseFunc] A Function that returns [*renderable                                                   // 118\n * content*](#renderable_content) to display in the case when there are no items                                       // 119\n * in the sequence.                                                                                                    // 120\n */                                                                                                                    // 121\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {                                                               // 122\n  var eachView = Blaze.View('each', function () {                                                                      // 123\n    var subviews = this.initialSubviews;                                                                               // 124\n    this.initialSubviews = null;                                                                                       // 125\n    if (this._isCreatedForExpansion) {                                                                                 // 126\n      this.expandedValueDep = new Tracker.Dependency;                                                                  // 127\n      this.expandedValueDep.depend();                                                                                  // 128\n    }                                                                                                                  // 129\n    return subviews;                                                                                                   // 130\n  });                                                                                                                  // 131\n  eachView.initialSubviews = [];                                                                                       // 132\n  eachView.numItems = 0;                                                                                               // 133\n  eachView.inElseMode = false;                                                                                         // 134\n  eachView.stopHandle = null;                                                                                          // 135\n  eachView.contentFunc = contentFunc;                                                                                  // 136\n  eachView.elseFunc = elseFunc;                                                                                        // 137\n  eachView.argVar = new ReactiveVar;                                                                                   // 138\n  eachView.variableName = null;                                                                                        // 139\n                                                                                                                       // 140\n  // update the @index value in the scope of all subviews in the range                                                 // 141\n  var updateIndices = function (from, to) {                                                                            // 142\n    if (to === undefined) {                                                                                            // 143\n      to = eachView.numItems - 1;                                                                                      // 144\n    }                                                                                                                  // 145\n                                                                                                                       // 146\n    for (var i = from; i <= to; i++) {                                                                                 // 147\n      var view = eachView._domrange.members[i].view;                                                                   // 148\n      view._scopeBindings['@index'].set(i);                                                                            // 149\n    }                                                                                                                  // 150\n  };                                                                                                                   // 151\n                                                                                                                       // 152\n  eachView.onViewCreated(function () {                                                                                 // 153\n    // We evaluate argFunc in an autorun to make sure                                                                  // 154\n    // Blaze.currentView is always set when it runs (rather than                                                       // 155\n    // passing argFunc straight to ObserveSequence).                                                                   // 156\n    eachView.autorun(function () {                                                                                     // 157\n      // argFunc can return either a sequence as is or a wrapper object with a                                         // 158\n      // _sequence and _variable fields set.                                                                           // 159\n      var arg = argFunc();                                                                                             // 160\n      if (_.isObject(arg) && _.has(arg, '_sequence')) {                                                                // 161\n        eachView.variableName = arg._variable || null;                                                                 // 162\n        arg = arg._sequence;                                                                                           // 163\n      }                                                                                                                // 164\n                                                                                                                       // 165\n      eachView.argVar.set(arg);                                                                                        // 166\n    }, eachView.parentView, 'collection');                                                                             // 167\n                                                                                                                       // 168\n    eachView.stopHandle = ObserveSequence.observe(function () {                                                        // 169\n      return eachView.argVar.get();                                                                                    // 170\n    }, {                                                                                                               // 171\n      addedAt: function (id, item, index) {                                                                            // 172\n        Tracker.nonreactive(function () {                                                                              // 173\n          var newItemView;                                                                                             // 174\n          if (eachView.variableName) {                                                                                 // 175\n            // new-style #each (as in {{#each item in items}})                                                         // 176\n            // doesn't create a new data context                                                                       // 177\n            newItemView = Blaze.View('item', eachView.contentFunc);                                                    // 178\n          } else {                                                                                                     // 179\n            newItemView = Blaze.With(item, eachView.contentFunc);                                                      // 180\n          }                                                                                                            // 181\n                                                                                                                       // 182\n          eachView.numItems++;                                                                                         // 183\n                                                                                                                       // 184\n          var bindings = {};                                                                                           // 185\n          bindings['@index'] = index;                                                                                  // 186\n          if (eachView.variableName) {                                                                                 // 187\n            bindings[eachView.variableName] = item;                                                                    // 188\n          }                                                                                                            // 189\n          Blaze._attachBindingsToView(bindings, newItemView);                                                          // 190\n                                                                                                                       // 191\n          if (eachView.expandedValueDep) {                                                                             // 192\n            eachView.expandedValueDep.changed();                                                                       // 193\n          } else if (eachView._domrange) {                                                                             // 194\n            if (eachView.inElseMode) {                                                                                 // 195\n              eachView._domrange.removeMember(0);                                                                      // 196\n              eachView.inElseMode = false;                                                                             // 197\n            }                                                                                                          // 198\n                                                                                                                       // 199\n            var range = Blaze._materializeView(newItemView, eachView);                                                 // 200\n            eachView._domrange.addMember(range, index);                                                                // 201\n            updateIndices(index);                                                                                      // 202\n          } else {                                                                                                     // 203\n            eachView.initialSubviews.splice(index, 0, newItemView);                                                    // 204\n          }                                                                                                            // 205\n        });                                                                                                            // 206\n      },                                                                                                               // 207\n      removedAt: function (id, item, index) {                                                                          // 208\n        Tracker.nonreactive(function () {                                                                              // 209\n          eachView.numItems--;                                                                                         // 210\n          if (eachView.expandedValueDep) {                                                                             // 211\n            eachView.expandedValueDep.changed();                                                                       // 212\n          } else if (eachView._domrange) {                                                                             // 213\n            eachView._domrange.removeMember(index);                                                                    // 214\n            updateIndices(index);                                                                                      // 215\n            if (eachView.elseFunc && eachView.numItems === 0) {                                                        // 216\n              eachView.inElseMode = true;                                                                              // 217\n              eachView._domrange.addMember(                                                                            // 218\n                Blaze._materializeView(                                                                                // 219\n                  Blaze.View('each_else',eachView.elseFunc),                                                           // 220\n                  eachView), 0);                                                                                       // 221\n            }                                                                                                          // 222\n          } else {                                                                                                     // 223\n            eachView.initialSubviews.splice(index, 1);                                                                 // 224\n          }                                                                                                            // 225\n        });                                                                                                            // 226\n      },                                                                                                               // 227\n      changedAt: function (id, newItem, oldItem, index) {                                                              // 228\n        Tracker.nonreactive(function () {                                                                              // 229\n          if (eachView.expandedValueDep) {                                                                             // 230\n            eachView.expandedValueDep.changed();                                                                       // 231\n          } else {                                                                                                     // 232\n            var itemView;                                                                                              // 233\n            if (eachView._domrange) {                                                                                  // 234\n              itemView = eachView._domrange.getMember(index).view;                                                     // 235\n            } else {                                                                                                   // 236\n              itemView = eachView.initialSubviews[index];                                                              // 237\n            }                                                                                                          // 238\n            if (eachView.variableName) {                                                                               // 239\n              itemView._scopeBindings[eachView.variableName].set(newItem);                                             // 240\n            } else {                                                                                                   // 241\n              itemView.dataVar.set(newItem);                                                                           // 242\n            }                                                                                                          // 243\n          }                                                                                                            // 244\n        });                                                                                                            // 245\n      },                                                                                                               // 246\n      movedTo: function (id, item, fromIndex, toIndex) {                                                               // 247\n        Tracker.nonreactive(function () {                                                                              // 248\n          if (eachView.expandedValueDep) {                                                                             // 249\n            eachView.expandedValueDep.changed();                                                                       // 250\n          } else if (eachView._domrange) {                                                                             // 251\n            eachView._domrange.moveMember(fromIndex, toIndex);                                                         // 252\n            updateIndices(                                                                                             // 253\n              Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex));                                             // 254\n          } else {                                                                                                     // 255\n            var subviews = eachView.initialSubviews;                                                                   // 256\n            var itemView = subviews[fromIndex];                                                                        // 257\n            subviews.splice(fromIndex, 1);                                                                             // 258\n            subviews.splice(toIndex, 0, itemView);                                                                     // 259\n          }                                                                                                            // 260\n        });                                                                                                            // 261\n      }                                                                                                                // 262\n    });                                                                                                                // 263\n                                                                                                                       // 264\n    if (eachView.elseFunc && eachView.numItems === 0) {                                                                // 265\n      eachView.inElseMode = true;                                                                                      // 266\n      eachView.initialSubviews[0] =                                                                                    // 267\n        Blaze.View('each_else', eachView.elseFunc);                                                                    // 268\n    }                                                                                                                  // 269\n  });                                                                                                                  // 270\n                                                                                                                       // 271\n  eachView.onViewDestroyed(function () {                                                                               // 272\n    if (eachView.stopHandle)                                                                                           // 273\n      eachView.stopHandle.stop();                                                                                      // 274\n  });                                                                                                                  // 275\n                                                                                                                       // 276\n  return eachView;                                                                                                     // 277\n};                                                                                                                     // 278\n                                                                                                                       // 279\nBlaze._TemplateWith = function (arg, contentFunc) {                                                                    // 280\n  var w;                                                                                                               // 281\n                                                                                                                       // 282\n  var argFunc = arg;                                                                                                   // 283\n  if (typeof arg !== 'function') {                                                                                     // 284\n    argFunc = function () {                                                                                            // 285\n      return arg;                                                                                                      // 286\n    };                                                                                                                 // 287\n  }                                                                                                                    // 288\n                                                                                                                       // 289\n  // This is a little messy.  When we compile `{{> Template.contentBlock}}`, we                                        // 290\n  // wrap it in Blaze._InOuterTemplateScope in order to skip the intermediate                                          // 291\n  // parent Views in the current template.  However, when there's an argument                                          // 292\n  // (`{{> Template.contentBlock arg}}`), the argument needs to be evaluated                                           // 293\n  // in the original scope.  There's no good order to nest                                                             // 294\n  // Blaze._InOuterTemplateScope and Spacebars.TemplateWith to achieve this,                                           // 295\n  // so we wrap argFunc to run it in the \"original parentView\" of the                                                  // 296\n  // Blaze._InOuterTemplateScope.                                                                                      // 297\n  //                                                                                                                   // 298\n  // To make this better, reconsider _InOuterTemplateScope as a primitive.                                             // 299\n  // Longer term, evaluate expressions in the proper lexical scope.                                                    // 300\n  var wrappedArgFunc = function () {                                                                                   // 301\n    var viewToEvaluateArg = null;                                                                                      // 302\n    if (w.parentView && w.parentView.name === 'InOuterTemplateScope') {                                                // 303\n      viewToEvaluateArg = w.parentView.originalParentView;                                                             // 304\n    }                                                                                                                  // 305\n    if (viewToEvaluateArg) {                                                                                           // 306\n      return Blaze._withCurrentView(viewToEvaluateArg, argFunc);                                                       // 307\n    } else {                                                                                                           // 308\n      return argFunc();                                                                                                // 309\n    }                                                                                                                  // 310\n  };                                                                                                                   // 311\n                                                                                                                       // 312\n  var wrappedContentFunc = function () {                                                                               // 313\n    var content = contentFunc.call(this);                                                                              // 314\n                                                                                                                       // 315\n    // Since we are generating the Blaze._TemplateWith view for the                                                    // 316\n    // user, set the flag on the child view.  If `content` is a template,                                              // 317\n    // construct the View so that we can set the flag.                                                                 // 318\n    if (content instanceof Blaze.Template) {                                                                           // 319\n      content = content.constructView();                                                                               // 320\n    }                                                                                                                  // 321\n    if (content instanceof Blaze.View) {                                                                               // 322\n      content._hasGeneratedParent = true;                                                                              // 323\n    }                                                                                                                  // 324\n                                                                                                                       // 325\n    return content;                                                                                                    // 326\n  };                                                                                                                   // 327\n                                                                                                                       // 328\n  w = Blaze.With(wrappedArgFunc, wrappedContentFunc);                                                                  // 329\n  w.__isTemplateWith = true;                                                                                           // 330\n  return w;                                                                                                            // 331\n};                                                                                                                     // 332\n                                                                                                                       // 333\nBlaze._InOuterTemplateScope = function (templateView, contentFunc) {                                                   // 334\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);                                                          // 335\n  var parentView = templateView.parentView;                                                                            // 336\n                                                                                                                       // 337\n  // Hack so that if you call `{{> foo bar}}` and it expands into                                                      // 338\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template                                                   // 339\n  // that inserts `{{> Template.contentBlock}}`, the data context for                                                  // 340\n  // `Template.contentBlock` is not `bar` but the one enclosing that.                                                  // 341\n  if (parentView.__isTemplateWith)                                                                                     // 342\n    parentView = parentView.parentView;                                                                                // 343\n                                                                                                                       // 344\n  view.onViewCreated(function () {                                                                                     // 345\n    this.originalParentView = this.parentView;                                                                         // 346\n    this.parentView = parentView;                                                                                      // 347\n    this.__childDoesntStartNewLexicalScope = true;                                                                     // 348\n  });                                                                                                                  // 349\n  return view;                                                                                                         // 350\n};                                                                                                                     // 351\n                                                                                                                       // 352\n// XXX COMPAT WITH 0.9.0                                                                                               // 353\nBlaze.InOuterTemplateScope = Blaze._InOuterTemplateScope;                                                              // 354\n                                                                                                                       // 355\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/lookup.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nBlaze._globalHelpers = {};                                                                                             // 1\n                                                                                                                       // 2\n// Documented as Template.registerHelper.                                                                              // 3\n// This definition also provides back-compat for `UI.registerHelper`.                                                  // 4\nBlaze.registerHelper = function (name, func) {                                                                         // 5\n  Blaze._globalHelpers[name] = func;                                                                                   // 6\n};                                                                                                                     // 7\n                                                                                                                       // 8\nvar bindIfIsFunction = function (x, target) {                                                                          // 9\n  if (typeof x !== 'function')                                                                                         // 10\n    return x;                                                                                                          // 11\n  return _.bind(x, target);                                                                                            // 12\n};                                                                                                                     // 13\n                                                                                                                       // 14\n// If `x` is a function, binds the value of `this` for that function                                                   // 15\n// to the current data context.                                                                                        // 16\nvar bindDataContext = function (x) {                                                                                   // 17\n  if (typeof x === 'function') {                                                                                       // 18\n    return function () {                                                                                               // 19\n      var data = Blaze.getData();                                                                                      // 20\n      if (data == null)                                                                                                // 21\n        data = {};                                                                                                     // 22\n      return x.apply(data, arguments);                                                                                 // 23\n    };                                                                                                                 // 24\n  }                                                                                                                    // 25\n  return x;                                                                                                            // 26\n};                                                                                                                     // 27\n                                                                                                                       // 28\nBlaze._OLDSTYLE_HELPER = {};                                                                                           // 29\n                                                                                                                       // 30\nBlaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {                                               // 31\n  // XXX COMPAT WITH 0.9.3                                                                                             // 32\n  var isKnownOldStyleHelper = false;                                                                                   // 33\n                                                                                                                       // 34\n  if (template.__helpers.has(name)) {                                                                                  // 35\n    var helper = template.__helpers.get(name);                                                                         // 36\n    if (helper === Blaze._OLDSTYLE_HELPER) {                                                                           // 37\n      isKnownOldStyleHelper = true;                                                                                    // 38\n    } else if (helper != null) {                                                                                       // 39\n      return wrapHelper(bindDataContext(helper), tmplInstanceFunc);                                                    // 40\n    } else {                                                                                                           // 41\n      return null;                                                                                                     // 42\n    }                                                                                                                  // 43\n  }                                                                                                                    // 44\n                                                                                                                       // 45\n  // old-style helper                                                                                                  // 46\n  if (name in template) {                                                                                              // 47\n    // Only warn once per helper                                                                                       // 48\n    if (! isKnownOldStyleHelper) {                                                                                     // 49\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);                                                            // 50\n      if (! template._NOWARN_OLDSTYLE_HELPERS) {                                                                       // 51\n        Blaze._warn('Assigning helper with `' + template.viewName + '.' +                                              // 52\n                    name + ' = ...` is deprecated.  Use `' + template.viewName +                                       // 53\n                    '.helpers(...)` instead.');                                                                        // 54\n      }                                                                                                                // 55\n    }                                                                                                                  // 56\n    if (template[name] != null) {                                                                                      // 57\n      return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);                                            // 58\n    }                                                                                                                  // 59\n  }                                                                                                                    // 60\n                                                                                                                       // 61\n  return null;                                                                                                         // 62\n};                                                                                                                     // 63\n                                                                                                                       // 64\nvar wrapHelper = function (f, templateFunc) {                                                                          // 65\n  if (typeof f !== \"function\") {                                                                                       // 66\n    return f;                                                                                                          // 67\n  }                                                                                                                    // 68\n                                                                                                                       // 69\n  return function () {                                                                                                 // 70\n    var self = this;                                                                                                   // 71\n    var args = arguments;                                                                                              // 72\n                                                                                                                       // 73\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {                                        // 74\n      return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);                                    // 75\n    });                                                                                                                // 76\n  };                                                                                                                   // 77\n};                                                                                                                     // 78\n                                                                                                                       // 79\nBlaze._lexicalBindingLookup = function (view, name) {                                                                  // 80\n  var currentView = view;                                                                                              // 81\n  var blockHelpersStack = [];                                                                                          // 82\n                                                                                                                       // 83\n  // walk up the views stopping at a Spacebars.include or Template view that                                           // 84\n  // doesn't have an InOuterTemplateScope view as a parent                                                             // 85\n  do {                                                                                                                 // 86\n    // skip block helpers views                                                                                        // 87\n    // if we found the binding on the scope, return it                                                                 // 88\n    if (_.has(currentView._scopeBindings, name)) {                                                                     // 89\n      var bindingReactiveVar = currentView._scopeBindings[name];                                                       // 90\n      return function () {                                                                                             // 91\n        return bindingReactiveVar.get();                                                                               // 92\n      };                                                                                                               // 93\n    }                                                                                                                  // 94\n  } while (! (currentView.__startsNewLexicalScope &&                                                                   // 95\n              ! (currentView.parentView &&                                                                             // 96\n                 currentView.parentView.__childDoesntStartNewLexicalScope))                                            // 97\n           && (currentView = currentView.parentView));                                                                 // 98\n                                                                                                                       // 99\n  return null;                                                                                                         // 100\n};                                                                                                                     // 101\n                                                                                                                       // 102\n// templateInstance argument is provided to be available for possible                                                  // 103\n// alternative implementations of this function by 3rd party packages.                                                 // 104\nBlaze._getTemplate = function (name, templateInstance) {                                                               // 105\n  if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {                                  // 106\n    return Blaze.Template[name];                                                                                       // 107\n  }                                                                                                                    // 108\n  return null;                                                                                                         // 109\n};                                                                                                                     // 110\n                                                                                                                       // 111\nBlaze._getGlobalHelper = function (name, templateInstance) {                                                           // 112\n  if (Blaze._globalHelpers[name] != null) {                                                                            // 113\n    return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance);                                  // 114\n  }                                                                                                                    // 115\n  return null;                                                                                                         // 116\n};                                                                                                                     // 117\n                                                                                                                       // 118\n// Looks up a name, like \"foo\" or \"..\", as a helper of the                                                             // 119\n// current template; the name of a template; a global helper;                                                          // 120\n// or a property of the data context.  Called on the View of                                                           // 121\n// a template (i.e. a View with a `.template` property,                                                                // 122\n// where the helpers are).  Used for the first name in a                                                               // 123\n// \"path\" in a template tag, like \"foo\" in `{{foo.bar}}` or                                                            // 124\n// \"..\" in `{{frobulate ../blah}}`.                                                                                    // 125\n//                                                                                                                     // 126\n// Returns a function, a non-function value, or null.  If                                                              // 127\n// a function is found, it is bound appropriately.                                                                     // 128\n//                                                                                                                     // 129\n// NOTE: This function must not establish any reactive                                                                 // 130\n// dependencies itself.  If there is any reactivity in the                                                             // 131\n// value, lookup should return a function.                                                                             // 132\nBlaze.View.prototype.lookup = function (name, _options) {                                                              // 133\n  var template = this.template;                                                                                        // 134\n  var lookupTemplate = _options && _options.template;                                                                  // 135\n  var helper;                                                                                                          // 136\n  var binding;                                                                                                         // 137\n  var boundTmplInstance;                                                                                               // 138\n  var foundTemplate;                                                                                                   // 139\n                                                                                                                       // 140\n  if (this.templateInstance) {                                                                                         // 141\n    boundTmplInstance = _.bind(this.templateInstance, this);                                                           // 142\n  }                                                                                                                    // 143\n                                                                                                                       // 144\n  // 0. looking up the parent data context with the special \"../\" syntax                                               // 145\n  if (/^\\./.test(name)) {                                                                                              // 146\n    // starts with a dot. must be a series of dots which maps to an                                                    // 147\n    // ancestor of the appropriate height.                                                                             // 148\n    if (!/^(\\.)+$/.test(name))                                                                                         // 149\n      throw new Error(\"id starting with dot must be a series of dots\");                                                // 150\n                                                                                                                       // 151\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);                                              // 152\n                                                                                                                       // 153\n  }                                                                                                                    // 154\n                                                                                                                       // 155\n  // 1. look up a helper on the current template                                                                       // 156\n  if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {                  // 157\n    return helper;                                                                                                     // 158\n  }                                                                                                                    // 159\n                                                                                                                       // 160\n  // 2. look up a binding by traversing the lexical view hierarchy inside the                                          // 161\n  // current template                                                                                                  // 162\n  if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {                          // 163\n    return binding;                                                                                                    // 164\n  }                                                                                                                    // 165\n                                                                                                                       // 166\n  // 3. look up a template by name                                                                                     // 167\n  if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {                     // 168\n    return foundTemplate;                                                                                              // 169\n  }                                                                                                                    // 170\n                                                                                                                       // 171\n  // 4. look up a global helper                                                                                        // 172\n  if ((helper = Blaze._getGlobalHelper(name, boundTmplInstance)) != null) {                                            // 173\n    return helper;                                                                                                     // 174\n  }                                                                                                                    // 175\n                                                                                                                       // 176\n  // 5. look up in a data context                                                                                      // 177\n  return function () {                                                                                                 // 178\n    var isCalledAsFunction = (arguments.length > 0);                                                                   // 179\n    var data = Blaze.getData();                                                                                        // 180\n    var x = data && data[name];                                                                                        // 181\n    if (! x) {                                                                                                         // 182\n      if (lookupTemplate) {                                                                                            // 183\n        throw new Error(\"No such template: \" + name);                                                                  // 184\n      } else if (isCalledAsFunction) {                                                                                 // 185\n        throw new Error(\"No such function: \" + name);                                                                  // 186\n      } else if (name.charAt(0) === '@' && ((x === null) ||                                                            // 187\n                                            (x === undefined))) {                                                      // 188\n        // Throw an error if the user tries to use a `@directive`                                                      // 189\n        // that doesn't exist.  We don't implement all directives                                                      // 190\n        // from Handlebars, so there's a potential for confusion                                                       // 191\n        // if we fail silently.  On the other hand, we want to                                                         // 192\n        // throw late in case some app or package wants to provide                                                     // 193\n        // a missing directive.                                                                                        // 194\n        throw new Error(\"Unsupported directive: \" + name);                                                             // 195\n      }                                                                                                                // 196\n    }                                                                                                                  // 197\n    if (! data) {                                                                                                      // 198\n      return null;                                                                                                     // 199\n    }                                                                                                                  // 200\n    if (typeof x !== 'function') {                                                                                     // 201\n      if (isCalledAsFunction) {                                                                                        // 202\n        throw new Error(\"Can't call non-function: \" + x);                                                              // 203\n      }                                                                                                                // 204\n      return x;                                                                                                        // 205\n    }                                                                                                                  // 206\n    return x.apply(data, arguments);                                                                                   // 207\n  };                                                                                                                   // 208\n};                                                                                                                     // 209\n                                                                                                                       // 210\n// Implement Spacebars' {{../..}}.                                                                                     // 211\n// @param height {Number} The number of '..'s                                                                          // 212\nBlaze._parentData = function (height, _functionWrapped) {                                                              // 213\n  // If height is null or undefined, we default to 1, the first parent.                                                // 214\n  if (height == null) {                                                                                                // 215\n    height = 1;                                                                                                        // 216\n  }                                                                                                                    // 217\n  var theWith = Blaze.getView('with');                                                                                 // 218\n  for (var i = 0; (i < height) && theWith; i++) {                                                                      // 219\n    theWith = Blaze.getView(theWith, 'with');                                                                          // 220\n  }                                                                                                                    // 221\n                                                                                                                       // 222\n  if (! theWith)                                                                                                       // 223\n    return null;                                                                                                       // 224\n  if (_functionWrapped)                                                                                                // 225\n    return function () { return theWith.dataVar.get(); };                                                              // 226\n  return theWith.dataVar.get();                                                                                        // 227\n};                                                                                                                     // 228\n                                                                                                                       // 229\n                                                                                                                       // 230\nBlaze.View.prototype.lookupTemplate = function (name) {                                                                // 231\n  return this.lookup(name, {template:true});                                                                           // 232\n};                                                                                                                     // 233\n                                                                                                                       // 234\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/template.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// [new] Blaze.Template([viewName], renderFunction)                                                                    // 1\n//                                                                                                                     // 2\n// `Blaze.Template` is the class of templates, like `Template.foo` in                                                  // 3\n// Meteor, which is `instanceof Template`.                                                                             // 4\n//                                                                                                                     // 5\n// `viewKind` is a string that looks like \"Template.foo\" for templates                                                 // 6\n// defined by the compiler.                                                                                            // 7\n                                                                                                                       // 8\n/**                                                                                                                    // 9\n * @class                                                                                                              // 10\n * @summary Constructor for a Template, which is used to construct Views with particular name and content.             // 11\n * @locus Client                                                                                                       // 12\n * @param {String} [viewName] Optional.  A name for Views constructed by this Template.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  This function is used as the `renderFunction` for Views constructed by this Template.\n */                                                                                                                    // 15\nBlaze.Template = function (viewName, renderFunction) {                                                                 // 16\n  if (! (this instanceof Blaze.Template))                                                                              // 17\n    // called without `new`                                                                                            // 18\n    return new Blaze.Template(viewName, renderFunction);                                                               // 19\n                                                                                                                       // 20\n  if (typeof viewName === 'function') {                                                                                // 21\n    // omitted \"viewName\" argument                                                                                     // 22\n    renderFunction = viewName;                                                                                         // 23\n    viewName = '';                                                                                                     // 24\n  }                                                                                                                    // 25\n  if (typeof viewName !== 'string')                                                                                    // 26\n    throw new Error(\"viewName must be a String (or omitted)\");                                                         // 27\n  if (typeof renderFunction !== 'function')                                                                            // 28\n    throw new Error(\"renderFunction must be a function\");                                                              // 29\n                                                                                                                       // 30\n  this.viewName = viewName;                                                                                            // 31\n  this.renderFunction = renderFunction;                                                                                // 32\n                                                                                                                       // 33\n  this.__helpers = new HelperMap;                                                                                      // 34\n  this.__eventMaps = [];                                                                                               // 35\n                                                                                                                       // 36\n  this._callbacks = {                                                                                                  // 37\n    created: [],                                                                                                       // 38\n    rendered: [],                                                                                                      // 39\n    destroyed: []                                                                                                      // 40\n  };                                                                                                                   // 41\n};                                                                                                                     // 42\nvar Template = Blaze.Template;                                                                                         // 43\n                                                                                                                       // 44\nvar HelperMap = function () {};                                                                                        // 45\nHelperMap.prototype.get = function (name) {                                                                            // 46\n  return this[' '+name];                                                                                               // 47\n};                                                                                                                     // 48\nHelperMap.prototype.set = function (name, helper) {                                                                    // 49\n  this[' '+name] = helper;                                                                                             // 50\n};                                                                                                                     // 51\nHelperMap.prototype.has = function (name) {                                                                            // 52\n  return (' '+name) in this;                                                                                           // 53\n};                                                                                                                     // 54\n                                                                                                                       // 55\n/**                                                                                                                    // 56\n * @summary Returns true if `value` is a template object like `Template.myTemplate`.                                   // 57\n * @locus Client                                                                                                       // 58\n * @param {Any} value The value to test.                                                                               // 59\n */                                                                                                                    // 60\nBlaze.isTemplate = function (t) {                                                                                      // 61\n  return (t instanceof Blaze.Template);                                                                                // 62\n};                                                                                                                     // 63\n                                                                                                                       // 64\n/**                                                                                                                    // 65\n * @name  onCreated                                                                                                    // 66\n * @instance                                                                                                           // 67\n * @memberOf Template                                                                                                  // 68\n * @summary Register a function to be called when an instance of this template is created.                             // 69\n * @param {Function} callback A function to be added as a callback.                                                    // 70\n * @locus Client                                                                                                       // 71\n */                                                                                                                    // 72\nTemplate.prototype.onCreated = function (cb) {                                                                         // 73\n  this._callbacks.created.push(cb);                                                                                    // 74\n};                                                                                                                     // 75\n                                                                                                                       // 76\n/**                                                                                                                    // 77\n * @name  onRendered                                                                                                   // 78\n * @instance                                                                                                           // 79\n * @memberOf Template                                                                                                  // 80\n * @summary Register a function to be called when an instance of this template is inserted into the DOM.               // 81\n * @param {Function} callback A function to be added as a callback.                                                    // 82\n * @locus Client                                                                                                       // 83\n */                                                                                                                    // 84\nTemplate.prototype.onRendered = function (cb) {                                                                        // 85\n  this._callbacks.rendered.push(cb);                                                                                   // 86\n};                                                                                                                     // 87\n                                                                                                                       // 88\n/**                                                                                                                    // 89\n * @name  onDestroyed                                                                                                  // 90\n * @instance                                                                                                           // 91\n * @memberOf Template                                                                                                  // 92\n * @summary Register a function to be called when an instance of this template is removed from the DOM and destroyed.  // 93\n * @param {Function} callback A function to be added as a callback.                                                    // 94\n * @locus Client                                                                                                       // 95\n */                                                                                                                    // 96\nTemplate.prototype.onDestroyed = function (cb) {                                                                       // 97\n  this._callbacks.destroyed.push(cb);                                                                                  // 98\n};                                                                                                                     // 99\n                                                                                                                       // 100\nTemplate.prototype._getCallbacks = function (which) {                                                                  // 101\n  var self = this;                                                                                                     // 102\n  var callbacks = self[which] ? [self[which]] : [];                                                                    // 103\n  // Fire all callbacks added with the new API (Template.onRendered())                                                 // 104\n  // as well as the old-style callback (e.g. Template.rendered) for                                                    // 105\n  // backwards-compatibility.                                                                                          // 106\n  callbacks = callbacks.concat(self._callbacks[which]);                                                                // 107\n  return callbacks;                                                                                                    // 108\n};                                                                                                                     // 109\n                                                                                                                       // 110\nvar fireCallbacks = function (callbacks, template) {                                                                   // 111\n  Template._withTemplateInstanceFunc(                                                                                  // 112\n    function () { return template; },                                                                                  // 113\n    function () {                                                                                                      // 114\n      for (var i = 0, N = callbacks.length; i < N; i++) {                                                              // 115\n        callbacks[i].call(template);                                                                                   // 116\n      }                                                                                                                // 117\n    });                                                                                                                // 118\n};                                                                                                                     // 119\n                                                                                                                       // 120\nTemplate.prototype.constructView = function (contentFunc, elseFunc) {                                                  // 121\n  var self = this;                                                                                                     // 122\n  var view = Blaze.View(self.viewName, self.renderFunction);                                                           // 123\n  view.template = self;                                                                                                // 124\n                                                                                                                       // 125\n  view.templateContentBlock = (                                                                                        // 126\n    contentFunc ? new Template('(contentBlock)', contentFunc) : null);                                                 // 127\n  view.templateElseBlock = (                                                                                           // 128\n    elseFunc ? new Template('(elseBlock)', elseFunc) : null);                                                          // 129\n                                                                                                                       // 130\n  if (self.__eventMaps || typeof self.events === 'object') {                                                           // 131\n    view._onViewRendered(function () {                                                                                 // 132\n      if (view.renderCount !== 1)                                                                                      // 133\n        return;                                                                                                        // 134\n                                                                                                                       // 135\n      if (! self.__eventMaps.length && typeof self.events === \"object\") {                                              // 136\n        // Provide limited back-compat support for `.events = {...}`                                                   // 137\n        // syntax.  Pass `template.events` to the original `.events(...)`                                              // 138\n        // function.  This code must run only once per template, in                                                    // 139\n        // order to not bind the handlers more than once, which is                                                     // 140\n        // ensured by the fact that we only do this when `__eventMaps`                                                 // 141\n        // is falsy, and we cause it to be set now.                                                                    // 142\n        Template.prototype.events.call(self, self.events);                                                             // 143\n      }                                                                                                                // 144\n                                                                                                                       // 145\n      _.each(self.__eventMaps, function (m) {                                                                          // 146\n        Blaze._addEventMap(view, m, view);                                                                             // 147\n      });                                                                                                              // 148\n    });                                                                                                                // 149\n  }                                                                                                                    // 150\n                                                                                                                       // 151\n  view._templateInstance = new Blaze.TemplateInstance(view);                                                           // 152\n  view.templateInstance = function () {                                                                                // 153\n    // Update data, firstNode, and lastNode, and return the TemplateInstance                                           // 154\n    // object.                                                                                                         // 155\n    var inst = view._templateInstance;                                                                                 // 156\n                                                                                                                       // 157\n    /**                                                                                                                // 158\n     * @instance                                                                                                       // 159\n     * @memberOf Blaze.TemplateInstance                                                                                // 160\n     * @name  data                                                                                                     // 161\n     * @summary The data context of this instance's latest invocation.                                                 // 162\n     * @locus Client                                                                                                   // 163\n     */                                                                                                                // 164\n    inst.data = Blaze.getData(view);                                                                                   // 165\n                                                                                                                       // 166\n    if (view._domrange && !view.isDestroyed) {                                                                         // 167\n      inst.firstNode = view._domrange.firstNode();                                                                     // 168\n      inst.lastNode = view._domrange.lastNode();                                                                       // 169\n    } else {                                                                                                           // 170\n      // on 'created' or 'destroyed' callbacks we don't have a DomRange                                                // 171\n      inst.firstNode = null;                                                                                           // 172\n      inst.lastNode = null;                                                                                            // 173\n    }                                                                                                                  // 174\n                                                                                                                       // 175\n    return inst;                                                                                                       // 176\n  };                                                                                                                   // 177\n                                                                                                                       // 178\n  /**                                                                                                                  // 179\n   * @name  created                                                                                                    // 180\n   * @instance                                                                                                         // 181\n   * @memberOf Template                                                                                                // 182\n   * @summary Provide a callback when an instance of a template is created.                                            // 183\n   * @locus Client                                                                                                     // 184\n   * @deprecated in 1.1                                                                                                // 185\n   */                                                                                                                  // 186\n  // To avoid situations when new callbacks are added in between view                                                  // 187\n  // instantiation and event being fired, decide on all callbacks to fire                                              // 188\n  // immediately and then fire them on the event.                                                                      // 189\n  var createdCallbacks = self._getCallbacks('created');                                                                // 190\n  view.onViewCreated(function () {                                                                                     // 191\n    fireCallbacks(createdCallbacks, view.templateInstance());                                                          // 192\n  });                                                                                                                  // 193\n                                                                                                                       // 194\n  /**                                                                                                                  // 195\n   * @name  rendered                                                                                                   // 196\n   * @instance                                                                                                         // 197\n   * @memberOf Template                                                                                                // 198\n   * @summary Provide a callback when an instance of a template is rendered.                                           // 199\n   * @locus Client                                                                                                     // 200\n   * @deprecated in 1.1                                                                                                // 201\n   */                                                                                                                  // 202\n  var renderedCallbacks = self._getCallbacks('rendered');                                                              // 203\n  view.onViewReady(function () {                                                                                       // 204\n    fireCallbacks(renderedCallbacks, view.templateInstance());                                                         // 205\n  });                                                                                                                  // 206\n                                                                                                                       // 207\n  /**                                                                                                                  // 208\n   * @name  destroyed                                                                                                  // 209\n   * @instance                                                                                                         // 210\n   * @memberOf Template                                                                                                // 211\n   * @summary Provide a callback when an instance of a template is destroyed.                                          // 212\n   * @locus Client                                                                                                     // 213\n   * @deprecated in 1.1                                                                                                // 214\n   */                                                                                                                  // 215\n  var destroyedCallbacks = self._getCallbacks('destroyed');                                                            // 216\n  view.onViewDestroyed(function () {                                                                                   // 217\n    fireCallbacks(destroyedCallbacks, view.templateInstance());                                                        // 218\n  });                                                                                                                  // 219\n                                                                                                                       // 220\n  return view;                                                                                                         // 221\n};                                                                                                                     // 222\n                                                                                                                       // 223\n/**                                                                                                                    // 224\n * @class                                                                                                              // 225\n * @summary The class for template instances                                                                           // 226\n * @param {Blaze.View} view                                                                                            // 227\n * @instanceName template                                                                                              // 228\n */                                                                                                                    // 229\nBlaze.TemplateInstance = function (view) {                                                                             // 230\n  if (! (this instanceof Blaze.TemplateInstance))                                                                      // 231\n    // called without `new`                                                                                            // 232\n    return new Blaze.TemplateInstance(view);                                                                           // 233\n                                                                                                                       // 234\n  if (! (view instanceof Blaze.View))                                                                                  // 235\n    throw new Error(\"View required\");                                                                                  // 236\n                                                                                                                       // 237\n  view._templateInstance = this;                                                                                       // 238\n                                                                                                                       // 239\n  /**                                                                                                                  // 240\n   * @name view                                                                                                        // 241\n   * @memberOf Blaze.TemplateInstance                                                                                  // 242\n   * @instance                                                                                                         // 243\n   * @summary The [View](#blaze_view) object for this invocation of the template.                                      // 244\n   * @locus Client                                                                                                     // 245\n   * @type {Blaze.View}                                                                                                // 246\n   */                                                                                                                  // 247\n  this.view = view;                                                                                                    // 248\n  this.data = null;                                                                                                    // 249\n                                                                                                                       // 250\n  /**                                                                                                                  // 251\n   * @name firstNode                                                                                                   // 252\n   * @memberOf Blaze.TemplateInstance                                                                                  // 253\n   * @instance                                                                                                         // 254\n   * @summary The first top-level DOM node in this template instance.                                                  // 255\n   * @locus Client                                                                                                     // 256\n   * @type {DOMNode}                                                                                                   // 257\n   */                                                                                                                  // 258\n  this.firstNode = null;                                                                                               // 259\n                                                                                                                       // 260\n  /**                                                                                                                  // 261\n   * @name lastNode                                                                                                    // 262\n   * @memberOf Blaze.TemplateInstance                                                                                  // 263\n   * @instance                                                                                                         // 264\n   * @summary The last top-level DOM node in this template instance.                                                   // 265\n   * @locus Client                                                                                                     // 266\n   * @type {DOMNode}                                                                                                   // 267\n   */                                                                                                                  // 268\n  this.lastNode = null;                                                                                                // 269\n                                                                                                                       // 270\n  // This dependency is used to identify state transitions in                                                          // 271\n  // _subscriptionHandles which could cause the result of                                                              // 272\n  // TemplateInstance#subscriptionsReady to change. Basically this is triggered                                        // 273\n  // whenever a new subscription handle is added or when a subscription handle                                         // 274\n  // is removed and they are not ready.                                                                                // 275\n  this._allSubsReadyDep = new Tracker.Dependency();                                                                    // 276\n  this._allSubsReady = false;                                                                                          // 277\n                                                                                                                       // 278\n  this._subscriptionHandles = {};                                                                                      // 279\n};                                                                                                                     // 280\n                                                                                                                       // 281\n/**                                                                                                                    // 282\n * @summary Find all elements matching `selector` in this template instance, and return them as a JQuery object.       // 283\n * @locus Client                                                                                                       // 284\n * @param {String} selector The CSS selector to match, scoped to the template contents.                                // 285\n * @returns {DOMNode[]}                                                                                                // 286\n */                                                                                                                    // 287\nBlaze.TemplateInstance.prototype.$ = function (selector) {                                                             // 288\n  var view = this.view;                                                                                                // 289\n  if (! view._domrange)                                                                                                // 290\n    throw new Error(\"Can't use $ on template instance with no DOM\");                                                   // 291\n  return view._domrange.$(selector);                                                                                   // 292\n};                                                                                                                     // 293\n                                                                                                                       // 294\n/**                                                                                                                    // 295\n * @summary Find all elements matching `selector` in this template instance.                                           // 296\n * @locus Client                                                                                                       // 297\n * @param {String} selector The CSS selector to match, scoped to the template contents.                                // 298\n * @returns {DOMElement[]}                                                                                             // 299\n */                                                                                                                    // 300\nBlaze.TemplateInstance.prototype.findAll = function (selector) {                                                       // 301\n  return Array.prototype.slice.call(this.$(selector));                                                                 // 302\n};                                                                                                                     // 303\n                                                                                                                       // 304\n/**                                                                                                                    // 305\n * @summary Find one element matching `selector` in this template instance.                                            // 306\n * @locus Client                                                                                                       // 307\n * @param {String} selector The CSS selector to match, scoped to the template contents.                                // 308\n * @returns {DOMElement}                                                                                               // 309\n */                                                                                                                    // 310\nBlaze.TemplateInstance.prototype.find = function (selector) {                                                          // 311\n  var result = this.$(selector);                                                                                       // 312\n  return result[0] || null;                                                                                            // 313\n};                                                                                                                     // 314\n                                                                                                                       // 315\n/**                                                                                                                    // 316\n * @summary A version of [Tracker.autorun](#tracker_autorun) that is stopped when the template is destroyed.           // 317\n * @locus Client                                                                                                       // 318\n * @param {Function} runFunc The function to run. It receives one argument: a Tracker.Computation object.              // 319\n */                                                                                                                    // 320\nBlaze.TemplateInstance.prototype.autorun = function (f) {                                                              // 321\n  return this.view.autorun(f);                                                                                         // 322\n};                                                                                                                     // 323\n                                                                                                                       // 324\n/**                                                                                                                    // 325\n * @summary A version of [Meteor.subscribe](#meteor_subscribe) that is stopped                                         // 326\n * when the template is destroyed.                                                                                     // 327\n * @return {SubscriptionHandle} The subscription handle to the newly made                                              // 328\n * subscription. Call `handle.stop()` to manually stop the subscription, or                                            // 329\n * `handle.ready()` to find out if this particular subscription has loaded all                                         // 330\n * of its inital data.                                                                                                 // 331\n * @locus Client                                                                                                       // 332\n * @param {String} name Name of the subscription.  Matches the name of the                                             // 333\n * server's `publish()` call.                                                                                          // 334\n * @param {Any} [arg1,arg2...] Optional arguments passed to publisher function                                         // 335\n * on server.                                                                                                          // 336\n * @param {Function|Object} [options] If a function is passed instead of an                                            // 337\n * object, it is interpreted as an `onReady` callback.                                                                 // 338\n * @param {Function} [options.onReady] Passed to [`Meteor.subscribe`](#meteor_subscribe).                              // 339\n * @param {Function} [options.onStop] Passed to [`Meteor.subscribe`](#meteor_subscribe).                               // 340\n * @param {DDP.Connection} [options.connection] The connection on which to make the                                    // 341\n * subscription.                                                                                                       // 342\n */                                                                                                                    // 343\nBlaze.TemplateInstance.prototype.subscribe = function (/* arguments */) {                                              // 344\n  var self = this;                                                                                                     // 345\n                                                                                                                       // 346\n  var subHandles = self._subscriptionHandles;                                                                          // 347\n  var args = _.toArray(arguments);                                                                                     // 348\n                                                                                                                       // 349\n  // Duplicate logic from Meteor.subscribe                                                                             // 350\n  var options = {};                                                                                                    // 351\n  if (args.length) {                                                                                                   // 352\n    var lastParam = _.last(args);                                                                                      // 353\n                                                                                                                       // 354\n    // Match pattern to check if the last arg is an options argument                                                   // 355\n    var lastParamOptionsPattern = {                                                                                    // 356\n      onReady: Match.Optional(Function),                                                                               // 357\n      // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                                 // 358\n      // onStop with an error callback instead.                                                                        // 359\n      onError: Match.Optional(Function),                                                                               // 360\n      onStop: Match.Optional(Function),                                                                                // 361\n      connection: Match.Optional(Match.Any)                                                                            // 362\n    };                                                                                                                 // 363\n                                                                                                                       // 364\n    if (_.isFunction(lastParam)) {                                                                                     // 365\n      options.onReady = args.pop();                                                                                    // 366\n    } else if (lastParam && Match.test(lastParam, lastParamOptionsPattern)) {                                          // 367\n      options = args.pop();                                                                                            // 368\n    }                                                                                                                  // 369\n  }                                                                                                                    // 370\n                                                                                                                       // 371\n  var subHandle;                                                                                                       // 372\n  var oldStopped = options.onStop;                                                                                     // 373\n  options.onStop = function (error) {                                                                                  // 374\n    // When the subscription is stopped, remove it from the set of tracked                                             // 375\n    // subscriptions to avoid this list growing without bound                                                          // 376\n    delete subHandles[subHandle.subscriptionId];                                                                       // 377\n                                                                                                                       // 378\n    // Removing a subscription can only change the result of subscriptionsReady                                        // 379\n    // if we are not ready (that subscription could be the one blocking us being                                       // 380\n    // ready).                                                                                                         // 381\n    if (! self._allSubsReady) {                                                                                        // 382\n      self._allSubsReadyDep.changed();                                                                                 // 383\n    }                                                                                                                  // 384\n                                                                                                                       // 385\n    if (oldStopped) {                                                                                                  // 386\n      oldStopped(error);                                                                                               // 387\n    }                                                                                                                  // 388\n  };                                                                                                                   // 389\n                                                                                                                       // 390\n  var connection = options.connection;                                                                                 // 391\n  var callbacks = _.pick(options, [\"onReady\", \"onError\", \"onStop\"]);                                                   // 392\n                                                                                                                       // 393\n  // The callbacks are passed as the last item in the arguments array passed to                                        // 394\n  // View#subscribe                                                                                                    // 395\n  args.push(callbacks);                                                                                                // 396\n                                                                                                                       // 397\n  // View#subscribe takes the connection as one of the options in the last                                             // 398\n  // argument                                                                                                          // 399\n  subHandle = self.view.subscribe.call(self.view, args, {                                                              // 400\n    connection: connection                                                                                             // 401\n  });                                                                                                                  // 402\n                                                                                                                       // 403\n  if (! _.has(subHandles, subHandle.subscriptionId)) {                                                                 // 404\n    subHandles[subHandle.subscriptionId] = subHandle;                                                                  // 405\n                                                                                                                       // 406\n    // Adding a new subscription will always cause us to transition from ready                                         // 407\n    // to not ready, but if we are already not ready then this can't make us                                           // 408\n    // ready.                                                                                                          // 409\n    if (self._allSubsReady) {                                                                                          // 410\n      self._allSubsReadyDep.changed();                                                                                 // 411\n    }                                                                                                                  // 412\n  }                                                                                                                    // 413\n                                                                                                                       // 414\n  return subHandle;                                                                                                    // 415\n};                                                                                                                     // 416\n                                                                                                                       // 417\n/**                                                                                                                    // 418\n * @summary A reactive function that returns true when all of the subscriptions                                        // 419\n * called with [this.subscribe](#TemplateInstance-subscribe) are ready.                                                // 420\n * @return {Boolean} True if all subscriptions on this template instance are                                           // 421\n * ready.                                                                                                              // 422\n */                                                                                                                    // 423\nBlaze.TemplateInstance.prototype.subscriptionsReady = function () {                                                    // 424\n  this._allSubsReadyDep.depend();                                                                                      // 425\n                                                                                                                       // 426\n  this._allSubsReady = _.all(this._subscriptionHandles, function (handle) {                                            // 427\n    return handle.ready();                                                                                             // 428\n  });                                                                                                                  // 429\n                                                                                                                       // 430\n  return this._allSubsReady;                                                                                           // 431\n};                                                                                                                     // 432\n                                                                                                                       // 433\n/**                                                                                                                    // 434\n * @summary Specify template helpers available to this template.                                                       // 435\n * @locus Client                                                                                                       // 436\n * @param {Object} helpers Dictionary of helper functions by name.                                                     // 437\n */                                                                                                                    // 438\nTemplate.prototype.helpers = function (dict) {                                                                         // 439\n  for (var k in dict)                                                                                                  // 440\n    this.__helpers.set(k, dict[k]);                                                                                    // 441\n};                                                                                                                     // 442\n                                                                                                                       // 443\n// Kind of like Blaze.currentView but for the template instance.                                                       // 444\n// This is a function, not a value -- so that not all helpers                                                          // 445\n// are implicitly dependent on the current template instance's `data` property,                                        // 446\n// which would make them dependenct on the data context of the template                                                // 447\n// inclusion.                                                                                                          // 448\nTemplate._currentTemplateInstanceFunc = null;                                                                          // 449\n                                                                                                                       // 450\nTemplate._withTemplateInstanceFunc = function (templateInstanceFunc, func) {                                           // 451\n  if (typeof func !== 'function')                                                                                      // 452\n    throw new Error(\"Expected function, got: \" + func);                                                                // 453\n  var oldTmplInstanceFunc = Template._currentTemplateInstanceFunc;                                                     // 454\n  try {                                                                                                                // 455\n    Template._currentTemplateInstanceFunc = templateInstanceFunc;                                                      // 456\n    return func();                                                                                                     // 457\n  } finally {                                                                                                          // 458\n    Template._currentTemplateInstanceFunc = oldTmplInstanceFunc;                                                       // 459\n  }                                                                                                                    // 460\n};                                                                                                                     // 461\n                                                                                                                       // 462\n/**                                                                                                                    // 463\n * @summary Specify event handlers for this template.                                                                  // 464\n * @locus Client                                                                                                       // 465\n * @param {EventMap} eventMap Event handlers to associate with this template.                                          // 466\n */                                                                                                                    // 467\nTemplate.prototype.events = function (eventMap) {                                                                      // 468\n  var template = this;                                                                                                 // 469\n  var eventMap2 = {};                                                                                                  // 470\n  for (var k in eventMap) {                                                                                            // 471\n    eventMap2[k] = (function (k, v) {                                                                                  // 472\n      return function (event/*, ...*/) {                                                                               // 473\n        var view = this; // passed by EventAugmenter                                                                   // 474\n        var data = Blaze.getData(event.currentTarget);                                                                 // 475\n        if (data == null)                                                                                              // 476\n          data = {};                                                                                                   // 477\n        var args = Array.prototype.slice.call(arguments);                                                              // 478\n        var tmplInstanceFunc = _.bind(view.templateInstance, view);                                                    // 479\n        args.splice(1, 0, tmplInstanceFunc());                                                                         // 480\n                                                                                                                       // 481\n        return Template._withTemplateInstanceFunc(tmplInstanceFunc, function () {                                      // 482\n          return v.apply(data, args);                                                                                  // 483\n        });                                                                                                            // 484\n      };                                                                                                               // 485\n    })(k, eventMap[k]);                                                                                                // 486\n  }                                                                                                                    // 487\n                                                                                                                       // 488\n  template.__eventMaps.push(eventMap2);                                                                                // 489\n};                                                                                                                     // 490\n                                                                                                                       // 491\n/**                                                                                                                    // 492\n * @function                                                                                                           // 493\n * @name instance                                                                                                      // 494\n * @memberOf Template                                                                                                  // 495\n * @summary The [template instance](#template_inst) corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client                                                                                                       // 497\n * @returns {Blaze.TemplateInstance}                                                                                   // 498\n */                                                                                                                    // 499\nTemplate.instance = function () {                                                                                      // 500\n  return Template._currentTemplateInstanceFunc                                                                         // 501\n    && Template._currentTemplateInstanceFunc();                                                                        // 502\n};                                                                                                                     // 503\n                                                                                                                       // 504\n// Note: Template.currentData() is documented to take zero arguments,                                                  // 505\n// while Blaze.getData takes up to one.                                                                                // 506\n                                                                                                                       // 507\n/**                                                                                                                    // 508\n * @summary                                                                                                            // 509\n *                                                                                                                     // 510\n * - Inside an `onCreated`, `onRendered`, or `onDestroyed` callback, returns                                           // 511\n * the data context of the template.                                                                                   // 512\n * - Inside an event handler, returns the data context of the template on which                                        // 513\n * this event handler was defined.                                                                                     // 514\n * - Inside a helper, returns the data context of the DOM node where the helper                                        // 515\n * was used.                                                                                                           // 516\n *                                                                                                                     // 517\n * Establishes a reactive dependency on the result.                                                                    // 518\n * @locus Client                                                                                                       // 519\n * @function                                                                                                           // 520\n */                                                                                                                    // 521\nTemplate.currentData = Blaze.getData;                                                                                  // 522\n                                                                                                                       // 523\n/**                                                                                                                    // 524\n * @summary Accesses other data contexts that enclose the current data context.                                        // 525\n * @locus Client                                                                                                       // 526\n * @function                                                                                                           // 527\n * @param {Integer} [numLevels] The number of levels beyond the current data context to look. Defaults to 1.           // 528\n */                                                                                                                    // 529\nTemplate.parentData = Blaze._parentData;                                                                               // 530\n                                                                                                                       // 531\n/**                                                                                                                    // 532\n * @summary Defines a [helper function](#template_helpers) which can be used from all templates.                       // 533\n * @locus Client                                                                                                       // 534\n * @function                                                                                                           // 535\n * @param {String} name The name of the helper function you are defining.                                              // 536\n * @param {Function} function The helper function itself.                                                              // 537\n */                                                                                                                    // 538\nTemplate.registerHelper = Blaze.registerHelper;                                                                        // 539\n                                                                                                                       // 540\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/backcompat.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nUI = Blaze;                                                                                                            // 1\n                                                                                                                       // 2\nBlaze.ReactiveVar = ReactiveVar;                                                                                       // 3\nUI._templateInstance = Blaze.Template.instance;                                                                        // 4\n                                                                                                                       // 5\nHandlebars = {};                                                                                                       // 6\nHandlebars.registerHelper = Blaze.registerHelper;                                                                      // 7\n                                                                                                                       // 8\nHandlebars._escape = Blaze._escape;                                                                                    // 9\n                                                                                                                       // 10\n// Return these from {{...}} helpers to achieve the same as returning                                                  // 11\n// strings from {{{...}}} helpers                                                                                      // 12\nHandlebars.SafeString = function(string) {                                                                             // 13\n  this.string = string;                                                                                                // 14\n};                                                                                                                     // 15\nHandlebars.SafeString.prototype.toString = function() {                                                                // 16\n  return this.string.toString();                                                                                       // 17\n};                                                                                                                     // 18\n                                                                                                                       // 19\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.blaze = {\n  Blaze: Blaze,\n  UI: UI,\n  Handlebars: Handlebars\n};\n\n})();\n","servePath":"/packages/blaze.js","sourceMap":{"version":3,"sources":["/packages/blaze/preamble.js","/packages/blaze/dombackend.js","/packages/blaze/domrange.js","/packages/blaze/events.js","/packages/blaze/attrs.js","/packages/blaze/materializer.js","/packages/blaze/exceptions.js","/packages/blaze/view.js","/packages/blaze/builtins.js","/packages/blaze/lookup.js","/packages/blaze/template.js","/packages/blaze/backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AC3hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H","file":"/packages/blaze.js","sourcesContent":["/**\n * @namespace Blaze\n * @summary The namespace for all Blaze-related methods and classes.\n */\nBlaze = {};\n\n// Utility to HTML-escape a string.  Included for legacy reasons.\nBlaze._escape = (function() {\n  var escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  var escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\nBlaze._warn = function (msg) {\n  msg = 'Warning: ' + msg;\n\n  if ((typeof console !== 'undefined') && console.warn) {\n    console.warn(msg);\n  }\n};\n","var DOMBackend = {};\nBlaze._DOMBackend = DOMBackend;\n\nvar $jq = (typeof jQuery !== 'undefined' ? jQuery :\n           (typeof Package !== 'undefined' ?\n            Package.jquery && Package.jquery.jQuery : null));\nif (! $jq)\n  throw new Error(\"jQuery not found\");\n\nDOMBackend._$jq = $jq;\n\nDOMBackend.parseHTML = function (html) {\n  // Return an array of nodes.\n  //\n  // jQuery does fancy stuff like creating an appropriate\n  // container element and setting innerHTML on it, as well\n  // as working around various IE quirks.\n  return $jq.parseHTML(html) || [];\n};\n\nDOMBackend.Events = {\n  // `selector` is non-null.  `type` is one type (but\n  // may be in backend-specific form, e.g. have namespaces).\n  // Order fired must be order bound.\n  delegateEvents: function (elem, type, selector, handler) {\n    $jq(elem).on(type, selector, handler);\n  },\n\n  undelegateEvents: function (elem, type, handler) {\n    $jq(elem).off(type, '**', handler);\n  },\n\n  bindEventCapturer: function (elem, type, selector, handler) {\n    var $elem = $jq(elem);\n\n    var wrapper = function (event) {\n      event = $jq.event.fix(event);\n      event.currentTarget = event.target;\n\n      // Note: It might improve jQuery interop if we called into jQuery\n      // here somehow.  Since we don't use jQuery to dispatch the event,\n      // we don't fire any of jQuery's event hooks or anything.  However,\n      // since jQuery can't bind capturing handlers, it's not clear\n      // where we would hook in.  Internal jQuery functions like `dispatch`\n      // are too high-level.\n      var $target = $jq(event.currentTarget);\n      if ($target.is($elem.find(selector)))\n        handler.call(elem, event);\n    };\n\n    handler._meteorui_wrapper = wrapper;\n\n    type = DOMBackend.Events.parseEventType(type);\n    // add *capturing* event listener\n    elem.addEventListener(type, wrapper, true);\n  },\n\n  unbindEventCapturer: function (elem, type, handler) {\n    type = DOMBackend.Events.parseEventType(type);\n    elem.removeEventListener(type, handler._meteorui_wrapper, true);\n  },\n\n  parseEventType: function (type) {\n    // strip off namespaces\n    var dotLoc = type.indexOf('.');\n    if (dotLoc >= 0)\n      return type.slice(0, dotLoc);\n    return type;\n  }\n};\n\n\n///// Removal detection and interoperability.\n\n// For an explanation of this technique, see:\n// http://bugs.jquery.com/ticket/12213#comment:23 .\n//\n// In short, an element is considered \"removed\" when jQuery\n// cleans up its *private* userdata on the element,\n// which we can detect using a custom event with a teardown\n// hook.\n\nvar NOOP = function () {};\n\n// Circular doubly-linked list\nvar TeardownCallback = function (func) {\n  this.next = this;\n  this.prev = this;\n  this.func = func;\n};\n\n// Insert newElt before oldElt in the circular list\nTeardownCallback.prototype.linkBefore = function(oldElt) {\n  this.prev = oldElt.prev;\n  this.next = oldElt;\n  oldElt.prev.next = this;\n  oldElt.prev = this;\n};\n\nTeardownCallback.prototype.unlink = function () {\n  this.prev.next = this.next;\n  this.next.prev = this.prev;\n};\n\nTeardownCallback.prototype.go = function () {\n  var func = this.func;\n  func && func();\n};\n\nTeardownCallback.prototype.stop = TeardownCallback.prototype.unlink;\n\nDOMBackend.Teardown = {\n  _JQUERY_EVENT_NAME: 'blaze_teardown_watcher',\n  _CB_PROP: '$blaze_teardown_callbacks',\n  // Registers a callback function to be called when the given element or\n  // one of its ancestors is removed from the DOM via the backend library.\n  // The callback function is called at most once, and it receives the element\n  // in question as an argument.\n  onElementTeardown: function (elem, func) {\n    var elt = new TeardownCallback(func);\n\n    var propName = DOMBackend.Teardown._CB_PROP;\n    if (! elem[propName]) {\n      // create an empty node that is never unlinked\n      elem[propName] = new TeardownCallback;\n\n      // Set up the event, only the first time.\n      $jq(elem).on(DOMBackend.Teardown._JQUERY_EVENT_NAME, NOOP);\n    }\n\n    elt.linkBefore(elem[propName]);\n\n    return elt; // so caller can call stop()\n  },\n  // Recursively call all teardown hooks, in the backend and registered\n  // through DOMBackend.onElementTeardown.\n  tearDownElement: function (elem) {\n    var elems = [];\n    // Array.prototype.slice.call doesn't work when given a NodeList in\n    // IE8 (\"JScript object expected\").\n    var nodeList = elem.getElementsByTagName('*');\n    for (var i = 0; i < nodeList.length; i++) {\n      elems.push(nodeList[i]);\n    }\n    elems.push(elem);\n    $jq.cleanData(elems);\n  }\n};\n\n$jq.event.special[DOMBackend.Teardown._JQUERY_EVENT_NAME] = {\n  setup: function () {\n    // This \"setup\" callback is important even though it is empty!\n    // Without it, jQuery will call addEventListener, which is a\n    // performance hit, especially with Chrome's async stack trace\n    // feature enabled.\n  },\n  teardown: function() {\n    var elem = this;\n    var callbacks = elem[DOMBackend.Teardown._CB_PROP];\n    if (callbacks) {\n      var elt = callbacks.next;\n      while (elt !== callbacks) {\n        elt.go();\n        elt = elt.next;\n      }\n      callbacks.go();\n\n      elem[DOMBackend.Teardown._CB_PROP] = null;\n    }\n  }\n};\n\n\n// Must use jQuery semantics for `context`, not\n// querySelectorAll's.  In other words, all the parts\n// of `selector` must be found under `context`.\nDOMBackend.findBySelector = function (selector, context) {\n  return $jq(selector, context);\n};\n","\n// A constant empty array (frozen if the JS engine supports it).\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];\n\n// `[new] Blaze._DOMRange([nodeAndRangeArray])`\n//\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\n// which may be replaced at any time with a new array.  If the DOMRange\n// has been attached to the DOM at some location, then updating\n// the array will cause the DOM to be updated at that location.\nBlaze._DOMRange = function (nodeAndRangeArray) {\n  if (! (this instanceof DOMRange))\n    // called without `new`\n    return new DOMRange(nodeAndRangeArray);\n\n  var members = (nodeAndRangeArray || _emptyArray);\n  if (! (members && (typeof members.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  for (var i = 0; i < members.length; i++)\n    this._memberIn(members[i]);\n\n  this.members = members;\n  this.emptyRangePlaceholder = null;\n  this.attached = false;\n  this.parentElement = null;\n  this.parentRange = null;\n  this.attachedCallbacks = _emptyArray;\n};\nvar DOMRange = Blaze._DOMRange;\n\n// In IE 8, don't use empty text nodes as placeholders\n// in empty DOMRanges, use comment nodes instead.  Using\n// empty text nodes in modern browsers is great because\n// it doesn't clutter the web inspector.  In IE 8, however,\n// it seems to lead in some roundabout way to the OAuth\n// pop-up crashing the browser completely.  In the past,\n// we didn't use empty text nodes on IE 8 because they\n// don't accept JS properties, so just use the same logic\n// even though we don't need to set properties on the\n// placeholder anymore.\nDOMRange._USE_COMMENT_PLACEHOLDERS = (function () {\n  var result = false;\n  var textNode = document.createTextNode(\"\");\n  try {\n    textNode.someProp = true;\n  } catch (e) {\n    // IE 8\n    result = true;\n  }\n  return result;\n})();\n\n// static methods\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.attach(parentElement, nextNode, _isMove);\n  } else {\n    if (_isMove)\n      DOMRange._moveNodeWithHooks(m, parentElement, nextNode);\n    else\n      DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\n  }\n};\n\nDOMRange._remove = function (rangeOrNode) {\n  var m = rangeOrNode;\n  if (m instanceof DOMRange) {\n    m.detach();\n  } else {\n    DOMRange._removeNodeWithHooks(m);\n  }\n};\n\nDOMRange._removeNodeWithHooks = function (n) {\n  if (! n.parentNode)\n    return;\n  if (n.nodeType === 1 &&\n      n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\n    n.parentNode._uihooks.removeElement(n);\n  } else {\n    n.parentNode.removeChild(n);\n  }\n};\n\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.insertElement) {\n    parent._uihooks.insertElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\n  if (n.parentNode !== parent)\n    return;\n  // `|| null` because IE throws an error if 'next' is undefined\n  next = next || null;\n  if (n.nodeType === 1 &&\n      parent._uihooks && parent._uihooks.moveElement) {\n    parent._uihooks.moveElement(n, next);\n  } else {\n    parent.insertBefore(n, next);\n  }\n};\n\nDOMRange.forElement = function (elem) {\n  if (elem.nodeType !== 1)\n    throw new Error(\"Expected element, found: \" + elem);\n  var range = null;\n  while (elem && ! range) {\n    range = (elem.$blaze_range || null);\n    if (! range)\n      elem = elem.parentNode;\n  }\n  return range;\n};\n\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove, _isReplace) {\n  // This method is called to insert the DOMRange into the DOM for\n  // the first time, but it's also used internally when\n  // updating the DOM.\n  //\n  // If _isMove is true, move this attached range to a different\n  // location under the same parentElement.\n  if (_isMove || _isReplace) {\n    if (! (this.parentElement === parentElement &&\n           this.attached))\n      throw new Error(\"Can only move or replace an attached DOMRange, and only under the same parent element\");\n  }\n\n  var members = this.members;\n  if (members.length) {\n    this.emptyRangePlaceholder = null;\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\n    }\n  } else {\n    var placeholder = (\n      DOMRange._USE_COMMENT_PLACEHOLDERS ?\n        document.createComment(\"\") :\n        document.createTextNode(\"\"));\n    this.emptyRangePlaceholder = placeholder;\n    parentElement.insertBefore(placeholder, nextNode || null);\n  }\n  this.attached = true;\n  this.parentElement = parentElement;\n\n  if (! (_isMove || _isReplace)) {\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.attached && obj.attached(this, parentElement);\n    }\n  }\n};\n\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\n  var newMembers = newNodeAndRangeArray;\n  if (! (newMembers && (typeof newMembers.length) === 'number'))\n    throw new Error(\"Expected array\");\n\n  var oldMembers = this.members;\n\n  for (var i = 0; i < oldMembers.length; i++)\n    this._memberOut(oldMembers[i]);\n  for (var i = 0; i < newMembers.length; i++)\n    this._memberIn(newMembers[i]);\n\n  if (! this.attached) {\n    this.members = newMembers;\n  } else {\n    // don't do anything if we're going from empty to empty\n    if (newMembers.length || oldMembers.length) {\n      // detach the old members and insert the new members\n      var nextNode = this.lastNode().nextSibling;\n      var parentElement = this.parentElement;\n      // Use detach/attach, but don't fire attached/detached hooks\n      this.detach(true /*_isReplace*/);\n      this.members = newMembers;\n      this.attach(parentElement, nextNode, false, true /*_isReplace*/);\n    }\n  }\n};\n\nDOMRange.prototype.firstNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[0];\n  return (m instanceof DOMRange) ? m.firstNode() : m;\n};\n\nDOMRange.prototype.lastNode = function () {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! this.members.length)\n    return this.emptyRangePlaceholder;\n\n  var m = this.members[this.members.length - 1];\n  return (m instanceof DOMRange) ? m.lastNode() : m;\n};\n\nDOMRange.prototype.detach = function (_isReplace) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  var oldParentElement = this.parentElement;\n  var members = this.members;\n  if (members.length) {\n    for (var i = 0; i < members.length; i++) {\n      DOMRange._remove(members[i]);\n    }\n  } else {\n    var placeholder = this.emptyRangePlaceholder;\n    this.parentElement.removeChild(placeholder);\n    this.emptyRangePlaceholder = null;\n  }\n\n  if (! _isReplace) {\n    this.attached = false;\n    this.parentElement = null;\n\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\n      var obj = this.attachedCallbacks[i];\n      obj.detached && obj.detached(this, oldParentElement);\n    }\n  }\n};\n\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex <= members.length))\n    throw new Error(\"Bad index in range.addMember: \" + atIndex);\n\n  if (! _isMove)\n    this._memberIn(newMember);\n\n  if (! this.attached) {\n    // currently detached; just updated members\n    members.splice(atIndex, 0, newMember);\n  } else if (members.length === 0) {\n    // empty; use the empty-to-nonempty handling of setMembers\n    this.setMembers([newMember]);\n  } else {\n    var nextNode;\n    if (atIndex === members.length) {\n      // insert at end\n      nextNode = this.lastNode().nextSibling;\n    } else {\n      var m = members[atIndex];\n      nextNode = (m instanceof DOMRange) ? m.firstNode() : m;\n    }\n    members.splice(atIndex, 0, newMember);\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\n  }\n};\n\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.removeMember: \" + atIndex);\n\n  if (_isMove) {\n    members.splice(atIndex, 1);\n  } else {\n    var oldMember = members[atIndex];\n    this._memberOut(oldMember);\n\n    if (members.length === 1) {\n      // becoming empty; use the logic in setMembers\n      this.setMembers(_emptyArray);\n    } else {\n      members.splice(atIndex, 1);\n      if (this.attached)\n        DOMRange._remove(oldMember);\n    }\n  }\n};\n\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\n  var member = this.members[oldIndex];\n  this.removeMember(oldIndex, true /*_isMove*/);\n  this.addMember(member, newIndex, true /*_isMove*/);\n};\n\nDOMRange.prototype.getMember = function (atIndex) {\n  var members = this.members;\n  if (! (atIndex >= 0 && atIndex < members.length))\n    throw new Error(\"Bad index in range.getMember: \" + atIndex);\n  return this.members[atIndex];\n};\n\nDOMRange.prototype._memberIn = function (m) {\n  if (m instanceof DOMRange)\n    m.parentRange = this;\n  else if (m.nodeType === 1) // DOM Element\n    m.$blaze_range = this;\n};\n\nDOMRange._destroy = function (m, _skipNodes) {\n  if (m instanceof DOMRange) {\n    if (m.view)\n      Blaze._destroyView(m.view, _skipNodes);\n  } else if ((! _skipNodes) && m.nodeType === 1) {\n    // DOM Element\n    if (m.$blaze_range) {\n      Blaze._destroyNode(m);\n      m.$blaze_range = null;\n    }\n  }\n};\n\nDOMRange.prototype._memberOut = DOMRange._destroy;\n\n// Tear down, but don't remove, the members.  Used when chunks\n// of DOM are being torn down or replaced.\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\n  var members = this.members;\n  for (var i = 0; i < members.length; i++)\n    this._memberOut(members[i], _skipNodes);\n};\n\nDOMRange.prototype.destroy = function (_skipNodes) {\n  DOMRange._destroy(this, _skipNodes);\n};\n\nDOMRange.prototype.containsElement = function (elem) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  // An element is contained in this DOMRange if it's possible to\n  // reach it by walking parent pointers, first through the DOM and\n  // then parentRange pointers.  In other words, the element or some\n  // ancestor of it is at our level of the DOM (a child of our\n  // parentElement), and this element is one of our members or\n  // is a member of a descendant Range.\n\n  // First check that elem is a descendant of this.parentElement,\n  // according to the DOM.\n  if (! Blaze._elementContains(this.parentElement, elem))\n    return false;\n\n  // If elem is not an immediate child of this.parentElement,\n  // walk up to its ancestor that is.\n  while (elem.parentNode !== this.parentElement)\n    elem = elem.parentNode;\n\n  var range = elem.$blaze_range;\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.containsRange = function (range) {\n  if (! this.attached)\n    throw new Error(\"Must be attached\");\n\n  if (! range.attached)\n    return false;\n\n  // A DOMRange is contained in this DOMRange if it's possible\n  // to reach this range by following parent pointers.  If the\n  // DOMRange has the same parentElement, then it should be\n  // a member, or a member of a member etc.  Otherwise, we must\n  // contain its parentElement.\n\n  if (range.parentElement !== this.parentElement)\n    return this.containsElement(range.parentElement);\n\n  if (range === this)\n    return false; // don't contain self\n\n  while (range && range !== this)\n    range = range.parentRange;\n\n  return range === this;\n};\n\nDOMRange.prototype.onAttached = function (attached) {\n  this.onAttachedDetached({ attached: attached });\n};\n\n// callbacks are `attached(range, element)` and\n// `detached(range, element)`, and they may\n// access the `callbacks` object in `this`.\n// The arguments to `detached` are the same\n// range and element that were passed to `attached`.\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\n  if (this.attachedCallbacks === _emptyArray)\n    this.attachedCallbacks = [];\n  this.attachedCallbacks.push(callbacks);\n};\n\nDOMRange.prototype.$ = function (selector) {\n  var self = this;\n\n  var parentNode = this.parentElement;\n  if (! parentNode)\n    throw new Error(\"Can't select in removed DomRange\");\n\n  // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using `DOMRange#containsElement`.  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n  if (parentNode.nodeType === 11 /* DocumentFragment */)\n    throw new Error(\"Can't use $ on an offscreen range\");\n\n  var results = Blaze._DOMBackend.findBySelector(selector, parentNode);\n\n  // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number')\n      elem = this;\n\n    return self.containsElement(elem);\n  };\n\n  if (! results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x))\n        newResults.push(x);\n    }\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n\n  return results;\n};\n\n// Returns true if element a contains node b and is not node b.\n//\n// The restriction that `a` be an element (not a document fragment,\n// say) is based on what's easy to implement cross-browser.\nBlaze._elementContains = function (a, b) {\n  if (a.nodeType !== 1) // ELEMENT\n    return false;\n  if (a === b)\n    return false;\n\n  if (a.compareDocumentPosition) {\n    return a.compareDocumentPosition(b) & 0x10;\n  } else {\n    // Should be only old IE and maybe other old browsers here.\n    // Modern Safari has both functions but seems to get contains() wrong.\n    // IE can't handle b being a text node.  We work around this\n    // by doing a direct parent test now.\n    b = b.parentNode;\n    if (! (b && b.nodeType === 1)) // ELEMENT\n      return false;\n    if (a === b)\n      return true;\n\n    return a.contains(b);\n  }\n};\n","var EventSupport = Blaze._EventSupport = {};\n\nvar DOMBackend = Blaze._DOMBackend;\n\n// List of events to always delegate, never capture.\n// Since jQuery fakes bubbling for certain events in\n// certain browsers (like `submit`), we don't want to\n// get in its way.\n//\n// We could list all known bubbling\n// events here to avoid creating speculative capturers\n// for them, but it would only be an optimization.\nvar eventsToDelegate = EventSupport.eventsToDelegate = {\n  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,\n  focusout: 1, reset: 1, submit: 1\n};\n\nvar EVENT_MODE = EventSupport.EVENT_MODE = {\n  TBD: 0,\n  BUBBLING: 1,\n  CAPTURING: 2\n};\n\nvar NEXT_HANDLERREC_ID = 1;\n\nvar HandlerRec = function (elem, type, selector, handler, recipient) {\n  this.elem = elem;\n  this.type = type;\n  this.selector = selector;\n  this.handler = handler;\n  this.recipient = recipient;\n  this.id = (NEXT_HANDLERREC_ID++);\n\n  this.mode = EVENT_MODE.TBD;\n\n  // It's important that delegatedHandler be a different\n  // instance for each handlerRecord, because its identity\n  // is used to remove it.\n  //\n  // It's also important that the closure have access to\n  // `this` when it is not called with it set.\n  this.delegatedHandler = (function (h) {\n    return function (evt) {\n      if ((! h.selector) && evt.currentTarget !== evt.target)\n        // no selector means only fire on target\n        return;\n      return h.handler.apply(h.recipient, arguments);\n    };\n  })(this);\n\n  // WHY CAPTURE AND DELEGATE: jQuery can't delegate\n  // non-bubbling events, because\n  // event capture doesn't work in IE 8.  However, there\n  // are all sorts of new-fangled non-bubbling events\n  // like \"play\" and \"touchenter\".  We delegate these\n  // events using capture in all browsers except IE 8.\n  // IE 8 doesn't support these events anyway.\n\n  var tryCapturing = elem.addEventListener &&\n        (! _.has(eventsToDelegate,\n                 DOMBackend.Events.parseEventType(type)));\n\n  if (tryCapturing) {\n    this.capturingHandler = (function (h) {\n      return function (evt) {\n        if (h.mode === EVENT_MODE.TBD) {\n          // must be first time we're called.\n          if (evt.bubbles) {\n            // this type of event bubbles, so don't\n            // get called again.\n            h.mode = EVENT_MODE.BUBBLING;\n            DOMBackend.Events.unbindEventCapturer(\n              h.elem, h.type, h.capturingHandler);\n            return;\n          } else {\n            // this type of event doesn't bubble,\n            // so unbind the delegation, preventing\n            // it from ever firing.\n            h.mode = EVENT_MODE.CAPTURING;\n            DOMBackend.Events.undelegateEvents(\n              h.elem, h.type, h.delegatedHandler);\n          }\n        }\n\n        h.delegatedHandler(evt);\n      };\n    })(this);\n\n  } else {\n    this.mode = EVENT_MODE.BUBBLING;\n  }\n};\nEventSupport.HandlerRec = HandlerRec;\n\nHandlerRec.prototype.bind = function () {\n  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in\n  // this case, 'capturingHandler' is in charge of detecting the\n  // correct mode and turning off one or the other handlers.\n  if (this.mode !== EVENT_MODE.BUBBLING) {\n    DOMBackend.Events.bindEventCapturer(\n      this.elem, this.type, this.selector || '*',\n      this.capturingHandler);\n  }\n\n  if (this.mode !== EVENT_MODE.CAPTURING)\n    DOMBackend.Events.delegateEvents(\n      this.elem, this.type,\n      this.selector || '*', this.delegatedHandler);\n};\n\nHandlerRec.prototype.unbind = function () {\n  if (this.mode !== EVENT_MODE.BUBBLING)\n    DOMBackend.Events.unbindEventCapturer(this.elem, this.type,\n                                          this.capturingHandler);\n\n  if (this.mode !== EVENT_MODE.CAPTURING)\n    DOMBackend.Events.undelegateEvents(this.elem, this.type,\n                                       this.delegatedHandler);\n};\n\nEventSupport.listen = function (element, events, selector, handler, recipient, getParentRecipient) {\n\n  // Prevent this method from being JITed by Safari.  Due to a\n  // presumed JIT bug in Safari -- observed in Version 7.0.6\n  // (9537.78.2) -- this method may crash the Safari render process if\n  // it is JITed.\n  // Repro: https://github.com/dgreensp/public/tree/master/safari-crash\n  try { element = element; } finally {}\n\n  var eventTypes = [];\n  events.replace(/[^ /]+/g, function (e) {\n    eventTypes.push(e);\n  });\n\n  var newHandlerRecs = [];\n  for (var i = 0, N = eventTypes.length; i < N; i++) {\n    var type = eventTypes[i];\n\n    var eventDict = element.$blaze_events;\n    if (! eventDict)\n      eventDict = (element.$blaze_events = {});\n\n    var info = eventDict[type];\n    if (! info) {\n      info = eventDict[type] = {};\n      info.handlers = [];\n    }\n    var handlerList = info.handlers;\n    var handlerRec = new HandlerRec(\n      element, type, selector, handler, recipient);\n    newHandlerRecs.push(handlerRec);\n    handlerRec.bind();\n    handlerList.push(handlerRec);\n    // Move handlers of enclosing ranges to end, by unbinding and rebinding\n    // them.  In jQuery (or other DOMBackend) this causes them to fire\n    // later when the backend dispatches event handlers.\n    if (getParentRecipient) {\n      for (var r = getParentRecipient(recipient); r;\n           r = getParentRecipient(r)) {\n        // r is an enclosing range (recipient)\n        for (var j = 0, Nj = handlerList.length;\n             j < Nj; j++) {\n          var h = handlerList[j];\n          if (h.recipient === r) {\n            h.unbind();\n            h.bind();\n            handlerList.splice(j, 1); // remove handlerList[j]\n            handlerList.push(h);\n            j--; // account for removed handler\n            Nj--; // don't visit appended handlers\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    // closes over just `element` and `newHandlerRecs`\n    stop: function () {\n      var eventDict = element.$blaze_events;\n      if (! eventDict)\n        return;\n      // newHandlerRecs has only one item unless you specify multiple\n      // event types.  If this code is slow, it's because we have to\n      // iterate over handlerList here.  Clearing a whole handlerList\n      // via stop() methods is O(N^2) in the number of handlers on\n      // an element.\n      for (var i = 0; i < newHandlerRecs.length; i++) {\n        var handlerToRemove = newHandlerRecs[i];\n        var info = eventDict[handlerToRemove.type];\n        if (! info)\n          continue;\n        var handlerList = info.handlers;\n        for (var j = handlerList.length - 1; j >= 0; j--) {\n          if (handlerList[j] === handlerToRemove) {\n            handlerToRemove.unbind();\n            handlerList.splice(j, 1); // remove handlerList[j]\n          }\n        }\n      }\n      newHandlerRecs.length = 0;\n    }\n  };\n};\n","var jsUrlsAllowed = false;\nBlaze._allowJavascriptUrls = function () {\n  jsUrlsAllowed = true;\n};\nBlaze._javascriptUrlsAllowed = function () {\n  return jsUrlsAllowed;\n};\n\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\nBlaze._AttributeHandler = AttributeHandler;\n\nAttributeHandler.prototype.update = function (element, oldValue, value) {\n  if (value === null) {\n    if (oldValue !== null)\n      element.removeAttribute(this.name);\n  } else {\n    element.setAttribute(this.name, value);\n  }\n};\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"\n//\n// Each subclass must implement a parseValue method which takes a string\n// as an input and returns a dict of attributes. The keys of the dict\n// are unique identifiers (ie. css properties in the case of styles), and the\n// values are the entire attribute which will be injected into the element.\n//\n// Extended below to support classes, SVG elements and styles.\n\nvar DiffingAttributeHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");\n\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};\n    var newAttrsMap = value ? this.parseValue(value) : {};\n\n    // the current attributes on the element, which we will mutate.\n\n    var attrString = this.getCurrentValue(element);\n    var attrsMap = attrString ? this.parseValue(attrString) : {};\n\n    _.each(_.keys(oldAttrsMap), function (t) {\n      if (! (t in newAttrsMap))\n        delete attrsMap[t];\n    });\n\n    _.each(_.keys(newAttrsMap), function (t) {\n      attrsMap[t] = newAttrsMap[t];\n    });\n\n    this.setValue(element, _.values(attrsMap).join(' '));\n  }\n});\n\nvar ClassHandler = DiffingAttributeHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  },\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    _.each(attrString.split(' '), function(token) {\n      if (token)\n        tokens[token] = token;\n    });\n    return tokens;\n  }\n});\n\nvar SVGClassHandler = ClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar StyleHandler = DiffingAttributeHandler.extend({\n  getCurrentValue: function (element) {\n    return element.getAttribute('style');\n  },\n  setValue: function (element, style) {\n    if (style === '') {\n      element.removeAttribute('style');\n    } else {\n      element.setAttribute('style', style);\n    }\n  },\n\n  // Parse a string to produce a map from property to attribute string.\n  //\n  // Example:\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}\n  parseValue: function (attrString) {\n    var tokens = {};\n\n    // Regex for parsing a css attribute declaration, taken from css-parse:\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\n    var match = regex.exec(attrString);\n    while (match) {\n      // match[0] = entire matching string\n      // match[1] = css property\n      // Prefix the token to prevent conflicts with existing properties.\n\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to\n      // remove strong dep on jquery.\n      tokens[' ' + match[1]] = match[0].trim ?\n        match[0].trim() : $.trim(match[0]);\n\n      match = regex.exec(attrString);\n    }\n\n    return tokens;\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar DOMPropertyHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value !== element[name])\n      element[name] = value;\n  }\n});\n\n// attributes of the type 'xlink:something' should be set using\n// the correct namespace in order to work\nvar XlinkHandler = AttributeHandler.extend({\n  update: function(element, oldValue, value) {\n    var NS = 'http://www.w3.org/1999/xlink';\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttributeNS(NS, this.name);\n    } else {\n      element.setAttributeNS(NS, this.name, this.value);\n    }\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\nvar isUrlAttribute = function (tagName, attrName) {\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\n  // and\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\n  var urlAttrs = {\n    FORM: ['action'],\n    BODY: ['background'],\n    BLOCKQUOTE: ['cite'],\n    Q: ['cite'],\n    DEL: ['cite'],\n    INS: ['cite'],\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\n    APPLET: ['codebase'],\n    A: ['href'],\n    AREA: ['href'],\n    LINK: ['href'],\n    BASE: ['href'],\n    IMG: ['longdesc', 'src', 'usemap'],\n    FRAME: ['longdesc', 'src'],\n    IFRAME: ['longdesc', 'src'],\n    HEAD: ['profile'],\n    SCRIPT: ['src'],\n    INPUT: ['src', 'usemap', 'formaction'],\n    BUTTON: ['formaction'],\n    BASE: ['href'],\n    MENUITEM: ['icon'],\n    HTML: ['manifest'],\n    VIDEO: ['poster']\n  };\n\n  if (attrName === 'itemid') {\n    return true;\n  }\n\n  var urlAttrNames = urlAttrs[tagName] || [];\n  return _.contains(urlAttrNames, attrName);\n};\n\n// To get the protocol for a URL, we let the browser normalize it for\n// us, by setting it as the href for an anchor tag and then reading out\n// the 'protocol' property.\nif (Meteor.isClient) {\n  var anchorForNormalization = document.createElement('A');\n}\n\nvar getUrlProtocol = function (url) {\n  if (Meteor.isClient) {\n    anchorForNormalization.href = url;\n    return (anchorForNormalization.protocol || \"\").toLowerCase();\n  } else {\n    throw new Error('getUrlProtocol not implemented on the server');\n  }\n};\n\n// UrlHandler is an attribute handler for all HTML attributes that take\n// URL values. It disallows javascript: URLs, unless\n// Blaze._allowJavascriptUrls() has been called. To detect javascript:\n// urls, we set the attribute on a dummy anchor element and then read\n// out the 'protocol' property of the attribute.\nvar origUpdate = AttributeHandler.prototype.update;\nvar UrlHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var self = this;\n    var args = arguments;\n\n    if (Blaze._javascriptUrlsAllowed()) {\n      origUpdate.apply(self, args);\n    } else {\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");\n      if (isJavascriptProtocol) {\n        Blaze._warn(\"URLs that use the 'javascript:' protocol are not \" +\n                    \"allowed in URL attribute values. \" +\n                    \"Call Blaze._allowJavascriptUrls() \" +\n                    \"to enable them.\");\n        origUpdate.apply(self, [element, oldValue, null]);\n      } else {\n        origUpdate.apply(self, args);\n      }\n    }\n  }\n});\n\n// XXX make it possible for users to register attribute handlers!\nmakeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'style') {\n    return new StyleHandler(name, value);\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\n             (elem.tagName === 'INPUT' && name === 'checked')) {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new DOMPropertyHandler(name, value);\n  } else if (name.substring(0,6) === 'xlink:') {\n    return new XlinkHandler(name.substring(6), value);\n  } else if (isUrlAttribute(elem.tagName, name)) {\n    return new UrlHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n\n\nElementAttributesUpdater = function (elem) {\n  this.elem = elem;\n  this.handlers = {};\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, whose\n// values are strings.\nElementAttributesUpdater.prototype.update = function(newAttrs) {\n  var elem = this.elem;\n  var handlers = this.handlers;\n\n  for (var k in handlers) {\n    if (! _.has(newAttrs, k)) {\n      // remove attributes (and handlers) for attribute names\n      // that don't exist as keys of `newAttrs` and so won't\n      // be visited when traversing it.  (Attributes that\n      // exist in the `newAttrs` object but are `null`\n      // are handled later.)\n      var handler = handlers[k];\n      var oldValue = handler.value;\n      handler.value = null;\n      handler.update(elem, oldValue, null);\n      delete handlers[k];\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if (! _.has(handlers, k)) {\n      if (value !== null) {\n        // make new handler\n        handler = makeAttributeHandler(elem, k, value);\n        handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n","// Turns HTMLjs into DOM nodes and DOMRanges.\n//\n// - `htmljs`: the value to materialize, which may be any of the htmljs\n//   types (Tag, CharRef, Comment, Raw, array, string, boolean, number,\n//   null, or undefined) or a View or Template (which will be used to\n//   construct a View).\n// - `intoArray`: the array of DOM nodes and DOMRanges to push the output\n//   into (required)\n// - `parentView`: the View we are materializing content for (optional)\n// - `_existingWorkStack`: optional argument, only used for recursive\n//   calls when there is some other _materializeDOM on the call stack.\n//   If _materializeDOM called your function and passed in a workStack,\n//   pass it back when you call _materializeDOM (such as from a workStack\n//   task).\n//\n// Returns `intoArray`, which is especially useful if you pass in `[]`.\nBlaze._materializeDOM = function (htmljs, intoArray, parentView,\n                                  _existingWorkStack) {\n  // In order to use fewer stack frames, materializeDOMInner can push\n  // tasks onto `workStack`, and they will be popped off\n  // and run, last first, after materializeDOMInner returns.  The\n  // reason we use a stack instead of a queue is so that we recurse\n  // depth-first, doing newer tasks first.\n  var workStack = (_existingWorkStack || []);\n  materializeDOMInner(htmljs, intoArray, parentView, workStack);\n\n  if (! _existingWorkStack) {\n    // We created the work stack, so we are responsible for finishing\n    // the work.  Call each \"task\" function, starting with the top\n    // of the stack.\n    while (workStack.length) {\n      // Note that running task() may push new items onto workStack.\n      var task = workStack.pop();\n      task();\n    }\n  }\n\n  return intoArray;\n};\n\nvar materializeDOMInner = function (htmljs, intoArray, parentView, workStack) {\n  if (htmljs == null) {\n    // null or undefined\n    return;\n  }\n\n  switch (typeof htmljs) {\n  case 'string': case 'boolean': case 'number':\n    intoArray.push(document.createTextNode(String(htmljs)));\n    return;\n  case 'object':\n    if (htmljs.htmljsType) {\n      switch (htmljs.htmljsType) {\n      case HTML.Tag.htmljsType:\n        intoArray.push(materializeTag(htmljs, parentView, workStack));\n        return;\n      case HTML.CharRef.htmljsType:\n        intoArray.push(document.createTextNode(htmljs.str));\n        return;\n      case HTML.Comment.htmljsType:\n        intoArray.push(document.createComment(htmljs.sanitizedValue));\n        return;\n      case HTML.Raw.htmljsType:\n        // Get an array of DOM nodes by using the browser's HTML parser\n        // (like innerHTML).\n        var nodes = Blaze._DOMBackend.parseHTML(htmljs.value);\n        for (var i = 0; i < nodes.length; i++)\n          intoArray.push(nodes[i]);\n        return;\n      }\n    } else if (HTML.isArray(htmljs)) {\n      for (var i = htmljs.length-1; i >= 0; i--) {\n        workStack.push(_.bind(Blaze._materializeDOM, null,\n                              htmljs[i], intoArray, parentView, workStack));\n      }\n      return;\n    } else {\n      if (htmljs instanceof Blaze.Template) {\n        htmljs = htmljs.constructView();\n        // fall through to Blaze.View case below\n      }\n      if (htmljs instanceof Blaze.View) {\n        Blaze._materializeView(htmljs, parentView, workStack, intoArray);\n        return;\n      }\n    }\n  }\n\n  throw new Error(\"Unexpected object in htmljs: \" + htmljs);\n};\n\nvar materializeTag = function (tag, parentView, workStack) {\n  var tagName = tag.tagName;\n  var elem;\n  if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\n      && document.createElementNS) {\n    // inline SVG\n    elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  } else {\n    // normal elements\n    elem = document.createElement(tagName);\n  }\n\n  var rawAttrs = tag.attrs;\n  var children = tag.children;\n  if (tagName === 'textarea' && tag.children.length &&\n      ! (rawAttrs && ('value' in rawAttrs))) {\n    // Provide very limited support for TEXTAREA tags with children\n    // rather than a \"value\" attribute.\n    // Reactivity in the form of Views nested in the tag's children\n    // won't work.  Compilers should compile textarea contents into\n    // the \"value\" attribute of the tag, wrapped in a function if there\n    // is reactivity.\n    if (typeof rawAttrs === 'function' ||\n        HTML.isArray(rawAttrs)) {\n      throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\n                      \"use the 'value' attribute instead.\");\n    }\n    rawAttrs = _.extend({}, rawAttrs || null);\n    rawAttrs.value = Blaze._expand(children, parentView);\n    children = [];\n  }\n\n  if (rawAttrs) {\n    var attrUpdater = new ElementAttributesUpdater(elem);\n    var updateAttributes = function () {\n      var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\n      var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\n      var stringAttrs = {};\n      for (var attrName in flattenedAttrs) {\n        stringAttrs[attrName] = Blaze._toText(flattenedAttrs[attrName],\n                                              parentView,\n                                              HTML.TEXTMODE.STRING);\n      }\n      attrUpdater.update(stringAttrs);\n    };\n    var updaterComputation;\n    if (parentView) {\n      updaterComputation =\n        parentView.autorun(updateAttributes, undefined, 'updater');\n    } else {\n      updaterComputation = Tracker.nonreactive(function () {\n        return Tracker.autorun(function () {\n          Tracker._withCurrentView(parentView, updateAttributes);\n        });\n      });\n    }\n    Blaze._DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\n      updaterComputation.stop();\n    });\n  }\n\n  if (children.length) {\n    var childNodesAndRanges = [];\n    // push this function first so that it's done last\n    workStack.push(function () {\n      for (var i = 0; i < childNodesAndRanges.length; i++) {\n        var x = childNodesAndRanges[i];\n        if (x instanceof Blaze._DOMRange)\n          x.attach(elem);\n        else\n          elem.appendChild(x);\n      }\n    });\n    // now push the task that calculates childNodesAndRanges\n    workStack.push(_.bind(Blaze._materializeDOM, null,\n                          children, childNodesAndRanges, parentView,\n                          workStack));\n  }\n\n  return elem;\n};\n\n\nvar isSVGAnchor = function (node) {\n  // We generally aren't able to detect SVG <a> elements because\n  // if \"A\" were in our list of known svg element names, then all\n  // <a> nodes would be created using\n  // `document.createElementNS`. But in the special case of <a\n  // xlink:href=\"...\">, we can at least detect that attribute and\n  // create an SVG <a> tag in that case.\n  //\n  // However, we still have a general problem of knowing when to\n  // use document.createElementNS and when to use\n  // document.createElement; for example, font tags will always\n  // be created as SVG elements which can cause other\n  // problems. #1977\n  return (node.tagName === \"a\" &&\n          node.attrs &&\n          node.attrs[\"xlink:href\"] !== undefined);\n};\n","var debugFunc;\n\n// We call into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\n// Set this to `true` to cause `reportException` to throw\n// the next exception rather than reporting it.  This is\n// useful in unit tests that test error messages.\nBlaze._throwNextException = false;\n\nBlaze._reportException = function (e, msg) {\n  if (Blaze._throwNextException) {\n    Blaze._throwNextException = false;\n    throw e;\n  }\n\n  if (! debugFunc)\n    // adapted from Tracker\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message || e);\n};\n\nBlaze._wrapCatchingExceptions = function (f, where) {\n  if (typeof f !== 'function')\n    return f;\n\n  return function () {\n    try {\n      return f.apply(this, arguments);\n    } catch (e) {\n      Blaze._reportException(e, 'Exception in ' + where + ':');\n    }\n  };\n};\n","/// [new] Blaze.View([name], renderMethod)\n///\n/// Blaze.View is the building block of reactive DOM.  Views have\n/// the following features:\n///\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\n///   and callbacks can be registered to fire when these things happen.\n///\n/// * parent pointer - A View points to its parentView, which is the\n///   View that caused it to be rendered.  These pointers form a\n///   hierarchy or tree of Views.\n///\n/// * render() method - A View's render() method specifies the DOM\n///   (or HTML) content of the View.  If the method establishes\n///   reactive dependencies, it may be re-run.\n///\n/// * a DOMRange - If a View is rendered to DOM, its position and\n///   extent in the DOM are tracked using a DOMRange object.\n///\n/// When a View is constructed by calling Blaze.View, the View is\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\n/// and no logic has been run to initialize the View.  All real\n/// work is deferred until at least creation time, when the onViewCreated\n/// callbacks are fired, which happens when the View is \"used\" in\n/// some way that requires it to be rendered.\n///\n/// ...more lifecycle stuff\n///\n/// `name` is an optional string tag identifying the View.  The only\n/// time it's used is when looking in the View tree for a View of a\n/// particular name; for example, data contexts are stored on Views\n/// of name \"with\".  Names are also useful when debugging, so in\n/// general it's good for functions that create Views to set the name.\n/// Views associated with templates have names of the form \"Template.foo\".\n\n/**\n * @class\n * @summary Constructor for a View, which represents a reactive region of DOM.\n * @locus Client\n * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  In this function, `this` is bound to the View.\n */\nBlaze.View = function (name, render) {\n  if (! (this instanceof Blaze.View))\n    // called without `new`\n    return new Blaze.View(name, render);\n\n  if (typeof name === 'function') {\n    // omitted \"name\" argument\n    render = name;\n    name = '';\n  }\n  this.name = name;\n  this._render = render;\n\n  this._callbacks = {\n    created: null,\n    rendered: null,\n    destroyed: null\n  };\n\n  // Setting all properties here is good for readability,\n  // and also may help Chrome optimize the code by keeping\n  // the View object from changing shape too much.\n  this.isCreated = false;\n  this._isCreatedForExpansion = false;\n  this.isRendered = false;\n  this._isAttached = false;\n  this.isDestroyed = false;\n  this._isInRender = false;\n  this.parentView = null;\n  this._domrange = null;\n  // This flag is normally set to false except for the cases when view's parent\n  // was generated as part of expanding some syntactic sugar expressions or\n  // methods.\n  // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n  // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n  // users don't know anything about these generated parent views, Blaze needs\n  // this information to be available on views to make smarter decisions. For\n  // example: removing the generated parent view with the view on Blaze.remove.\n  this._hasGeneratedParent = false;\n  // Bindings accessible to children views (via view.lookup('name')) within the\n  // closest template view.\n  this._scopeBindings = {};\n\n  this.renderCount = 0;\n};\n\nBlaze.View.prototype._render = function () { return null; };\n\nBlaze.View.prototype.onViewCreated = function (cb) {\n  this._callbacks.created = this._callbacks.created || [];\n  this._callbacks.created.push(cb);\n};\n\nBlaze.View.prototype._onViewRendered = function (cb) {\n  this._callbacks.rendered = this._callbacks.rendered || [];\n  this._callbacks.rendered.push(cb);\n};\n\nBlaze.View.prototype.onViewReady = function (cb) {\n  var self = this;\n  var fire = function () {\n    Tracker.afterFlush(function () {\n      if (! self.isDestroyed) {\n        Blaze._withCurrentView(self, function () {\n          cb.call(self);\n        });\n      }\n    });\n  };\n  self._onViewRendered(function onViewRendered() {\n    if (self.isDestroyed)\n      return;\n    if (! self._domrange.attached)\n      self._domrange.onAttached(fire);\n    else\n      fire();\n  });\n};\n\nBlaze.View.prototype.onViewDestroyed = function (cb) {\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\n  this._callbacks.destroyed.push(cb);\n};\nBlaze.View.prototype.removeViewDestroyedListener = function (cb) {\n  var destroyed = this._callbacks.destroyed;\n  if (! destroyed)\n    return;\n  var index = _.lastIndexOf(destroyed, cb);\n  if (index !== -1) {\n    // XXX You'd think the right thing to do would be splice, but _fireCallbacks\n    // gets sad if you remove callbacks while iterating over the list.  Should\n    // change this to use callback-hook or EventEmitter or something else that\n    // properly supports removal.\n    destroyed[index] = null;\n  }\n};\n\n/// View#autorun(func)\n///\n/// Sets up a Tracker autorun that is \"scoped\" to this View in two\n/// important ways: 1) Blaze.currentView is automatically set\n/// on every re-run, and 2) the autorun is stopped when the\n/// View is destroyed.  As with Tracker.autorun, the first run of\n/// the function is immediate, and a Computation object that can\n/// be used to stop the autorun is returned.\n///\n/// View#autorun is meant to be called from View callbacks like\n/// onViewCreated, or from outside the rendering process.  It may not\n/// be called before the onViewCreated callbacks are fired (too early),\n/// or from a render() method (too confusing).\n///\n/// Typically, autoruns that update the state\n/// of the View (as in Blaze.With) should be started from an onViewCreated\n/// callback.  Autoruns that update the DOM should be started\n/// from either onViewCreated (guarded against the absence of\n/// view._domrange), or onViewReady.\nBlaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n  var self = this;\n\n  // The restrictions on when View#autorun can be called are in order\n  // to avoid bad patterns, like creating a Blaze.View and immediately\n  // calling autorun on it.  A freshly created View is not ready to\n  // have logic run on it; it doesn't have a parentView, for example.\n  // It's when the View is materialized or expanded that the onViewCreated\n  // handlers are fired and the View starts up.\n  //\n  // Letting the render() method call `this.autorun()` is problematic\n  // because of re-render.  The best we can do is to stop the old\n  // autorun and start a new one for each render, but that's a pattern\n  // we try to avoid internally because it leads to helpers being\n  // called extra times, in the case where the autorun causes the\n  // view to re-render (and thus the autorun to be torn down and a\n  // new one established).\n  //\n  // We could lift these restrictions in various ways.  One interesting\n  // idea is to allow you to call `view.autorun` after instantiating\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n  // the autorun so that it starts at an appropriate time.  However,\n  // then we can't return the Computation object to the caller, because\n  // it doesn't exist yet.\n  if (! self.isCreated) {\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n  }\n  if (this._isInRender) {\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (Tracker.active) {\n    throw new Error(\"Can't call View#autorun from a Tracker Computation; try calling it from the created or rendered callback\");\n  }\n\n  var templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n\n  var func = function viewAutorun(c) {\n    return Blaze._withCurrentView(_inViewScope || self, function () {\n      return Blaze.Template._withTemplateInstanceFunc(\n        templateInstanceFunc, function () {\n          return f.call(self, c);\n        });\n    });\n  };\n\n  // Give the autorun function a better name for debugging and profiling.\n  // The `displayName` property is not part of the spec but browsers like Chrome\n  // and Firefox prefer it in debuggers over the name function was declared by.\n  func.displayName =\n    (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n  var comp = Tracker.autorun(func);\n\n  var stopComputation = function () { comp.stop(); };\n  self.onViewDestroyed(stopComputation);\n  comp.onStop(function () {\n    self.removeViewDestroyedListener(stopComputation);\n  });\n\n  return comp;\n};\n\nBlaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n  var self = this;\n\n  if (! self.isCreated) {\n    throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n  }\n  if (self._isInRender) {\n    throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (self.isDestroyed) {\n    throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n  }\n};\n\n/**\n * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n * Tracker.autorun. Stop the subscription when the view is destroyed.\n * @return {SubscriptionHandle} A handle to the subscription so that you can\n * see if it is ready, or stop it manually\n */\nBlaze.View.prototype.subscribe = function (args, options) {\n  var self = this;\n  options = options || {};\n\n  self._errorIfShouldntCallSubscribe();\n\n  var subHandle;\n  if (options.connection) {\n    subHandle = options.connection.subscribe.apply(options.connection, args);\n  } else {\n    subHandle = Meteor.subscribe.apply(Meteor, args);\n  }\n\n  self.onViewDestroyed(function () {\n    subHandle.stop();\n  });\n\n  return subHandle;\n};\n\nBlaze.View.prototype.firstNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.firstNode();\n};\n\nBlaze.View.prototype.lastNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.lastNode();\n};\n\nBlaze._fireCallbacks = function (view, which) {\n  Blaze._withCurrentView(view, function () {\n    Tracker.nonreactive(function fireCallbacks() {\n      var cbs = view._callbacks[which];\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)\n        cbs[i] && cbs[i].call(view);\n    });\n  });\n};\n\nBlaze._createView = function (view, parentView, forExpansion) {\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n\n  view.parentView = (parentView || null);\n  view.isCreated = true;\n  if (forExpansion)\n    view._isCreatedForExpansion = true;\n\n  Blaze._fireCallbacks(view, 'created');\n};\n\nvar doFirstRender = function (view, initialContent) {\n  var domrange = new Blaze._DOMRange(initialContent);\n  view._domrange = domrange;\n  domrange.view = view;\n  view.isRendered = true;\n  Blaze._fireCallbacks(view, 'rendered');\n\n  var teardownHook = null;\n\n  domrange.onAttached(function attached(range, element) {\n    view._isAttached = true;\n\n    teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(\n      element, function teardown() {\n        Blaze._destroyView(view, true /* _skipNodes */);\n      });\n  });\n\n  // tear down the teardown hook\n  view.onViewDestroyed(function () {\n    teardownHook && teardownHook.stop();\n    teardownHook = null;\n  });\n\n  return domrange;\n};\n\n// Take an uncreated View `view` and create and render it to DOM,\n// setting up the autorun that updates the View.  Returns a new\n// DOMRange, which has been associated with the View.\n//\n// The private arguments `_workStack` and `_intoArray` are passed in\n// by Blaze._materializeDOM and are only present for recursive calls\n// (when there is some other _materializeView on the stack).  If\n// provided, then we avoid the mutual recursion of calling back into\n// Blaze._materializeDOM so that deep View hierarchies don't blow the\n// stack.  Instead, we push tasks onto workStack for the initial\n// rendering and subsequent setup of the View, and they are done after\n// we return.  When there is a _workStack, we do not return the new\n// DOMRange, but instead push it into _intoArray from a _workStack\n// task.\nBlaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n  Blaze._createView(view, parentView);\n\n  var domrange;\n  var lastHtmljs;\n  // We don't expect to be called in a Computation, but just in case,\n  // wrap in Tracker.nonreactive.\n  Tracker.nonreactive(function () {\n    view.autorun(function doRender(c) {\n      // `view.autorun` sets the current view.\n      view.renderCount++;\n      view._isInRender = true;\n      // Any dependencies that should invalidate this Computation come\n      // from this line:\n      var htmljs = view._render();\n      view._isInRender = false;\n\n      if (! c.firstRun) {\n        Tracker.nonreactive(function doMaterialize() {\n          // re-render\n          var rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n          if (! Blaze._isContentEqual(lastHtmljs, htmljs)) {\n            domrange.setMembers(rangesAndNodes);\n            Blaze._fireCallbacks(view, 'rendered');\n          }\n        });\n      }\n      lastHtmljs = htmljs;\n\n      // Causes any nested views to stop immediately, not when we call\n      // `setMembers` the next time around the autorun.  Otherwise,\n      // helpers in the DOM tree to be replaced might be scheduled\n      // to re-run before we have a chance to stop them.\n      Tracker.onInvalidate(function () {\n        if (domrange) {\n          domrange.destroyMembers();\n        }\n      });\n    }, undefined, 'materialize');\n\n    // first render.  lastHtmljs is the first htmljs.\n    var initialContents;\n    if (! _workStack) {\n      initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n      domrange = doFirstRender(view, initialContents);\n      initialContents = null; // help GC because we close over this scope a lot\n    } else {\n      // We're being called from Blaze._materializeDOM, so to avoid\n      // recursion and save stack space, provide a description of the\n      // work to be done instead of doing it.  Tasks pushed onto\n      // _workStack will be done in LIFO order after we return.\n      // The work will still be done within a Tracker.nonreactive,\n      // because it will be done by some call to Blaze._materializeDOM\n      // (which is always called in a Tracker.nonreactive).\n      initialContents = [];\n      // push this function first so that it happens last\n      _workStack.push(function () {\n        domrange = doFirstRender(view, initialContents);\n        initialContents = null; // help GC because of all the closures here\n        _intoArray.push(domrange);\n      });\n      // now push the task that calculates initialContents\n      _workStack.push(_.bind(Blaze._materializeDOM, null,\n                             lastHtmljs, initialContents, view, _workStack));\n    }\n  });\n\n  if (! _workStack) {\n    return domrange;\n  } else {\n    return null;\n  }\n};\n\n// Expands a View to HTMLjs, calling `render` recursively on all\n// Views and evaluating any dynamic attributes.  Calls the `created`\n// callback, but not the `materialized` or `rendered` callbacks.\n// Destroys the view immediately, unless called in a Tracker Computation,\n// in which case the view will be destroyed when the Computation is\n// invalidated.  If called in a Tracker Computation, the result is a\n// reactive string; that is, the Computation will be invalidated\n// if any changes are made to the view or subviews that might affect\n// the HTML.\nBlaze._expandView = function (view, parentView) {\n  Blaze._createView(view, parentView, true /*forExpansion*/);\n\n  view._isInRender = true;\n  var htmljs = Blaze._withCurrentView(view, function () {\n    return view._render();\n  });\n  view._isInRender = false;\n\n  var result = Blaze._expand(htmljs, view);\n\n  if (Tracker.active) {\n    Tracker.onInvalidate(function () {\n      Blaze._destroyView(view);\n    });\n  } else {\n    Blaze._destroyView(view);\n  }\n\n  return result;\n};\n\n// Options: `parentView`\nBlaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\nBlaze._HTMLJSExpander.def({\n  visitObject: function (x) {\n    if (x instanceof Blaze.Template)\n      x = x.constructView();\n    if (x instanceof Blaze.View)\n      return Blaze._expandView(x, this.parentView);\n\n    // this will throw an error; other objects are not allowed!\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    // expand dynamic attributes\n    if (typeof attrs === 'function')\n      attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    // expand attribute values that are functions.  Any attribute value\n    // that contains Views must be wrapped in a function.\n    if (typeof value === 'function')\n      value = Blaze._withCurrentView(this.parentView, value);\n\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\n      this, name, value, tag);\n  }\n});\n\n// Return Blaze.currentView, but only if it is being rendered\n// (i.e. we are in its render() method).\nvar currentViewIfRendering = function () {\n  var view = Blaze.currentView;\n  return (view && view._isInRender) ? view : null;\n};\n\nBlaze._expand = function (htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visit(htmljs);\n};\n\nBlaze._expandAttributes = function (attrs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visitAttributes(attrs);\n};\n\nBlaze._destroyView = function (view, _skipNodes) {\n  if (view.isDestroyed)\n    return;\n  view.isDestroyed = true;\n\n  Blaze._fireCallbacks(view, 'destroyed');\n\n  // Destroy views and elements recursively.  If _skipNodes,\n  // only recurse up to views, not elements, for the case where\n  // the backend (jQuery) is recursing over the elements already.\n\n  if (view._domrange)\n    view._domrange.destroyMembers(_skipNodes);\n};\n\nBlaze._destroyNode = function (node) {\n  if (node.nodeType === 1)\n    Blaze._DOMBackend.Teardown.tearDownElement(node);\n};\n\n// Are the HTMLjs entities `a` and `b` the same?  We could be\n// more elaborate here but the point is to catch the most basic\n// cases.\nBlaze._isContentEqual = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\n/**\n * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @type {Blaze.View}\n */\nBlaze.currentView = null;\n\nBlaze._withCurrentView = function (view, func) {\n  var oldView = Blaze.currentView;\n  try {\n    Blaze.currentView = view;\n    return func();\n  } finally {\n    Blaze.currentView = oldView;\n  }\n};\n\n// Blaze.render publicly takes a View or a Template.\n// Privately, it takes any HTMLJS (extended with Views and Templates)\n// except null or undefined, or a function that returns any extended\n// HTMLJS.\nvar checkRenderContent = function (content) {\n  if (content === null)\n    throw new Error(\"Can't render null\");\n  if (typeof content === 'undefined')\n    throw new Error(\"Can't render undefined\");\n\n  if ((content instanceof Blaze.View) ||\n      (content instanceof Blaze.Template) ||\n      (typeof content === 'function'))\n    return;\n\n  try {\n    // Throw if content doesn't look like HTMLJS at the top level\n    // (i.e. verify that this is an HTML.Tag, or an array,\n    // or a primitive, etc.)\n    (new HTML.Visitor).visit(content);\n  } catch (e) {\n    // Make error message suitable for public API\n    throw new Error(\"Expected Template or View\");\n  }\n};\n\n// For Blaze.render and Blaze.toHTML, take content and\n// wrap it in a View, unless it's a single View or\n// Template already.\nvar contentAsView = function (content) {\n  checkRenderContent(content);\n\n  if (content instanceof Blaze.Template) {\n    return content.constructView();\n  } else if (content instanceof Blaze.View) {\n    return content;\n  } else {\n    var func = content;\n    if (typeof func !== 'function') {\n      func = function () {\n        return content;\n      };\n    }\n    return Blaze.View('render', func);\n  }\n};\n\n// For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n// in a function, if necessary, so it can be a content arg to\n// a Blaze.With.\nvar contentAsFunc = function (content) {\n  checkRenderContent(content);\n\n  if (typeof content !== 'function') {\n    return function () {\n      return content;\n    };\n  } else {\n    return content;\n  }\n};\n\n/**\n * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#blaze_view) which can be passed to [`Blaze.remove`](#blaze_remove).\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.render = function (content, parentElement, nextNode, parentView) {\n  if (! parentElement) {\n    Blaze._warn(\"Blaze.render without a parent element is deprecated. \" +\n                \"You must specify where to insert the rendered content.\");\n  }\n\n  if (nextNode instanceof Blaze.View) {\n    // handle omitted nextNode\n    parentView = nextNode;\n    nextNode = null;\n  }\n\n  // parentElement must be a DOM node. in particular, can't be the\n  // result of a call to `$`. Can't check if `parentElement instanceof\n  // Node` since 'Node' is undefined in IE8.\n  if (parentElement && typeof parentElement.nodeType !== 'number')\n    throw new Error(\"'parentElement' must be a DOM node\");\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\n    throw new Error(\"'nextNode' must be a DOM node\");\n\n  parentView = parentView || currentViewIfRendering();\n\n  var view = contentAsView(content);\n  Blaze._materializeView(view, parentView);\n\n  if (parentElement) {\n    view._domrange.attach(parentElement, nextNode);\n  }\n\n  return view;\n};\n\nBlaze.insert = function (view, parentElement, nextNode) {\n  Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" +\n              \"rendered content in the call to Blaze.render.\");\n\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  view._domrange.attach(parentElement, nextNode);\n};\n\n/**\n * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n  // We defer the handling of optional arguments to Blaze.render.  At this point,\n  // `nextNode` may actually be `parentView`.\n  return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)),\n                          parentElement, nextNode, parentView);\n};\n\n/**\n * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it.\n * @locus Client\n * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`.\n */\nBlaze.remove = function (view) {\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  while (view) {\n    if (! view.isDestroyed) {\n      var range = view._domrange;\n      if (range.attached && ! range.parentRange)\n        range.detach();\n      range.destroy();\n    }\n\n    view = view._hasGeneratedParent && view.parentView;\n  }\n};\n\n/**\n * @summary Renders a template or View to a string of HTML.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n */\nBlaze.toHTML = function (content, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n};\n\n/**\n * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n * @param {Object|Function} data The data context to use, or a function returning a data context.\n */\nBlaze.toHTMLWithData = function (content, data, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(\n    data, contentAsFunc(content)), parentView));\n};\n\nBlaze._toText = function (htmljs, parentView, textMode) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\n    // omitted parentView argument\n    textMode = parentView;\n    parentView = null;\n  }\n  parentView = parentView || currentViewIfRendering();\n\n  if (! textMode)\n    throw new Error(\"textMode required\");\n  if (! (textMode === HTML.TEXTMODE.STRING ||\n         textMode === HTML.TEXTMODE.RCDATA ||\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\n    throw new Error(\"Unknown textMode: \" + textMode);\n\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n};\n\n/**\n * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n * @locus Client\n * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n */\nBlaze.getData = function (elementOrView) {\n  var theWith;\n\n  if (! elementOrView) {\n    theWith = Blaze.getView('with');\n  } else if (elementOrView instanceof Blaze.View) {\n    var view = elementOrView;\n    theWith = (view.name === 'with' ? view :\n               Blaze.getView(view, 'with'));\n  } else if (typeof elementOrView.nodeType === 'number') {\n    if (elementOrView.nodeType !== 1)\n      throw new Error(\"Expected DOM element\");\n    theWith = Blaze.getView(elementOrView, 'with');\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n\n  return theWith ? theWith.dataVar.get() : null;\n};\n\n// For back-compat\nBlaze.getElementData = function (element) {\n  Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" +\n              \"Blaze.getData(element) instead.\");\n\n  if (element.nodeType !== 1)\n    throw new Error(\"Expected DOM element\");\n\n  return Blaze.getData(element);\n};\n\n// Both arguments are optional.\n\n/**\n * @summary Gets either the current View, or the View enclosing the given DOM element.\n * @locus Client\n * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n */\nBlaze.getView = function (elementOrView, _viewName) {\n  var viewName = _viewName;\n\n  if ((typeof elementOrView) === 'string') {\n    // omitted elementOrView; viewName present\n    viewName = elementOrView;\n    elementOrView = null;\n  }\n\n  // We could eventually shorten the code by folding the logic\n  // from the other methods into this method.\n  if (! elementOrView) {\n    return Blaze._getCurrentView(viewName);\n  } else if (elementOrView instanceof Blaze.View) {\n    return Blaze._getParentView(elementOrView, viewName);\n  } else if (typeof elementOrView.nodeType === 'number') {\n    return Blaze._getElementView(elementOrView, viewName);\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n};\n\n// Gets the current view or its nearest ancestor of name\n// `name`.\nBlaze._getCurrentView = function (name) {\n  var view = Blaze.currentView;\n  // Better to fail in cases where it doesn't make sense\n  // to use Blaze._getCurrentView().  There will be a current\n  // view anywhere it does.  You can check Blaze.currentView\n  // if you want to know whether there is one or not.\n  if (! view)\n    throw new Error(\"There is no current view\");\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    // Blaze._getCurrentView() with no arguments just returns\n    // Blaze.currentView.\n    return view;\n  }\n};\n\nBlaze._getParentView = function (view, name) {\n  var v = view.parentView;\n\n  if (name) {\n    while (v && v.name !== name)\n      v = v.parentView;\n  }\n\n  return v || null;\n};\n\nBlaze._getElementView = function (elem, name) {\n  var range = Blaze._DOMRange.forElement(elem);\n  var view = null;\n  while (range && ! view) {\n    view = (range.view || null);\n    if (! view) {\n      if (range.parentRange)\n        range = range.parentRange;\n      else\n        range = Blaze._DOMRange.forElement(range.parentElement);\n    }\n  }\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    return view;\n  }\n};\n\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\n  thisInHandler = (thisInHandler || null);\n  var handles = [];\n\n  if (! view._domrange)\n    throw new Error(\"View must have a DOMRange\");\n\n  view._domrange.onAttached(function attached_eventMaps(range, element) {\n    _.each(eventMap, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        handles.push(Blaze._EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget))\n              return null;\n            var handlerThis = thisInHandler || this;\n            var handlerArgs = arguments;\n            return Blaze._withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  });\n\n  view.onViewDestroyed(function () {\n    _.each(handles, function (h) {\n      h.stop();\n    });\n    handles.length = 0;\n  });\n};\n","Blaze._calculateCondition = function (cond) {\n  if (cond instanceof Array && cond.length === 0)\n    cond = false;\n  return !! cond;\n};\n\n/**\n * @summary Constructs a View that renders content with a data context.\n * @locus Client\n * @param {Object|Function} data An object to use as the data context, or a function returning such an object.  If a function is provided, it will be reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n */\nBlaze.With = function (data, contentFunc) {\n  var view = Blaze.View('with', contentFunc);\n\n  view.dataVar = new ReactiveVar;\n\n  view.onViewCreated(function () {\n    if (typeof data === 'function') {\n      // `data` is a reactive function\n      view.autorun(function () {\n        view.dataVar.set(data());\n      }, view.parentView, 'setData');\n    } else {\n      view.dataVar.set(data);\n    }\n  });\n\n  return view;\n};\n\n/**\n * Attaches bindings to the instantiated view.\n * @param {Object} bindings A dictionary of bindings, each binding name\n * corresponds to a value or a function that will be reactively re-run.\n * @param {View} view The target.\n */\nBlaze._attachBindingsToView = function (bindings, view) {\n  view.onViewCreated(function () {\n    _.each(bindings, function (binding, name) {\n      view._scopeBindings[name] = new ReactiveVar;\n      if (typeof binding === 'function') {\n        view.autorun(function () {\n          view._scopeBindings[name].set(binding());\n        }, view.parentView);\n      } else {\n        view._scopeBindings[name].set(binding);\n      }\n    });\n  });\n};\n\n/**\n * @summary Constructs a View setting the local lexical scope in the block.\n * @param {Function} bindings Dictionary mapping names of bindings to\n * values or computations to reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n */\nBlaze.Let = function (bindings, contentFunc) {\n  var view = Blaze.View('let', contentFunc);\n  Blaze._attachBindingsToView(bindings, view);\n\n  return view;\n};\n\n/**\n * @summary Constructs a View that renders content conditionally.\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  Whether the result is truthy or falsy determines whether `contentFunc` or `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\n  var conditionVar = new ReactiveVar;\n\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {\n    return conditionVar.get() ? contentFunc() :\n      (elseFunc ? elseFunc() : null);\n  });\n  view.__conditionVar = conditionVar;\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      var cond = Blaze._calculateCondition(conditionFunc());\n      conditionVar.set(_not ? (! cond) : cond);\n    }, this.parentView, 'condition');\n  });\n\n  return view;\n};\n\n/**\n * @summary An inverted [`Blaze.If`](#blaze_if).\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  If the result is falsy, `contentFunc` is shown, otherwise `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\n};\n\n/**\n * @summary Constructs a View that renders `contentFunc` for each item in a sequence.\n * @locus Client\n * @param {Function} argFunc A function to reactively re-run. The function can\n * return one of two options:\n *\n * 1. An object with two fields: '_variable' and '_sequence'. Each iterates over\n *   '_sequence', it may be a Cursor, an array, null, or undefined. Inside the\n *   Each body you will be able to get the current item from the sequence using\n *   the name specified in the '_variable' field.\n *\n * 2. Just a sequence (Cursor, array, null, or undefined) not wrapped into an\n *   object. Inside the Each body, the current item will be set as the data\n *   context.\n * @param {Function} contentFunc A Function that returns  [*renderable\n * content*](#renderable_content).\n * @param {Function} [elseFunc] A Function that returns [*renderable\n * content*](#renderable_content) to display in the case when there are no items\n * in the sequence.\n */\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('each', function () {\n    var subviews = this.initialSubviews;\n    this.initialSubviews = null;\n    if (this._isCreatedForExpansion) {\n      this.expandedValueDep = new Tracker.Dependency;\n      this.expandedValueDep.depend();\n    }\n    return subviews;\n  });\n  eachView.initialSubviews = [];\n  eachView.numItems = 0;\n  eachView.inElseMode = false;\n  eachView.stopHandle = null;\n  eachView.contentFunc = contentFunc;\n  eachView.elseFunc = elseFunc;\n  eachView.argVar = new ReactiveVar;\n  eachView.variableName = null;\n\n  // update the @index value in the scope of all subviews in the range\n  var updateIndices = function (from, to) {\n    if (to === undefined) {\n      to = eachView.numItems - 1;\n    }\n\n    for (var i = from; i <= to; i++) {\n      var view = eachView._domrange.members[i].view;\n      view._scopeBindings['@index'].set(i);\n    }\n  };\n\n  eachView.onViewCreated(function () {\n    // We evaluate argFunc in an autorun to make sure\n    // Blaze.currentView is always set when it runs (rather than\n    // passing argFunc straight to ObserveSequence).\n    eachView.autorun(function () {\n      // argFunc can return either a sequence as is or a wrapper object with a\n      // _sequence and _variable fields set.\n      var arg = argFunc();\n      if (_.isObject(arg) && _.has(arg, '_sequence')) {\n        eachView.variableName = arg._variable || null;\n        arg = arg._sequence;\n      }\n\n      eachView.argVar.set(arg);\n    }, eachView.parentView, 'collection');\n\n    eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          var newItemView;\n          if (eachView.variableName) {\n            // new-style #each (as in {{#each item in items}})\n            // doesn't create a new data context\n            newItemView = Blaze.View('item', eachView.contentFunc);\n          } else {\n            newItemView = Blaze.With(item, eachView.contentFunc);\n          }\n\n          eachView.numItems++;\n\n          var bindings = {};\n          bindings['@index'] = index;\n          if (eachView.variableName) {\n            bindings[eachView.variableName] = item;\n          }\n          Blaze._attachBindingsToView(bindings, newItemView);\n\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            if (eachView.inElseMode) {\n              eachView._domrange.removeMember(0);\n              eachView.inElseMode = false;\n            }\n\n            var range = Blaze._materializeView(newItemView, eachView);\n            eachView._domrange.addMember(range, index);\n            updateIndices(index);\n          } else {\n            eachView.initialSubviews.splice(index, 0, newItemView);\n          }\n        });\n      },\n      removedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          eachView.numItems--;\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.removeMember(index);\n            updateIndices(index);\n            if (eachView.elseFunc && eachView.numItems === 0) {\n              eachView.inElseMode = true;\n              eachView._domrange.addMember(\n                Blaze._materializeView(\n                  Blaze.View('each_else',eachView.elseFunc),\n                  eachView), 0);\n            }\n          } else {\n            eachView.initialSubviews.splice(index, 1);\n          }\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else {\n            var itemView;\n            if (eachView._domrange) {\n              itemView = eachView._domrange.getMember(index).view;\n            } else {\n              itemView = eachView.initialSubviews[index];\n            }\n            if (eachView.variableName) {\n              itemView._scopeBindings[eachView.variableName].set(newItem);\n            } else {\n              itemView.dataVar.set(newItem);\n            }\n          }\n        });\n      },\n      movedTo: function (id, item, fromIndex, toIndex) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.moveMember(fromIndex, toIndex);\n            updateIndices(\n              Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex));\n          } else {\n            var subviews = eachView.initialSubviews;\n            var itemView = subviews[fromIndex];\n            subviews.splice(fromIndex, 1);\n            subviews.splice(toIndex, 0, itemView);\n          }\n        });\n      }\n    });\n\n    if (eachView.elseFunc && eachView.numItems === 0) {\n      eachView.inElseMode = true;\n      eachView.initialSubviews[0] =\n        Blaze.View('each_else', eachView.elseFunc);\n    }\n  });\n\n  eachView.onViewDestroyed(function () {\n    if (eachView.stopHandle)\n      eachView.stopHandle.stop();\n  });\n\n  return eachView;\n};\n\nBlaze._TemplateWith = function (arg, contentFunc) {\n  var w;\n\n  var argFunc = arg;\n  if (typeof arg !== 'function') {\n    argFunc = function () {\n      return arg;\n    };\n  }\n\n  // This is a little messy.  When we compile `{{> Template.contentBlock}}`, we\n  // wrap it in Blaze._InOuterTemplateScope in order to skip the intermediate\n  // parent Views in the current template.  However, when there's an argument\n  // (`{{> Template.contentBlock arg}}`), the argument needs to be evaluated\n  // in the original scope.  There's no good order to nest\n  // Blaze._InOuterTemplateScope and Spacebars.TemplateWith to achieve this,\n  // so we wrap argFunc to run it in the \"original parentView\" of the\n  // Blaze._InOuterTemplateScope.\n  //\n  // To make this better, reconsider _InOuterTemplateScope as a primitive.\n  // Longer term, evaluate expressions in the proper lexical scope.\n  var wrappedArgFunc = function () {\n    var viewToEvaluateArg = null;\n    if (w.parentView && w.parentView.name === 'InOuterTemplateScope') {\n      viewToEvaluateArg = w.parentView.originalParentView;\n    }\n    if (viewToEvaluateArg) {\n      return Blaze._withCurrentView(viewToEvaluateArg, argFunc);\n    } else {\n      return argFunc();\n    }\n  };\n\n  var wrappedContentFunc = function () {\n    var content = contentFunc.call(this);\n\n    // Since we are generating the Blaze._TemplateWith view for the\n    // user, set the flag on the child view.  If `content` is a template,\n    // construct the View so that we can set the flag.\n    if (content instanceof Blaze.Template) {\n      content = content.constructView();\n    }\n    if (content instanceof Blaze.View) {\n      content._hasGeneratedParent = true;\n    }\n\n    return content;\n  };\n\n  w = Blaze.With(wrappedArgFunc, wrappedContentFunc);\n  w.__isTemplateWith = true;\n  return w;\n};\n\nBlaze._InOuterTemplateScope = function (templateView, contentFunc) {\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);\n  var parentView = templateView.parentView;\n\n  // Hack so that if you call `{{> foo bar}}` and it expands into\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\n  // that inserts `{{> Template.contentBlock}}`, the data context for\n  // `Template.contentBlock` is not `bar` but the one enclosing that.\n  if (parentView.__isTemplateWith)\n    parentView = parentView.parentView;\n\n  view.onViewCreated(function () {\n    this.originalParentView = this.parentView;\n    this.parentView = parentView;\n    this.__childDoesntStartNewLexicalScope = true;\n  });\n  return view;\n};\n\n// XXX COMPAT WITH 0.9.0\nBlaze.InOuterTemplateScope = Blaze._InOuterTemplateScope;\n","Blaze._globalHelpers = {};\n\n// Documented as Template.registerHelper.\n// This definition also provides back-compat for `UI.registerHelper`.\nBlaze.registerHelper = function (name, func) {\n  Blaze._globalHelpers[name] = func;\n};\n\nvar bindIfIsFunction = function (x, target) {\n  if (typeof x !== 'function')\n    return x;\n  return _.bind(x, target);\n};\n\n// If `x` is a function, binds the value of `this` for that function\n// to the current data context.\nvar bindDataContext = function (x) {\n  if (typeof x === 'function') {\n    return function () {\n      var data = Blaze.getData();\n      if (data == null)\n        data = {};\n      return x.apply(data, arguments);\n    };\n  }\n  return x;\n};\n\nBlaze._OLDSTYLE_HELPER = {};\n\nBlaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n  // XXX COMPAT WITH 0.9.3\n  var isKnownOldStyleHelper = false;\n\n  if (template.__helpers.has(name)) {\n    var helper = template.__helpers.get(name);\n    if (helper === Blaze._OLDSTYLE_HELPER) {\n      isKnownOldStyleHelper = true;\n    } else if (helper != null) {\n      return wrapHelper(bindDataContext(helper), tmplInstanceFunc);\n    } else {\n      return null;\n    }\n  }\n\n  // old-style helper\n  if (name in template) {\n    // Only warn once per helper\n    if (! isKnownOldStyleHelper) {\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n      if (! template._NOWARN_OLDSTYLE_HELPERS) {\n        Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n                    name + ' = ...` is deprecated.  Use `' + template.viewName +\n                    '.helpers(...)` instead.');\n      }\n    }\n    if (template[name] != null) {\n      return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n    }\n  }\n\n  return null;\n};\n\nvar wrapHelper = function (f, templateFunc) {\n  if (typeof f !== \"function\") {\n    return f;\n  }\n\n  return function () {\n    var self = this;\n    var args = arguments;\n\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n      return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n    });\n  };\n};\n\nBlaze._lexicalBindingLookup = function (view, name) {\n  var currentView = view;\n  var blockHelpersStack = [];\n\n  // walk up the views stopping at a Spacebars.include or Template view that\n  // doesn't have an InOuterTemplateScope view as a parent\n  do {\n    // skip block helpers views\n    // if we found the binding on the scope, return it\n    if (_.has(currentView._scopeBindings, name)) {\n      var bindingReactiveVar = currentView._scopeBindings[name];\n      return function () {\n        return bindingReactiveVar.get();\n      };\n    }\n  } while (! (currentView.__startsNewLexicalScope &&\n              ! (currentView.parentView &&\n                 currentView.parentView.__childDoesntStartNewLexicalScope))\n           && (currentView = currentView.parentView));\n\n  return null;\n};\n\n// templateInstance argument is provided to be available for possible\n// alternative implementations of this function by 3rd party packages.\nBlaze._getTemplate = function (name, templateInstance) {\n  if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {\n    return Blaze.Template[name];\n  }\n  return null;\n};\n\nBlaze._getGlobalHelper = function (name, templateInstance) {\n  if (Blaze._globalHelpers[name] != null) {\n    return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance);\n  }\n  return null;\n};\n\n// Looks up a name, like \"foo\" or \"..\", as a helper of the\n// current template; the name of a template; a global helper;\n// or a property of the data context.  Called on the View of\n// a template (i.e. a View with a `.template` property,\n// where the helpers are).  Used for the first name in a\n// \"path\" in a template tag, like \"foo\" in `{{foo.bar}}` or\n// \"..\" in `{{frobulate ../blah}}`.\n//\n// Returns a function, a non-function value, or null.  If\n// a function is found, it is bound appropriately.\n//\n// NOTE: This function must not establish any reactive\n// dependencies itself.  If there is any reactivity in the\n// value, lookup should return a function.\nBlaze.View.prototype.lookup = function (name, _options) {\n  var template = this.template;\n  var lookupTemplate = _options && _options.template;\n  var helper;\n  var binding;\n  var boundTmplInstance;\n  var foundTemplate;\n\n  if (this.templateInstance) {\n    boundTmplInstance = _.bind(this.templateInstance, this);\n  }\n\n  // 0. looking up the parent data context with the special \"../\" syntax\n  if (/^\\./.test(name)) {\n    // starts with a dot. must be a series of dots which maps to an\n    // ancestor of the appropriate height.\n    if (!/^(\\.)+$/.test(name))\n      throw new Error(\"id starting with dot must be a series of dots\");\n\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n  }\n\n  // 1. look up a helper on the current template\n  if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {\n    return helper;\n  }\n\n  // 2. look up a binding by traversing the lexical view hierarchy inside the\n  // current template\n  if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n    return binding;\n  }\n\n  // 3. look up a template by name\n  if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {\n    return foundTemplate;\n  }\n\n  // 4. look up a global helper\n  if ((helper = Blaze._getGlobalHelper(name, boundTmplInstance)) != null) {\n    return helper;\n  }\n\n  // 5. look up in a data context\n  return function () {\n    var isCalledAsFunction = (arguments.length > 0);\n    var data = Blaze.getData();\n    var x = data && data[name];\n    if (! x) {\n      if (lookupTemplate) {\n        throw new Error(\"No such template: \" + name);\n      } else if (isCalledAsFunction) {\n        throw new Error(\"No such function: \" + name);\n      } else if (name.charAt(0) === '@' && ((x === null) ||\n                                            (x === undefined))) {\n        // Throw an error if the user tries to use a `@directive`\n        // that doesn't exist.  We don't implement all directives\n        // from Handlebars, so there's a potential for confusion\n        // if we fail silently.  On the other hand, we want to\n        // throw late in case some app or package wants to provide\n        // a missing directive.\n        throw new Error(\"Unsupported directive: \" + name);\n      }\n    }\n    if (! data) {\n      return null;\n    }\n    if (typeof x !== 'function') {\n      if (isCalledAsFunction) {\n        throw new Error(\"Can't call non-function: \" + x);\n      }\n      return x;\n    }\n    return x.apply(data, arguments);\n  };\n};\n\n// Implement Spacebars' {{../..}}.\n// @param height {Number} The number of '..'s\nBlaze._parentData = function (height, _functionWrapped) {\n  // If height is null or undefined, we default to 1, the first parent.\n  if (height == null) {\n    height = 1;\n  }\n  var theWith = Blaze.getView('with');\n  for (var i = 0; (i < height) && theWith; i++) {\n    theWith = Blaze.getView(theWith, 'with');\n  }\n\n  if (! theWith)\n    return null;\n  if (_functionWrapped)\n    return function () { return theWith.dataVar.get(); };\n  return theWith.dataVar.get();\n};\n\n\nBlaze.View.prototype.lookupTemplate = function (name) {\n  return this.lookup(name, {template:true});\n};\n","// [new] Blaze.Template([viewName], renderFunction)\n//\n// `Blaze.Template` is the class of templates, like `Template.foo` in\n// Meteor, which is `instanceof Template`.\n//\n// `viewKind` is a string that looks like \"Template.foo\" for templates\n// defined by the compiler.\n\n/**\n * @class\n * @summary Constructor for a Template, which is used to construct Views with particular name and content.\n * @locus Client\n * @param {String} [viewName] Optional.  A name for Views constructed by this Template.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  This function is used as the `renderFunction` for Views constructed by this Template.\n */\nBlaze.Template = function (viewName, renderFunction) {\n  if (! (this instanceof Blaze.Template))\n    // called without `new`\n    return new Blaze.Template(viewName, renderFunction);\n\n  if (typeof viewName === 'function') {\n    // omitted \"viewName\" argument\n    renderFunction = viewName;\n    viewName = '';\n  }\n  if (typeof viewName !== 'string')\n    throw new Error(\"viewName must be a String (or omitted)\");\n  if (typeof renderFunction !== 'function')\n    throw new Error(\"renderFunction must be a function\");\n\n  this.viewName = viewName;\n  this.renderFunction = renderFunction;\n\n  this.__helpers = new HelperMap;\n  this.__eventMaps = [];\n\n  this._callbacks = {\n    created: [],\n    rendered: [],\n    destroyed: []\n  };\n};\nvar Template = Blaze.Template;\n\nvar HelperMap = function () {};\nHelperMap.prototype.get = function (name) {\n  return this[' '+name];\n};\nHelperMap.prototype.set = function (name, helper) {\n  this[' '+name] = helper;\n};\nHelperMap.prototype.has = function (name) {\n  return (' '+name) in this;\n};\n\n/**\n * @summary Returns true if `value` is a template object like `Template.myTemplate`.\n * @locus Client\n * @param {Any} value The value to test.\n */\nBlaze.isTemplate = function (t) {\n  return (t instanceof Blaze.Template);\n};\n\n/**\n * @name  onCreated\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is created.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onCreated = function (cb) {\n  this._callbacks.created.push(cb);\n};\n\n/**\n * @name  onRendered\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is inserted into the DOM.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onRendered = function (cb) {\n  this._callbacks.rendered.push(cb);\n};\n\n/**\n * @name  onDestroyed\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is removed from the DOM and destroyed.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onDestroyed = function (cb) {\n  this._callbacks.destroyed.push(cb);\n};\n\nTemplate.prototype._getCallbacks = function (which) {\n  var self = this;\n  var callbacks = self[which] ? [self[which]] : [];\n  // Fire all callbacks added with the new API (Template.onRendered())\n  // as well as the old-style callback (e.g. Template.rendered) for\n  // backwards-compatibility.\n  callbacks = callbacks.concat(self._callbacks[which]);\n  return callbacks;\n};\n\nvar fireCallbacks = function (callbacks, template) {\n  Template._withTemplateInstanceFunc(\n    function () { return template; },\n    function () {\n      for (var i = 0, N = callbacks.length; i < N; i++) {\n        callbacks[i].call(template);\n      }\n    });\n};\n\nTemplate.prototype.constructView = function (contentFunc, elseFunc) {\n  var self = this;\n  var view = Blaze.View(self.viewName, self.renderFunction);\n  view.template = self;\n\n  view.templateContentBlock = (\n    contentFunc ? new Template('(contentBlock)', contentFunc) : null);\n  view.templateElseBlock = (\n    elseFunc ? new Template('(elseBlock)', elseFunc) : null);\n\n  if (self.__eventMaps || typeof self.events === 'object') {\n    view._onViewRendered(function () {\n      if (view.renderCount !== 1)\n        return;\n\n      if (! self.__eventMaps.length && typeof self.events === \"object\") {\n        // Provide limited back-compat support for `.events = {...}`\n        // syntax.  Pass `template.events` to the original `.events(...)`\n        // function.  This code must run only once per template, in\n        // order to not bind the handlers more than once, which is\n        // ensured by the fact that we only do this when `__eventMaps`\n        // is falsy, and we cause it to be set now.\n        Template.prototype.events.call(self, self.events);\n      }\n\n      _.each(self.__eventMaps, function (m) {\n        Blaze._addEventMap(view, m, view);\n      });\n    });\n  }\n\n  view._templateInstance = new Blaze.TemplateInstance(view);\n  view.templateInstance = function () {\n    // Update data, firstNode, and lastNode, and return the TemplateInstance\n    // object.\n    var inst = view._templateInstance;\n\n    /**\n     * @instance\n     * @memberOf Blaze.TemplateInstance\n     * @name  data\n     * @summary The data context of this instance's latest invocation.\n     * @locus Client\n     */\n    inst.data = Blaze.getData(view);\n\n    if (view._domrange && !view.isDestroyed) {\n      inst.firstNode = view._domrange.firstNode();\n      inst.lastNode = view._domrange.lastNode();\n    } else {\n      // on 'created' or 'destroyed' callbacks we don't have a DomRange\n      inst.firstNode = null;\n      inst.lastNode = null;\n    }\n\n    return inst;\n  };\n\n  /**\n   * @name  created\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is created.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  // To avoid situations when new callbacks are added in between view\n  // instantiation and event being fired, decide on all callbacks to fire\n  // immediately and then fire them on the event.\n  var createdCallbacks = self._getCallbacks('created');\n  view.onViewCreated(function () {\n    fireCallbacks(createdCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  rendered\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is rendered.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  var renderedCallbacks = self._getCallbacks('rendered');\n  view.onViewReady(function () {\n    fireCallbacks(renderedCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  destroyed\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is destroyed.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  var destroyedCallbacks = self._getCallbacks('destroyed');\n  view.onViewDestroyed(function () {\n    fireCallbacks(destroyedCallbacks, view.templateInstance());\n  });\n\n  return view;\n};\n\n/**\n * @class\n * @summary The class for template instances\n * @param {Blaze.View} view\n * @instanceName template\n */\nBlaze.TemplateInstance = function (view) {\n  if (! (this instanceof Blaze.TemplateInstance))\n    // called without `new`\n    return new Blaze.TemplateInstance(view);\n\n  if (! (view instanceof Blaze.View))\n    throw new Error(\"View required\");\n\n  view._templateInstance = this;\n\n  /**\n   * @name view\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The [View](#blaze_view) object for this invocation of the template.\n   * @locus Client\n   * @type {Blaze.View}\n   */\n  this.view = view;\n  this.data = null;\n\n  /**\n   * @name firstNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The first top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.firstNode = null;\n\n  /**\n   * @name lastNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The last top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.lastNode = null;\n\n  // This dependency is used to identify state transitions in\n  // _subscriptionHandles which could cause the result of\n  // TemplateInstance#subscriptionsReady to change. Basically this is triggered\n  // whenever a new subscription handle is added or when a subscription handle\n  // is removed and they are not ready.\n  this._allSubsReadyDep = new Tracker.Dependency();\n  this._allSubsReady = false;\n\n  this._subscriptionHandles = {};\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance, and return them as a JQuery object.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMNode[]}\n */\nBlaze.TemplateInstance.prototype.$ = function (selector) {\n  var view = this.view;\n  if (! view._domrange)\n    throw new Error(\"Can't use $ on template instance with no DOM\");\n  return view._domrange.$(selector);\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement[]}\n */\nBlaze.TemplateInstance.prototype.findAll = function (selector) {\n  return Array.prototype.slice.call(this.$(selector));\n};\n\n/**\n * @summary Find one element matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement}\n */\nBlaze.TemplateInstance.prototype.find = function (selector) {\n  var result = this.$(selector);\n  return result[0] || null;\n};\n\n/**\n * @summary A version of [Tracker.autorun](#tracker_autorun) that is stopped when the template is destroyed.\n * @locus Client\n * @param {Function} runFunc The function to run. It receives one argument: a Tracker.Computation object.\n */\nBlaze.TemplateInstance.prototype.autorun = function (f) {\n  return this.view.autorun(f);\n};\n\n/**\n * @summary A version of [Meteor.subscribe](#meteor_subscribe) that is stopped\n * when the template is destroyed.\n * @return {SubscriptionHandle} The subscription handle to the newly made\n * subscription. Call `handle.stop()` to manually stop the subscription, or\n * `handle.ready()` to find out if this particular subscription has loaded all\n * of its inital data.\n * @locus Client\n * @param {String} name Name of the subscription.  Matches the name of the\n * server's `publish()` call.\n * @param {Any} [arg1,arg2...] Optional arguments passed to publisher function\n * on server.\n * @param {Function|Object} [options] If a function is passed instead of an\n * object, it is interpreted as an `onReady` callback.\n * @param {Function} [options.onReady] Passed to [`Meteor.subscribe`](#meteor_subscribe).\n * @param {Function} [options.onStop] Passed to [`Meteor.subscribe`](#meteor_subscribe).\n * @param {DDP.Connection} [options.connection] The connection on which to make the\n * subscription.\n */\nBlaze.TemplateInstance.prototype.subscribe = function (/* arguments */) {\n  var self = this;\n\n  var subHandles = self._subscriptionHandles;\n  var args = _.toArray(arguments);\n\n  // Duplicate logic from Meteor.subscribe\n  var options = {};\n  if (args.length) {\n    var lastParam = _.last(args);\n\n    // Match pattern to check if the last arg is an options argument\n    var lastParamOptionsPattern = {\n      onReady: Match.Optional(Function),\n      // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n      // onStop with an error callback instead.\n      onError: Match.Optional(Function),\n      onStop: Match.Optional(Function),\n      connection: Match.Optional(Match.Any)\n    };\n\n    if (_.isFunction(lastParam)) {\n      options.onReady = args.pop();\n    } else if (lastParam && Match.test(lastParam, lastParamOptionsPattern)) {\n      options = args.pop();\n    }\n  }\n\n  var subHandle;\n  var oldStopped = options.onStop;\n  options.onStop = function (error) {\n    // When the subscription is stopped, remove it from the set of tracked\n    // subscriptions to avoid this list growing without bound\n    delete subHandles[subHandle.subscriptionId];\n\n    // Removing a subscription can only change the result of subscriptionsReady\n    // if we are not ready (that subscription could be the one blocking us being\n    // ready).\n    if (! self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n\n    if (oldStopped) {\n      oldStopped(error);\n    }\n  };\n\n  var connection = options.connection;\n  var callbacks = _.pick(options, [\"onReady\", \"onError\", \"onStop\"]);\n\n  // The callbacks are passed as the last item in the arguments array passed to\n  // View#subscribe\n  args.push(callbacks);\n\n  // View#subscribe takes the connection as one of the options in the last\n  // argument\n  subHandle = self.view.subscribe.call(self.view, args, {\n    connection: connection\n  });\n\n  if (! _.has(subHandles, subHandle.subscriptionId)) {\n    subHandles[subHandle.subscriptionId] = subHandle;\n\n    // Adding a new subscription will always cause us to transition from ready\n    // to not ready, but if we are already not ready then this can't make us\n    // ready.\n    if (self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n  }\n\n  return subHandle;\n};\n\n/**\n * @summary A reactive function that returns true when all of the subscriptions\n * called with [this.subscribe](#TemplateInstance-subscribe) are ready.\n * @return {Boolean} True if all subscriptions on this template instance are\n * ready.\n */\nBlaze.TemplateInstance.prototype.subscriptionsReady = function () {\n  this._allSubsReadyDep.depend();\n\n  this._allSubsReady = _.all(this._subscriptionHandles, function (handle) {\n    return handle.ready();\n  });\n\n  return this._allSubsReady;\n};\n\n/**\n * @summary Specify template helpers available to this template.\n * @locus Client\n * @param {Object} helpers Dictionary of helper functions by name.\n */\nTemplate.prototype.helpers = function (dict) {\n  for (var k in dict)\n    this.__helpers.set(k, dict[k]);\n};\n\n// Kind of like Blaze.currentView but for the template instance.\n// This is a function, not a value -- so that not all helpers\n// are implicitly dependent on the current template instance's `data` property,\n// which would make them dependenct on the data context of the template\n// inclusion.\nTemplate._currentTemplateInstanceFunc = null;\n\nTemplate._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n  if (typeof func !== 'function')\n    throw new Error(\"Expected function, got: \" + func);\n  var oldTmplInstanceFunc = Template._currentTemplateInstanceFunc;\n  try {\n    Template._currentTemplateInstanceFunc = templateInstanceFunc;\n    return func();\n  } finally {\n    Template._currentTemplateInstanceFunc = oldTmplInstanceFunc;\n  }\n};\n\n/**\n * @summary Specify event handlers for this template.\n * @locus Client\n * @param {EventMap} eventMap Event handlers to associate with this template.\n */\nTemplate.prototype.events = function (eventMap) {\n  var template = this;\n  var eventMap2 = {};\n  for (var k in eventMap) {\n    eventMap2[k] = (function (k, v) {\n      return function (event/*, ...*/) {\n        var view = this; // passed by EventAugmenter\n        var data = Blaze.getData(event.currentTarget);\n        if (data == null)\n          data = {};\n        var args = Array.prototype.slice.call(arguments);\n        var tmplInstanceFunc = _.bind(view.templateInstance, view);\n        args.splice(1, 0, tmplInstanceFunc());\n\n        return Template._withTemplateInstanceFunc(tmplInstanceFunc, function () {\n          return v.apply(data, args);\n        });\n      };\n    })(k, eventMap[k]);\n  }\n\n  template.__eventMaps.push(eventMap2);\n};\n\n/**\n * @function\n * @name instance\n * @memberOf Template\n * @summary The [template instance](#template_inst) corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @returns {Blaze.TemplateInstance}\n */\nTemplate.instance = function () {\n  return Template._currentTemplateInstanceFunc\n    && Template._currentTemplateInstanceFunc();\n};\n\n// Note: Template.currentData() is documented to take zero arguments,\n// while Blaze.getData takes up to one.\n\n/**\n * @summary\n *\n * - Inside an `onCreated`, `onRendered`, or `onDestroyed` callback, returns\n * the data context of the template.\n * - Inside an event handler, returns the data context of the template on which\n * this event handler was defined.\n * - Inside a helper, returns the data context of the DOM node where the helper\n * was used.\n *\n * Establishes a reactive dependency on the result.\n * @locus Client\n * @function\n */\nTemplate.currentData = Blaze.getData;\n\n/**\n * @summary Accesses other data contexts that enclose the current data context.\n * @locus Client\n * @function\n * @param {Integer} [numLevels] The number of levels beyond the current data context to look. Defaults to 1.\n */\nTemplate.parentData = Blaze._parentData;\n\n/**\n * @summary Defines a [helper function](#template_helpers) which can be used from all templates.\n * @locus Client\n * @function\n * @param {String} name The name of the helper function you are defining.\n * @param {Function} function The helper function itself.\n */\nTemplate.registerHelper = Blaze.registerHelper;\n","UI = Blaze;\n\nBlaze.ReactiveVar = ReactiveVar;\nUI._templateInstance = Blaze.Template.instance;\n\nHandlebars = {};\nHandlebars.registerHelper = Blaze.registerHelper;\n\nHandlebars._escape = Blaze._escape;\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}}]