[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Package-scope variables */\nvar exports, _;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                       //\n// packages/underscore/pre.js                                                                            //\n//                                                                                                       //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                         //\n// Define an object named exports. This will cause underscore.js to put `_` as a                         // 1\n// field on it, instead of in the global namespace.  See also post.js.                                   // 2\nexports = {};                                                                                            // 3\n                                                                                                         // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                       //\n// packages/underscore/underscore.js                                                                     //\n//                                                                                                       //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                         //\n//     Underscore.js 1.5.2                                                                               // 1\n//     http://underscorejs.org                                                                           // 2\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                // 3\n//     Underscore may be freely distributed under the MIT license.                                       // 4\n                                                                                                         // 5\n(function() {                                                                                            // 6\n                                                                                                         // 7\n  // Baseline setup                                                                                      // 8\n  // --------------                                                                                      // 9\n                                                                                                         // 10\n  // Establish the root object, `window` in the browser, or `exports` on the server.                     // 11\n  var root = this;                                                                                       // 12\n                                                                                                         // 13\n  // Save the previous value of the `_` variable.                                                        // 14\n  var previousUnderscore = root._;                                                                       // 15\n                                                                                                         // 16\n  // Establish the object that gets returned to break out of a loop iteration.                           // 17\n  var breaker = {};                                                                                      // 18\n                                                                                                         // 19\n  // Save bytes in the minified (but not gzipped) version:                                               // 20\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;         // 21\n                                                                                                         // 22\n  // Create quick reference variables for speed access to core prototypes.                               // 23\n  var                                                                                                    // 24\n    push             = ArrayProto.push,                                                                  // 25\n    slice            = ArrayProto.slice,                                                                 // 26\n    concat           = ArrayProto.concat,                                                                // 27\n    toString         = ObjProto.toString,                                                                // 28\n    hasOwnProperty   = ObjProto.hasOwnProperty;                                                          // 29\n                                                                                                         // 30\n  // All **ECMAScript 5** native function implementations that we hope to use                            // 31\n  // are declared here.                                                                                  // 32\n  var                                                                                                    // 33\n    nativeForEach      = ArrayProto.forEach,                                                             // 34\n    nativeMap          = ArrayProto.map,                                                                 // 35\n    nativeReduce       = ArrayProto.reduce,                                                              // 36\n    nativeReduceRight  = ArrayProto.reduceRight,                                                         // 37\n    nativeFilter       = ArrayProto.filter,                                                              // 38\n    nativeEvery        = ArrayProto.every,                                                               // 39\n    nativeSome         = ArrayProto.some,                                                                // 40\n    nativeIndexOf      = ArrayProto.indexOf,                                                             // 41\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,                                                         // 42\n    nativeIsArray      = Array.isArray,                                                                  // 43\n    nativeKeys         = Object.keys,                                                                    // 44\n    nativeBind         = FuncProto.bind;                                                                 // 45\n                                                                                                         // 46\n  // Create a safe reference to the Underscore object for use below.                                     // 47\n  var _ = function(obj) {                                                                                // 48\n    if (obj instanceof _) return obj;                                                                    // 49\n    if (!(this instanceof _)) return new _(obj);                                                         // 50\n    this._wrapped = obj;                                                                                 // 51\n  };                                                                                                     // 52\n                                                                                                         // 53\n  // Export the Underscore object for **Node.js**, with                                                  // 54\n  // backwards-compatibility for the old `require()` API. If we're in                                    // 55\n  // the browser, add `_` as a global object via a string identifier,                                    // 56\n  // for Closure Compiler \"advanced\" mode.                                                               // 57\n  if (typeof exports !== 'undefined') {                                                                  // 58\n    if (typeof module !== 'undefined' && module.exports) {                                               // 59\n      exports = module.exports = _;                                                                      // 60\n    }                                                                                                    // 61\n    exports._ = _;                                                                                       // 62\n  } else {                                                                                               // 63\n    root._ = _;                                                                                          // 64\n  }                                                                                                      // 65\n                                                                                                         // 66\n  // Current version.                                                                                    // 67\n  _.VERSION = '1.5.2';                                                                                   // 68\n                                                                                                         // 69\n  // Collection Functions                                                                                // 70\n  // --------------------                                                                                // 71\n                                                                                                         // 72\n  // METEOR CHANGE: Define _isArguments instead of depending on                                          // 73\n  // _.isArguments which is defined using each. In looksLikeArray                                        // 74\n  // (which each depends on), we then use _isArguments instead of                                        // 75\n  // _.isArguments.                                                                                      // 76\n  var _isArguments = function (obj) {                                                                    // 77\n    return toString.call(obj) === '[object Arguments]';                                                  // 78\n  };                                                                                                     // 79\n  // Define a fallback version of the method in browsers (ahem, IE), where                               // 80\n  // there isn't any inspectable \"Arguments\" type.                                                       // 81\n  if (!_isArguments(arguments)) {                                                                        // 82\n    _isArguments = function (obj) {                                                                      // 83\n      return !!(obj && hasOwnProperty.call(obj, 'callee') && typeof obj.callee === 'function');          // 84\n    };                                                                                                   // 85\n  }                                                                                                      // 86\n                                                                                                         // 87\n  // METEOR CHANGE: _.each({length: 5}) should be treated like an object, not an                         // 88\n  // array. This looksLikeArray function is introduced by Meteor, and replaces                           // 89\n  // all instances of `obj.length === +obj.length`.                                                      // 90\n  // https://github.com/meteor/meteor/issues/594                                                         // 91\n  // https://github.com/jashkenas/underscore/issues/770                                                  // 92\n  var looksLikeArray = function (obj) {                                                                  // 93\n    return (obj.length === +obj.length                                                                   // 94\n            // _.isArguments not yet necessarily defined here                                            // 95\n            && (_isArguments(obj) || obj.constructor !== Object));                                       // 96\n  };                                                                                                     // 97\n                                                                                                         // 98\n  // The cornerstone, an `each` implementation, aka `forEach`.                                           // 99\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.                               // 100\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.                                      // 101\n  var each = _.each = _.forEach = function(obj, iterator, context) {                                     // 102\n    if (obj == null) return;                                                                             // 103\n    if (nativeForEach && obj.forEach === nativeForEach) {                                                // 104\n      obj.forEach(iterator, context);                                                                    // 105\n    } else if (looksLikeArray(obj)) {                                                                    // 106\n      for (var i = 0, length = obj.length; i < length; i++) {                                            // 107\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;                                  // 108\n      }                                                                                                  // 109\n    } else {                                                                                             // 110\n      var keys = _.keys(obj);                                                                            // 111\n      for (var i = 0, length = keys.length; i < length; i++) {                                           // 112\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;                      // 113\n      }                                                                                                  // 114\n    }                                                                                                    // 115\n  };                                                                                                     // 116\n                                                                                                         // 117\n  // Return the results of applying the iterator to each element.                                        // 118\n  // Delegates to **ECMAScript 5**'s native `map` if available.                                          // 119\n  _.map = _.collect = function(obj, iterator, context) {                                                 // 120\n    var results = [];                                                                                    // 121\n    if (obj == null) return results;                                                                     // 122\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);                           // 123\n    each(obj, function(value, index, list) {                                                             // 124\n      results.push(iterator.call(context, value, index, list));                                          // 125\n    });                                                                                                  // 126\n    return results;                                                                                      // 127\n  };                                                                                                     // 128\n                                                                                                         // 129\n  var reduceError = 'Reduce of empty array with no initial value';                                       // 130\n                                                                                                         // 131\n  // **Reduce** builds up a single result from a list of values, aka `inject`,                           // 132\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.                           // 133\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {                               // 134\n    var initial = arguments.length > 2;                                                                  // 135\n    if (obj == null) obj = [];                                                                           // 136\n    if (nativeReduce && obj.reduce === nativeReduce) {                                                   // 137\n      if (context) iterator = _.bind(iterator, context);                                                 // 138\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);                                // 139\n    }                                                                                                    // 140\n    each(obj, function(value, index, list) {                                                             // 141\n      if (!initial) {                                                                                    // 142\n        memo = value;                                                                                    // 143\n        initial = true;                                                                                  // 144\n      } else {                                                                                           // 145\n        memo = iterator.call(context, memo, value, index, list);                                         // 146\n      }                                                                                                  // 147\n    });                                                                                                  // 148\n    if (!initial) throw new TypeError(reduceError);                                                      // 149\n    return memo;                                                                                         // 150\n  };                                                                                                     // 151\n                                                                                                         // 152\n  // The right-associative version of reduce, also known as `foldr`.                                     // 153\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.                                  // 154\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {                                     // 155\n    var initial = arguments.length > 2;                                                                  // 156\n    if (obj == null) obj = [];                                                                           // 157\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {                                    // 158\n      if (context) iterator = _.bind(iterator, context);                                                 // 159\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);                      // 160\n    }                                                                                                    // 161\n    var length = obj.length;                                                                             // 162\n    if (!looksLikeArray(obj)) {                                                                          // 163\n      var keys = _.keys(obj);                                                                            // 164\n      length = keys.length;                                                                              // 165\n    }                                                                                                    // 166\n    each(obj, function(value, index, list) {                                                             // 167\n      index = keys ? keys[--length] : --length;                                                          // 168\n      if (!initial) {                                                                                    // 169\n        memo = obj[index];                                                                               // 170\n        initial = true;                                                                                  // 171\n      } else {                                                                                           // 172\n        memo = iterator.call(context, memo, obj[index], index, list);                                    // 173\n      }                                                                                                  // 174\n    });                                                                                                  // 175\n    if (!initial) throw new TypeError(reduceError);                                                      // 176\n    return memo;                                                                                         // 177\n  };                                                                                                     // 178\n                                                                                                         // 179\n  // Return the first value which passes a truth test. Aliased as `detect`.                              // 180\n  _.find = _.detect = function(obj, iterator, context) {                                                 // 181\n    var result;                                                                                          // 182\n    any(obj, function(value, index, list) {                                                              // 183\n      if (iterator.call(context, value, index, list)) {                                                  // 184\n        result = value;                                                                                  // 185\n        return true;                                                                                     // 186\n      }                                                                                                  // 187\n    });                                                                                                  // 188\n    return result;                                                                                       // 189\n  };                                                                                                     // 190\n                                                                                                         // 191\n  // Return all the elements that pass a truth test.                                                     // 192\n  // Delegates to **ECMAScript 5**'s native `filter` if available.                                       // 193\n  // Aliased as `select`.                                                                                // 194\n  _.filter = _.select = function(obj, iterator, context) {                                               // 195\n    var results = [];                                                                                    // 196\n    if (obj == null) return results;                                                                     // 197\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);               // 198\n    each(obj, function(value, index, list) {                                                             // 199\n      if (iterator.call(context, value, index, list)) results.push(value);                               // 200\n    });                                                                                                  // 201\n    return results;                                                                                      // 202\n  };                                                                                                     // 203\n                                                                                                         // 204\n  // Return all the elements for which a truth test fails.                                               // 205\n  _.reject = function(obj, iterator, context) {                                                          // 206\n    return _.filter(obj, function(value, index, list) {                                                  // 207\n      return !iterator.call(context, value, index, list);                                                // 208\n    }, context);                                                                                         // 209\n  };                                                                                                     // 210\n                                                                                                         // 211\n  // Determine whether all of the elements match a truth test.                                           // 212\n  // Delegates to **ECMAScript 5**'s native `every` if available.                                        // 213\n  // Aliased as `all`.                                                                                   // 214\n  _.every = _.all = function(obj, iterator, context) {                                                   // 215\n    iterator || (iterator = _.identity);                                                                 // 216\n    var result = true;                                                                                   // 217\n    if (obj == null) return result;                                                                      // 218\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);                   // 219\n    each(obj, function(value, index, list) {                                                             // 220\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;              // 221\n    });                                                                                                  // 222\n    return !!result;                                                                                     // 223\n  };                                                                                                     // 224\n                                                                                                         // 225\n  // Determine if at least one element in the object matches a truth test.                               // 226\n  // Delegates to **ECMAScript 5**'s native `some` if available.                                         // 227\n  // Aliased as `any`.                                                                                   // 228\n  var any = _.some = _.any = function(obj, iterator, context) {                                          // 229\n    iterator || (iterator = _.identity);                                                                 // 230\n    var result = false;                                                                                  // 231\n    if (obj == null) return result;                                                                      // 232\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);                       // 233\n    each(obj, function(value, index, list) {                                                             // 234\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;               // 235\n    });                                                                                                  // 236\n    return !!result;                                                                                     // 237\n  };                                                                                                     // 238\n                                                                                                         // 239\n  // Determine if the array or object contains a given value (using `===`).                              // 240\n  // Aliased as `include`.                                                                               // 241\n  _.contains = _.include = function(obj, target) {                                                       // 242\n    if (obj == null) return false;                                                                       // 243\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;                // 244\n    return any(obj, function(value) {                                                                    // 245\n      return value === target;                                                                           // 246\n    });                                                                                                  // 247\n  };                                                                                                     // 248\n                                                                                                         // 249\n  // Invoke a method (with arguments) on every item in a collection.                                     // 250\n  _.invoke = function(obj, method) {                                                                     // 251\n    var args = slice.call(arguments, 2);                                                                 // 252\n    var isFunc = _.isFunction(method);                                                                   // 253\n    return _.map(obj, function(value) {                                                                  // 254\n      return (isFunc ? method : value[method]).apply(value, args);                                       // 255\n    });                                                                                                  // 256\n  };                                                                                                     // 257\n                                                                                                         // 258\n  // Convenience version of a common use case of `map`: fetching a property.                             // 259\n  _.pluck = function(obj, key) {                                                                         // 260\n    return _.map(obj, function(value){ return value[key]; });                                            // 261\n  };                                                                                                     // 262\n                                                                                                         // 263\n  // Convenience version of a common use case of `filter`: selecting only objects                        // 264\n  // containing specific `key:value` pairs.                                                              // 265\n  _.where = function(obj, attrs, first) {                                                                // 266\n    if (_.isEmpty(attrs)) return first ? void 0 : [];                                                    // 267\n    return _[first ? 'find' : 'filter'](obj, function(value) {                                           // 268\n      for (var key in attrs) {                                                                           // 269\n        if (attrs[key] !== value[key]) return false;                                                     // 270\n      }                                                                                                  // 271\n      return true;                                                                                       // 272\n    });                                                                                                  // 273\n  };                                                                                                     // 274\n                                                                                                         // 275\n  // Convenience version of a common use case of `find`: getting the first object                        // 276\n  // containing specific `key:value` pairs.                                                              // 277\n  _.findWhere = function(obj, attrs) {                                                                   // 278\n    return _.where(obj, attrs, true);                                                                    // 279\n  };                                                                                                     // 280\n                                                                                                         // 281\n  // Return the maximum element or (element-based computation).                                          // 282\n  // Can't optimize arrays of integers longer than 65,535 elements.                                      // 283\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)                               // 284\n  _.max = function(obj, iterator, context) {                                                             // 285\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 286\n      return Math.max.apply(Math, obj);                                                                  // 287\n    }                                                                                                    // 288\n    if (!iterator && _.isEmpty(obj)) return -Infinity;                                                   // 289\n    var result = {computed : -Infinity, value: -Infinity};                                               // 290\n    each(obj, function(value, index, list) {                                                             // 291\n      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 292\n      computed > result.computed && (result = {value : value, computed : computed});                     // 293\n    });                                                                                                  // 294\n    return result.value;                                                                                 // 295\n  };                                                                                                     // 296\n                                                                                                         // 297\n  // Return the minimum element (or element-based computation).                                          // 298\n  _.min = function(obj, iterator, context) {                                                             // 299\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 300\n      return Math.min.apply(Math, obj);                                                                  // 301\n    }                                                                                                    // 302\n    if (!iterator && _.isEmpty(obj)) return Infinity;                                                    // 303\n    var result = {computed : Infinity, value: Infinity};                                                 // 304\n    each(obj, function(value, index, list) {                                                             // 305\n      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 306\n      computed < result.computed && (result = {value : value, computed : computed});                     // 307\n    });                                                                                                  // 308\n    return result.value;                                                                                 // 309\n  };                                                                                                     // 310\n                                                                                                         // 311\n  // Shuffle an array, using the modern version of the                                                   // 312\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).                          // 313\n  _.shuffle = function(obj) {                                                                            // 314\n    var rand;                                                                                            // 315\n    var index = 0;                                                                                       // 316\n    var shuffled = [];                                                                                   // 317\n    each(obj, function(value) {                                                                          // 318\n      rand = _.random(index++);                                                                          // 319\n      shuffled[index - 1] = shuffled[rand];                                                              // 320\n      shuffled[rand] = value;                                                                            // 321\n    });                                                                                                  // 322\n    return shuffled;                                                                                     // 323\n  };                                                                                                     // 324\n                                                                                                         // 325\n  // Sample **n** random values from an array.                                                           // 326\n  // If **n** is not specified, returns a single random element from the array.                          // 327\n  // The internal `guard` argument allows it to work with `map`.                                         // 328\n  _.sample = function(obj, n, guard) {                                                                   // 329\n    if (arguments.length < 2 || guard) {                                                                 // 330\n      return obj[_.random(obj.length - 1)];                                                              // 331\n    }                                                                                                    // 332\n    return _.shuffle(obj).slice(0, Math.max(0, n));                                                      // 333\n  };                                                                                                     // 334\n                                                                                                         // 335\n  // An internal function to generate lookup iterators.                                                  // 336\n  var lookupIterator = function(value) {                                                                 // 337\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };                            // 338\n  };                                                                                                     // 339\n                                                                                                         // 340\n  // Sort the object's values by a criterion produced by an iterator.                                    // 341\n  _.sortBy = function(obj, value, context) {                                                             // 342\n    var iterator = lookupIterator(value);                                                                // 343\n    return _.pluck(_.map(obj, function(value, index, list) {                                             // 344\n      return {                                                                                           // 345\n        value: value,                                                                                    // 346\n        index: index,                                                                                    // 347\n        criteria: iterator.call(context, value, index, list)                                             // 348\n      };                                                                                                 // 349\n    }).sort(function(left, right) {                                                                      // 350\n      var a = left.criteria;                                                                             // 351\n      var b = right.criteria;                                                                            // 352\n      if (a !== b) {                                                                                     // 353\n        if (a > b || a === void 0) return 1;                                                             // 354\n        if (a < b || b === void 0) return -1;                                                            // 355\n      }                                                                                                  // 356\n      return left.index - right.index;                                                                   // 357\n    }), 'value');                                                                                        // 358\n  };                                                                                                     // 359\n                                                                                                         // 360\n  // An internal function used for aggregate \"group by\" operations.                                      // 361\n  var group = function(behavior) {                                                                       // 362\n    return function(obj, value, context) {                                                               // 363\n      var result = {};                                                                                   // 364\n      var iterator = value == null ? _.identity : lookupIterator(value);                                 // 365\n      each(obj, function(value, index) {                                                                 // 366\n        var key = iterator.call(context, value, index, obj);                                             // 367\n        behavior(result, key, value);                                                                    // 368\n      });                                                                                                // 369\n      return result;                                                                                     // 370\n    };                                                                                                   // 371\n  };                                                                                                     // 372\n                                                                                                         // 373\n  // Groups the object's values by a criterion. Pass either a string attribute                           // 374\n  // to group by, or a function that returns the criterion.                                              // 375\n  _.groupBy = group(function(result, key, value) {                                                       // 376\n    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);                                 // 377\n  });                                                                                                    // 378\n                                                                                                         // 379\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for                           // 380\n  // when you know that your index values will be unique.                                                // 381\n  _.indexBy = group(function(result, key, value) {                                                       // 382\n    result[key] = value;                                                                                 // 383\n  });                                                                                                    // 384\n                                                                                                         // 385\n  // Counts instances of an object that group by a certain criterion. Pass                               // 386\n  // either a string attribute to count by, or a function that returns the                               // 387\n  // criterion.                                                                                          // 388\n  _.countBy = group(function(result, key) {                                                              // 389\n    _.has(result, key) ? result[key]++ : result[key] = 1;                                                // 390\n  });                                                                                                    // 391\n                                                                                                         // 392\n  // Use a comparator function to figure out the smallest index at which                                 // 393\n  // an object should be inserted so as to maintain order. Uses binary search.                           // 394\n  _.sortedIndex = function(array, obj, iterator, context) {                                              // 395\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);                                 // 396\n    var value = iterator.call(context, obj);                                                             // 397\n    var low = 0, high = array.length;                                                                    // 398\n    while (low < high) {                                                                                 // 399\n      var mid = (low + high) >>> 1;                                                                      // 400\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;                           // 401\n    }                                                                                                    // 402\n    return low;                                                                                          // 403\n  };                                                                                                     // 404\n                                                                                                         // 405\n  // Safely create a real, live array from anything iterable.                                            // 406\n  _.toArray = function(obj) {                                                                            // 407\n    if (!obj) return [];                                                                                 // 408\n    if (_.isArray(obj)) return slice.call(obj);                                                          // 409\n    if (looksLikeArray(obj)) return _.map(obj, _.identity);                                              // 410\n    return _.values(obj);                                                                                // 411\n  };                                                                                                     // 412\n                                                                                                         // 413\n  // Return the number of elements in an object.                                                         // 414\n  _.size = function(obj) {                                                                               // 415\n    if (obj == null) return 0;                                                                           // 416\n    return (looksLikeArray(obj)) ? obj.length : _.keys(obj).length;                                      // 417\n  };                                                                                                     // 418\n                                                                                                         // 419\n  // Array Functions                                                                                     // 420\n  // ---------------                                                                                     // 421\n                                                                                                         // 422\n  // Get the first element of an array. Passing **n** will return the first N                            // 423\n  // values in the array. Aliased as `head` and `take`. The **guard** check                              // 424\n  // allows it to work with `_.map`.                                                                     // 425\n  _.first = _.head = _.take = function(array, n, guard) {                                                // 426\n    if (array == null) return void 0;                                                                    // 427\n    return (n == null) || guard ? array[0] : slice.call(array, 0, n);                                    // 428\n  };                                                                                                     // 429\n                                                                                                         // 430\n  // Returns everything but the last entry of the array. Especially useful on                            // 431\n  // the arguments object. Passing **n** will return all the values in                                   // 432\n  // the array, excluding the last N. The **guard** check allows it to work with                         // 433\n  // `_.map`.                                                                                            // 434\n  _.initial = function(array, n, guard) {                                                                // 435\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));                          // 436\n  };                                                                                                     // 437\n                                                                                                         // 438\n  // Get the last element of an array. Passing **n** will return the last N                              // 439\n  // values in the array. The **guard** check allows it to work with `_.map`.                            // 440\n  _.last = function(array, n, guard) {                                                                   // 441\n    if (array == null) return void 0;                                                                    // 442\n    if ((n == null) || guard) {                                                                          // 443\n      return array[array.length - 1];                                                                    // 444\n    } else {                                                                                             // 445\n      return slice.call(array, Math.max(array.length - n, 0));                                           // 446\n    }                                                                                                    // 447\n  };                                                                                                     // 448\n                                                                                                         // 449\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                  // 450\n  // Especially useful on the arguments object. Passing an **n** will return                             // 451\n  // the rest N values in the array. The **guard**                                                       // 452\n  // check allows it to work with `_.map`.                                                               // 453\n  _.rest = _.tail = _.drop = function(array, n, guard) {                                                 // 454\n    return slice.call(array, (n == null) || guard ? 1 : n);                                              // 455\n  };                                                                                                     // 456\n                                                                                                         // 457\n  // Trim out all falsy values from an array.                                                            // 458\n  _.compact = function(array) {                                                                          // 459\n    return _.filter(array, _.identity);                                                                  // 460\n  };                                                                                                     // 461\n                                                                                                         // 462\n  // Internal implementation of a recursive `flatten` function.                                          // 463\n  var flatten = function(input, shallow, output) {                                                       // 464\n    if (shallow && _.every(input, _.isArray)) {                                                          // 465\n      return concat.apply(output, input);                                                                // 466\n    }                                                                                                    // 467\n    each(input, function(value) {                                                                        // 468\n      if (_.isArray(value) || _.isArguments(value)) {                                                    // 469\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);                           // 470\n      } else {                                                                                           // 471\n        output.push(value);                                                                              // 472\n      }                                                                                                  // 473\n    });                                                                                                  // 474\n    return output;                                                                                       // 475\n  };                                                                                                     // 476\n                                                                                                         // 477\n  // Flatten out an array, either recursively (by default), or just one level.                           // 478\n  _.flatten = function(array, shallow) {                                                                 // 479\n    return flatten(array, shallow, []);                                                                  // 480\n  };                                                                                                     // 481\n                                                                                                         // 482\n  // Return a version of the array that does not contain the specified value(s).                         // 483\n  _.without = function(array) {                                                                          // 484\n    return _.difference(array, slice.call(arguments, 1));                                                // 485\n  };                                                                                                     // 486\n                                                                                                         // 487\n  // Produce a duplicate-free version of the array. If the array has already                             // 488\n  // been sorted, you have the option of using a faster algorithm.                                       // 489\n  // Aliased as `unique`.                                                                                // 490\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {                                     // 491\n    if (_.isFunction(isSorted)) {                                                                        // 492\n      context = iterator;                                                                                // 493\n      iterator = isSorted;                                                                               // 494\n      isSorted = false;                                                                                  // 495\n    }                                                                                                    // 496\n    var initial = iterator ? _.map(array, iterator, context) : array;                                    // 497\n    var results = [];                                                                                    // 498\n    var seen = [];                                                                                       // 499\n    each(initial, function(value, index) {                                                               // 500\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {           // 501\n        seen.push(value);                                                                                // 502\n        results.push(array[index]);                                                                      // 503\n      }                                                                                                  // 504\n    });                                                                                                  // 505\n    return results;                                                                                      // 506\n  };                                                                                                     // 507\n                                                                                                         // 508\n  // Produce an array that contains the union: each distinct element from all of                         // 509\n  // the passed-in arrays.                                                                               // 510\n  _.union = function() {                                                                                 // 511\n    return _.uniq(_.flatten(arguments, true));                                                           // 512\n  };                                                                                                     // 513\n                                                                                                         // 514\n  // Produce an array that contains every item shared between all the                                    // 515\n  // passed-in arrays.                                                                                   // 516\n  _.intersection = function(array) {                                                                     // 517\n    var rest = slice.call(arguments, 1);                                                                 // 518\n    return _.filter(_.uniq(array), function(item) {                                                      // 519\n      return _.every(rest, function(other) {                                                             // 520\n        return _.indexOf(other, item) >= 0;                                                              // 521\n      });                                                                                                // 522\n    });                                                                                                  // 523\n  };                                                                                                     // 524\n                                                                                                         // 525\n  // Take the difference between one array and a number of other arrays.                                 // 526\n  // Only the elements present in just the first array will remain.                                      // 527\n  _.difference = function(array) {                                                                       // 528\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 529\n    return _.filter(array, function(value){ return !_.contains(rest, value); });                         // 530\n  };                                                                                                     // 531\n                                                                                                         // 532\n  // Zip together multiple lists into a single array -- elements that share                              // 533\n  // an index go together.                                                                               // 534\n  _.zip = function() {                                                                                   // 535\n    var length = _.max(_.pluck(arguments, \"length\").concat(0));                                          // 536\n    var results = new Array(length);                                                                     // 537\n    for (var i = 0; i < length; i++) {                                                                   // 538\n      results[i] = _.pluck(arguments, '' + i);                                                           // 539\n    }                                                                                                    // 540\n    return results;                                                                                      // 541\n  };                                                                                                     // 542\n                                                                                                         // 543\n  // Converts lists into objects. Pass either a single array of `[key, value]`                           // 544\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of                         // 545\n  // the corresponding values.                                                                           // 546\n  _.object = function(list, values) {                                                                    // 547\n    if (list == null) return {};                                                                         // 548\n    var result = {};                                                                                     // 549\n    for (var i = 0, length = list.length; i < length; i++) {                                             // 550\n      if (values) {                                                                                      // 551\n        result[list[i]] = values[i];                                                                     // 552\n      } else {                                                                                           // 553\n        result[list[i][0]] = list[i][1];                                                                 // 554\n      }                                                                                                  // 555\n    }                                                                                                    // 556\n    return result;                                                                                       // 557\n  };                                                                                                     // 558\n                                                                                                         // 559\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),                       // 560\n  // we need this function. Return the position of the first occurrence of an                            // 561\n  // item in an array, or -1 if the item is not included in the array.                                   // 562\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.                                      // 563\n  // If the array is large and already in sort order, pass `true`                                        // 564\n  // for **isSorted** to use binary search.                                                              // 565\n  _.indexOf = function(array, item, isSorted) {                                                          // 566\n    if (array == null) return -1;                                                                        // 567\n    var i = 0, length = array.length;                                                                    // 568\n    if (isSorted) {                                                                                      // 569\n      if (typeof isSorted == 'number') {                                                                 // 570\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);                                  // 571\n      } else {                                                                                           // 572\n        i = _.sortedIndex(array, item);                                                                  // 573\n        return array[i] === item ? i : -1;                                                               // 574\n      }                                                                                                  // 575\n    }                                                                                                    // 576\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);          // 577\n    for (; i < length; i++) if (array[i] === item) return i;                                             // 578\n    return -1;                                                                                           // 579\n  };                                                                                                     // 580\n                                                                                                         // 581\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.                                  // 582\n  _.lastIndexOf = function(array, item, from) {                                                          // 583\n    if (array == null) return -1;                                                                        // 584\n    var hasIndex = from != null;                                                                         // 585\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {                                  // 586\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);                         // 587\n    }                                                                                                    // 588\n    var i = (hasIndex ? from : array.length);                                                            // 589\n    while (i--) if (array[i] === item) return i;                                                         // 590\n    return -1;                                                                                           // 591\n  };                                                                                                     // 592\n                                                                                                         // 593\n  // Generate an integer Array containing an arithmetic progression. A port of                           // 594\n  // the native Python `range()` function. See                                                           // 595\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).                    // 596\n  _.range = function(start, stop, step) {                                                                // 597\n    if (arguments.length <= 1) {                                                                         // 598\n      stop = start || 0;                                                                                 // 599\n      start = 0;                                                                                         // 600\n    }                                                                                                    // 601\n    step = arguments[2] || 1;                                                                            // 602\n                                                                                                         // 603\n    var length = Math.max(Math.ceil((stop - start) / step), 0);                                          // 604\n    var idx = 0;                                                                                         // 605\n    var range = new Array(length);                                                                       // 606\n                                                                                                         // 607\n    while(idx < length) {                                                                                // 608\n      range[idx++] = start;                                                                              // 609\n      start += step;                                                                                     // 610\n    }                                                                                                    // 611\n                                                                                                         // 612\n    return range;                                                                                        // 613\n  };                                                                                                     // 614\n                                                                                                         // 615\n  // Function (ahem) Functions                                                                           // 616\n  // ------------------                                                                                  // 617\n                                                                                                         // 618\n  // Reusable constructor function for prototype setting.                                                // 619\n  var ctor = function(){};                                                                               // 620\n                                                                                                         // 621\n  // Create a function bound to a given object (assigning `this`, and arguments,                         // 622\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                              // 623\n  // available.                                                                                          // 624\n  _.bind = function(func, context) {                                                                     // 625\n    var args, bound;                                                                                     // 626\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;                                                        // 628\n    args = slice.call(arguments, 2);                                                                     // 629\n    return bound = function() {                                                                          // 630\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));      // 631\n      ctor.prototype = func.prototype;                                                                   // 632\n      var self = new ctor;                                                                               // 633\n      ctor.prototype = null;                                                                             // 634\n      var result = func.apply(self, args.concat(slice.call(arguments)));                                 // 635\n      if (Object(result) === result) return result;                                                      // 636\n      return self;                                                                                       // 637\n    };                                                                                                   // 638\n  };                                                                                                     // 639\n                                                                                                         // 640\n  // Partially apply a function by creating a version that has had some of its                           // 641\n  // arguments pre-filled, without changing its dynamic `this` context.                                  // 642\n  _.partial = function(func) {                                                                           // 643\n    var args = slice.call(arguments, 1);                                                                 // 644\n    return function() {                                                                                  // 645\n      return func.apply(this, args.concat(slice.call(arguments)));                                       // 646\n    };                                                                                                   // 647\n  };                                                                                                     // 648\n                                                                                                         // 649\n  // Bind all of an object's methods to that object. Useful for ensuring that                            // 650\n  // all callbacks defined on an object belong to it.                                                    // 651\n  _.bindAll = function(obj) {                                                                            // 652\n    var funcs = slice.call(arguments, 1);                                                                // 653\n    if (funcs.length === 0) throw new Error(\"bindAll must be passed function names\");                    // 654\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });                                          // 655\n    return obj;                                                                                          // 656\n  };                                                                                                     // 657\n                                                                                                         // 658\n  // Memoize an expensive function by storing its results.                                               // 659\n  _.memoize = function(func, hasher) {                                                                   // 660\n    var memo = {};                                                                                       // 661\n    hasher || (hasher = _.identity);                                                                     // 662\n    return function() {                                                                                  // 663\n      var key = hasher.apply(this, arguments);                                                           // 664\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));                   // 665\n    };                                                                                                   // 666\n  };                                                                                                     // 667\n                                                                                                         // 668\n  // Delays a function for the given number of milliseconds, and then calls                              // 669\n  // it with the arguments supplied.                                                                     // 670\n  _.delay = function(func, wait) {                                                                       // 671\n    var args = slice.call(arguments, 2);                                                                 // 672\n    return setTimeout(function(){ return func.apply(null, args); }, wait);                               // 673\n  };                                                                                                     // 674\n                                                                                                         // 675\n  // Defers a function, scheduling it to run after the current call stack has                            // 676\n  // cleared.                                                                                            // 677\n  _.defer = function(func) {                                                                             // 678\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));                                 // 679\n  };                                                                                                     // 680\n                                                                                                         // 681\n  // Returns a function, that, when invoked, will only be triggered at most once                         // 682\n  // during a given window of time. Normally, the throttled function will run                            // 683\n  // as much as it can, without ever going more than once per `wait` duration;                           // 684\n  // but if you'd like to disable the execution on the leading edge, pass                                // 685\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.                               // 686\n  _.throttle = function(func, wait, options) {                                                           // 687\n    var context, args, result;                                                                           // 688\n    var timeout = null;                                                                                  // 689\n    var previous = 0;                                                                                    // 690\n    options || (options = {});                                                                           // 691\n    var later = function() {                                                                             // 692\n      previous = options.leading === false ? 0 : new Date;                                               // 693\n      timeout = null;                                                                                    // 694\n      result = func.apply(context, args);                                                                // 695\n    };                                                                                                   // 696\n    return function() {                                                                                  // 697\n      var now = new Date;                                                                                // 698\n      if (!previous && options.leading === false) previous = now;                                        // 699\n      var remaining = wait - (now - previous);                                                           // 700\n      context = this;                                                                                    // 701\n      args = arguments;                                                                                  // 702\n      if (remaining <= 0) {                                                                              // 703\n        clearTimeout(timeout);                                                                           // 704\n        timeout = null;                                                                                  // 705\n        previous = now;                                                                                  // 706\n        result = func.apply(context, args);                                                              // 707\n      } else if (!timeout && options.trailing !== false) {                                               // 708\n        timeout = setTimeout(later, remaining);                                                          // 709\n      }                                                                                                  // 710\n      return result;                                                                                     // 711\n    };                                                                                                   // 712\n  };                                                                                                     // 713\n                                                                                                         // 714\n  // Returns a function, that, as long as it continues to be invoked, will not                           // 715\n  // be triggered. The function will be called after it stops being called for                           // 716\n  // N milliseconds. If `immediate` is passed, trigger the function on the                               // 717\n  // leading edge, instead of the trailing.                                                              // 718\n  _.debounce = function(func, wait, immediate) {                                                         // 719\n    var timeout, args, context, timestamp, result;                                                       // 720\n    return function() {                                                                                  // 721\n      context = this;                                                                                    // 722\n      args = arguments;                                                                                  // 723\n      timestamp = new Date();                                                                            // 724\n      var later = function() {                                                                           // 725\n        var last = (new Date()) - timestamp;                                                             // 726\n        if (last < wait) {                                                                               // 727\n          timeout = setTimeout(later, wait - last);                                                      // 728\n        } else {                                                                                         // 729\n          timeout = null;                                                                                // 730\n          if (!immediate) result = func.apply(context, args);                                            // 731\n        }                                                                                                // 732\n      };                                                                                                 // 733\n      var callNow = immediate && !timeout;                                                               // 734\n      if (!timeout) {                                                                                    // 735\n        timeout = setTimeout(later, wait);                                                               // 736\n      }                                                                                                  // 737\n      if (callNow) result = func.apply(context, args);                                                   // 738\n      return result;                                                                                     // 739\n    };                                                                                                   // 740\n  };                                                                                                     // 741\n                                                                                                         // 742\n  // Returns a function that will be executed at most one time, no matter how                            // 743\n  // often you call it. Useful for lazy initialization.                                                  // 744\n  _.once = function(func) {                                                                              // 745\n    var ran = false, memo;                                                                               // 746\n    return function() {                                                                                  // 747\n      if (ran) return memo;                                                                              // 748\n      ran = true;                                                                                        // 749\n      memo = func.apply(this, arguments);                                                                // 750\n      func = null;                                                                                       // 751\n      return memo;                                                                                       // 752\n    };                                                                                                   // 753\n  };                                                                                                     // 754\n                                                                                                         // 755\n  // Returns the first function passed as an argument to the second,                                     // 756\n  // allowing you to adjust arguments, run code before and after, and                                    // 757\n  // conditionally execute the original function.                                                        // 758\n  _.wrap = function(func, wrapper) {                                                                     // 759\n    return function() {                                                                                  // 760\n      var args = [func];                                                                                 // 761\n      push.apply(args, arguments);                                                                       // 762\n      return wrapper.apply(this, args);                                                                  // 763\n    };                                                                                                   // 764\n  };                                                                                                     // 765\n                                                                                                         // 766\n  // Returns a function that is the composition of a list of functions, each                             // 767\n  // consuming the return value of the function that follows.                                            // 768\n  _.compose = function() {                                                                               // 769\n    var funcs = arguments;                                                                               // 770\n    return function() {                                                                                  // 771\n      var args = arguments;                                                                              // 772\n      for (var i = funcs.length - 1; i >= 0; i--) {                                                      // 773\n        args = [funcs[i].apply(this, args)];                                                             // 774\n      }                                                                                                  // 775\n      return args[0];                                                                                    // 776\n    };                                                                                                   // 777\n  };                                                                                                     // 778\n                                                                                                         // 779\n  // Returns a function that will only be executed after being called N times.                           // 780\n  _.after = function(times, func) {                                                                      // 781\n    return function() {                                                                                  // 782\n      if (--times < 1) {                                                                                 // 783\n        return func.apply(this, arguments);                                                              // 784\n      }                                                                                                  // 785\n    };                                                                                                   // 786\n  };                                                                                                     // 787\n                                                                                                         // 788\n  // Object Functions                                                                                    // 789\n  // ----------------                                                                                    // 790\n                                                                                                         // 791\n  // Retrieve the names of an object's properties.                                                       // 792\n  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                // 793\n  _.keys = nativeKeys || function(obj) {                                                                 // 794\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');                                      // 795\n    var keys = [];                                                                                       // 796\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                            // 797\n    return keys;                                                                                         // 798\n  };                                                                                                     // 799\n                                                                                                         // 800\n  // Retrieve the values of an object's properties.                                                      // 801\n  _.values = function(obj) {                                                                             // 802\n    var keys = _.keys(obj);                                                                              // 803\n    var length = keys.length;                                                                            // 804\n    var values = new Array(length);                                                                      // 805\n    for (var i = 0; i < length; i++) {                                                                   // 806\n      values[i] = obj[keys[i]];                                                                          // 807\n    }                                                                                                    // 808\n    return values;                                                                                       // 809\n  };                                                                                                     // 810\n                                                                                                         // 811\n  // Convert an object into a list of `[key, value]` pairs.                                              // 812\n  _.pairs = function(obj) {                                                                              // 813\n    var keys = _.keys(obj);                                                                              // 814\n    var length = keys.length;                                                                            // 815\n    var pairs = new Array(length);                                                                       // 816\n    for (var i = 0; i < length; i++) {                                                                   // 817\n      pairs[i] = [keys[i], obj[keys[i]]];                                                                // 818\n    }                                                                                                    // 819\n    return pairs;                                                                                        // 820\n  };                                                                                                     // 821\n                                                                                                         // 822\n  // Invert the keys and values of an object. The values must be serializable.                           // 823\n  _.invert = function(obj) {                                                                             // 824\n    var result = {};                                                                                     // 825\n    var keys = _.keys(obj);                                                                              // 826\n    for (var i = 0, length = keys.length; i < length; i++) {                                             // 827\n      result[obj[keys[i]]] = keys[i];                                                                    // 828\n    }                                                                                                    // 829\n    return result;                                                                                       // 830\n  };                                                                                                     // 831\n                                                                                                         // 832\n  // Return a sorted list of the function names available on the object.                                 // 833\n  // Aliased as `methods`                                                                                // 834\n  _.functions = _.methods = function(obj) {                                                              // 835\n    var names = [];                                                                                      // 836\n    for (var key in obj) {                                                                               // 837\n      if (_.isFunction(obj[key])) names.push(key);                                                       // 838\n    }                                                                                                    // 839\n    return names.sort();                                                                                 // 840\n  };                                                                                                     // 841\n                                                                                                         // 842\n  // Extend a given object with all the properties in passed-in object(s).                               // 843\n  _.extend = function(obj) {                                                                             // 844\n    each(slice.call(arguments, 1), function(source) {                                                    // 845\n      if (source) {                                                                                      // 846\n        for (var prop in source) {                                                                       // 847\n          obj[prop] = source[prop];                                                                      // 848\n        }                                                                                                // 849\n      }                                                                                                  // 850\n    });                                                                                                  // 851\n    return obj;                                                                                          // 852\n  };                                                                                                     // 853\n                                                                                                         // 854\n  // Return a copy of the object only containing the whitelisted properties.                             // 855\n  _.pick = function(obj) {                                                                               // 856\n    var copy = {};                                                                                       // 857\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 858\n    each(keys, function(key) {                                                                           // 859\n      if (key in obj) copy[key] = obj[key];                                                              // 860\n    });                                                                                                  // 861\n    return copy;                                                                                         // 862\n  };                                                                                                     // 863\n                                                                                                         // 864\n   // Return a copy of the object without the blacklisted properties.                                    // 865\n  _.omit = function(obj) {                                                                               // 866\n    var copy = {};                                                                                       // 867\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 868\n    for (var key in obj) {                                                                               // 869\n      if (!_.contains(keys, key)) copy[key] = obj[key];                                                  // 870\n    }                                                                                                    // 871\n    return copy;                                                                                         // 872\n  };                                                                                                     // 873\n                                                                                                         // 874\n  // Fill in a given object with default properties.                                                     // 875\n  _.defaults = function(obj) {                                                                           // 876\n    each(slice.call(arguments, 1), function(source) {                                                    // 877\n      if (source) {                                                                                      // 878\n        for (var prop in source) {                                                                       // 879\n          if (obj[prop] === void 0) obj[prop] = source[prop];                                            // 880\n        }                                                                                                // 881\n      }                                                                                                  // 882\n    });                                                                                                  // 883\n    return obj;                                                                                          // 884\n  };                                                                                                     // 885\n                                                                                                         // 886\n  // Create a (shallow-cloned) duplicate of an object.                                                   // 887\n  _.clone = function(obj) {                                                                              // 888\n    if (!_.isObject(obj)) return obj;                                                                    // 889\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                             // 890\n  };                                                                                                     // 891\n                                                                                                         // 892\n  // Invokes interceptor with the obj, and then returns obj.                                             // 893\n  // The primary purpose of this method is to \"tap into\" a method chain, in                              // 894\n  // order to perform operations on intermediate results within the chain.                               // 895\n  _.tap = function(obj, interceptor) {                                                                   // 896\n    interceptor(obj);                                                                                    // 897\n    return obj;                                                                                          // 898\n  };                                                                                                     // 899\n                                                                                                         // 900\n  // Internal recursive comparison function for `isEqual`.                                               // 901\n  var eq = function(a, b, aStack, bStack) {                                                              // 902\n    // Identical objects are equal. `0 === -0`, but they aren't identical.                               // 903\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).           // 904\n    if (a === b) return a !== 0 || 1 / a == 1 / b;                                                       // 905\n    // A strict comparison is necessary because `null == undefined`.                                     // 906\n    if (a == null || b == null) return a === b;                                                          // 907\n    // Unwrap any wrapped objects.                                                                       // 908\n    if (a instanceof _) a = a._wrapped;                                                                  // 909\n    if (b instanceof _) b = b._wrapped;                                                                  // 910\n    // Compare `[[Class]]` names.                                                                        // 911\n    var className = toString.call(a);                                                                    // 912\n    if (className != toString.call(b)) return false;                                                     // 913\n    switch (className) {                                                                                 // 914\n      // Strings, numbers, dates, and booleans are compared by value.                                    // 915\n      case '[object String]':                                                                            // 916\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is             // 917\n        // equivalent to `new String(\"5\")`.                                                              // 918\n        return a == String(b);                                                                           // 919\n      case '[object Number]':                                                                            // 920\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for               // 921\n        // other numeric values.                                                                         // 922\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);                                  // 923\n      case '[object Date]':                                                                              // 924\n      case '[object Boolean]':                                                                           // 925\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their            // 926\n        // millisecond representations. Note that invalid dates with millisecond representations         // 927\n        // of `NaN` are not equivalent.                                                                  // 928\n        return +a == +b;                                                                                 // 929\n      // RegExps are compared by their source patterns and flags.                                        // 930\n      case '[object RegExp]':                                                                            // 931\n        return a.source == b.source &&                                                                   // 932\n               a.global == b.global &&                                                                   // 933\n               a.multiline == b.multiline &&                                                             // 934\n               a.ignoreCase == b.ignoreCase;                                                             // 935\n    }                                                                                                    // 936\n    if (typeof a != 'object' || typeof b != 'object') return false;                                      // 937\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic                         // 938\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                       // 939\n    var length = aStack.length;                                                                          // 940\n    while (length--) {                                                                                   // 941\n      // Linear search. Performance is inversely proportional to the number of                           // 942\n      // unique nested structures.                                                                       // 943\n      if (aStack[length] == a) return bStack[length] == b;                                               // 944\n    }                                                                                                    // 945\n    // Objects with different constructors are not equivalent, but `Object`s                             // 946\n    // from different frames are.                                                                        // 947\n    var aCtor = a.constructor, bCtor = b.constructor;                                                    // 948\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&                          // 949\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {                         // 950\n      return false;                                                                                      // 951\n    }                                                                                                    // 952\n    // Add the first object to the stack of traversed objects.                                           // 953\n    aStack.push(a);                                                                                      // 954\n    bStack.push(b);                                                                                      // 955\n    var size = 0, result = true;                                                                         // 956\n    // Recursively compare objects and arrays.                                                           // 957\n    if (className == '[object Array]') {                                                                 // 958\n      // Compare array lengths to determine if a deep comparison is necessary.                           // 959\n      size = a.length;                                                                                   // 960\n      result = size == b.length;                                                                         // 961\n      if (result) {                                                                                      // 962\n        // Deep compare the contents, ignoring non-numeric properties.                                   // 963\n        while (size--) {                                                                                 // 964\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;                                   // 965\n        }                                                                                                // 966\n      }                                                                                                  // 967\n    } else {                                                                                             // 968\n      // Deep compare objects.                                                                           // 969\n      for (var key in a) {                                                                               // 970\n        if (_.has(a, key)) {                                                                             // 971\n          // Count the expected number of properties.                                                    // 972\n          size++;                                                                                        // 973\n          // Deep compare each member.                                                                   // 974\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;                    // 975\n        }                                                                                                // 976\n      }                                                                                                  // 977\n      // Ensure that both objects contain the same number of properties.                                 // 978\n      if (result) {                                                                                      // 979\n        for (key in b) {                                                                                 // 980\n          if (_.has(b, key) && !(size--)) break;                                                         // 981\n        }                                                                                                // 982\n        result = !size;                                                                                  // 983\n      }                                                                                                  // 984\n    }                                                                                                    // 985\n    // Remove the first object from the stack of traversed objects.                                      // 986\n    aStack.pop();                                                                                        // 987\n    bStack.pop();                                                                                        // 988\n    return result;                                                                                       // 989\n  };                                                                                                     // 990\n                                                                                                         // 991\n  // Perform a deep comparison to check if two objects are equal.                                        // 992\n  _.isEqual = function(a, b) {                                                                           // 993\n    return eq(a, b, [], []);                                                                             // 994\n  };                                                                                                     // 995\n                                                                                                         // 996\n  // Is a given array, string, or object empty?                                                          // 997\n  // An \"empty\" object has no enumerable own-properties.                                                 // 998\n  _.isEmpty = function(obj) {                                                                            // 999\n    if (obj == null) return true;                                                                        // 1000\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;                                      // 1001\n    for (var key in obj) if (_.has(obj, key)) return false;                                              // 1002\n    return true;                                                                                         // 1003\n  };                                                                                                     // 1004\n                                                                                                         // 1005\n  // Is a given value a DOM element?                                                                     // 1006\n  _.isElement = function(obj) {                                                                          // 1007\n    return !!(obj && obj.nodeType === 1);                                                                // 1008\n  };                                                                                                     // 1009\n                                                                                                         // 1010\n  // Is a given value an array?                                                                          // 1011\n  // Delegates to ECMA5's native Array.isArray                                                           // 1012\n  _.isArray = nativeIsArray || function(obj) {                                                           // 1013\n    return toString.call(obj) == '[object Array]';                                                       // 1014\n  };                                                                                                     // 1015\n                                                                                                         // 1016\n  // Is a given variable an object?                                                                      // 1017\n  _.isObject = function(obj) {                                                                           // 1018\n    return obj === Object(obj);                                                                          // 1019\n  };                                                                                                     // 1020\n                                                                                                         // 1021\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.             // 1022\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {                 // 1023\n    _['is' + name] = function(obj) {                                                                     // 1024\n      return toString.call(obj) == '[object ' + name + ']';                                              // 1025\n    };                                                                                                   // 1026\n  });                                                                                                    // 1027\n                                                                                                         // 1028\n  // Define a fallback version of the method in browsers (ahem, IE), where                               // 1029\n  // there isn't any inspectable \"Arguments\" type.                                                       // 1030\n  if (!_.isArguments(arguments)) {                                                                       // 1031\n    _.isArguments = function(obj) {                                                                      // 1032\n      return !!(obj && _.has(obj, 'callee'));                                                            // 1033\n    };                                                                                                   // 1034\n  }                                                                                                      // 1035\n                                                                                                         // 1036\n  // Optimize `isFunction` if appropriate.                                                               // 1037\n  if (typeof (/./) !== 'function') {                                                                     // 1038\n    _.isFunction = function(obj) {                                                                       // 1039\n      return typeof obj === 'function';                                                                  // 1040\n    };                                                                                                   // 1041\n  }                                                                                                      // 1042\n                                                                                                         // 1043\n  // Is a given object a finite number?                                                                  // 1044\n  _.isFinite = function(obj) {                                                                           // 1045\n    return isFinite(obj) && !isNaN(parseFloat(obj));                                                     // 1046\n  };                                                                                                     // 1047\n                                                                                                         // 1048\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                     // 1049\n  _.isNaN = function(obj) {                                                                              // 1050\n    return _.isNumber(obj) && obj != +obj;                                                               // 1051\n  };                                                                                                     // 1052\n                                                                                                         // 1053\n  // Is a given value a boolean?                                                                         // 1054\n  _.isBoolean = function(obj) {                                                                          // 1055\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';                    // 1056\n  };                                                                                                     // 1057\n                                                                                                         // 1058\n  // Is a given value equal to null?                                                                     // 1059\n  _.isNull = function(obj) {                                                                             // 1060\n    return obj === null;                                                                                 // 1061\n  };                                                                                                     // 1062\n                                                                                                         // 1063\n  // Is a given variable undefined?                                                                      // 1064\n  _.isUndefined = function(obj) {                                                                        // 1065\n    return obj === void 0;                                                                               // 1066\n  };                                                                                                     // 1067\n                                                                                                         // 1068\n  // Shortcut function for checking if an object has a given property directly                           // 1069\n  // on itself (in other words, not on a prototype).                                                     // 1070\n  _.has = function(obj, key) {                                                                           // 1071\n    return hasOwnProperty.call(obj, key);                                                                // 1072\n  };                                                                                                     // 1073\n                                                                                                         // 1074\n  // Utility Functions                                                                                   // 1075\n  // -----------------                                                                                   // 1076\n                                                                                                         // 1077\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                           // 1078\n  // previous owner. Returns a reference to the Underscore object.                                       // 1079\n  _.noConflict = function() {                                                                            // 1080\n    root._ = previousUnderscore;                                                                         // 1081\n    return this;                                                                                         // 1082\n  };                                                                                                     // 1083\n                                                                                                         // 1084\n  // Keep the identity function around for default iterators.                                            // 1085\n  _.identity = function(value) {                                                                         // 1086\n    return value;                                                                                        // 1087\n  };                                                                                                     // 1088\n                                                                                                         // 1089\n  // Run a function **n** times.                                                                         // 1090\n  _.times = function(n, iterator, context) {                                                             // 1091\n    var accum = Array(Math.max(0, n));                                                                   // 1092\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);                                    // 1093\n    return accum;                                                                                        // 1094\n  };                                                                                                     // 1095\n                                                                                                         // 1096\n  // Return a random integer between min and max (inclusive).                                            // 1097\n  _.random = function(min, max) {                                                                        // 1098\n    if (max == null) {                                                                                   // 1099\n      max = min;                                                                                         // 1100\n      min = 0;                                                                                           // 1101\n    }                                                                                                    // 1102\n    return min + Math.floor(Math.random() * (max - min + 1));                                            // 1103\n  };                                                                                                     // 1104\n                                                                                                         // 1105\n  // List of HTML entities for escaping.                                                                 // 1106\n  var entityMap = {                                                                                      // 1107\n    escape: {                                                                                            // 1108\n      '&': '&amp;',                                                                                      // 1109\n      '<': '&lt;',                                                                                       // 1110\n      '>': '&gt;',                                                                                       // 1111\n      '\"': '&quot;',                                                                                     // 1112\n      \"'\": '&#x27;'                                                                                      // 1113\n    }                                                                                                    // 1114\n  };                                                                                                     // 1115\n  entityMap.unescape = _.invert(entityMap.escape);                                                       // 1116\n                                                                                                         // 1117\n  // Regexes containing the keys and values listed immediately above.                                    // 1118\n  var entityRegexes = {                                                                                  // 1119\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),                            // 1120\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')                          // 1121\n  };                                                                                                     // 1122\n                                                                                                         // 1123\n  // Functions for escaping and unescaping strings to/from HTML interpolation.                           // 1124\n  _.each(['escape', 'unescape'], function(method) {                                                      // 1125\n    _[method] = function(string) {                                                                       // 1126\n      if (string == null) return '';                                                                     // 1127\n      return ('' + string).replace(entityRegexes[method], function(match) {                              // 1128\n        return entityMap[method][match];                                                                 // 1129\n      });                                                                                                // 1130\n    };                                                                                                   // 1131\n  });                                                                                                    // 1132\n                                                                                                         // 1133\n  // If the value of the named `property` is a function then invoke it with the                          // 1134\n  // `object` as context; otherwise, return it.                                                          // 1135\n  _.result = function(object, property) {                                                                // 1136\n    if (object == null) return void 0;                                                                   // 1137\n    var value = object[property];                                                                        // 1138\n    return _.isFunction(value) ? value.call(object) : value;                                             // 1139\n  };                                                                                                     // 1140\n                                                                                                         // 1141\n  // Add your own custom functions to the Underscore object.                                             // 1142\n  _.mixin = function(obj) {                                                                              // 1143\n    each(_.functions(obj), function(name) {                                                              // 1144\n      var func = _[name] = obj[name];                                                                    // 1145\n      _.prototype[name] = function() {                                                                   // 1146\n        var args = [this._wrapped];                                                                      // 1147\n        push.apply(args, arguments);                                                                     // 1148\n        return result.call(this, func.apply(_, args));                                                   // 1149\n      };                                                                                                 // 1150\n    });                                                                                                  // 1151\n  };                                                                                                     // 1152\n                                                                                                         // 1153\n  // Generate a unique integer id (unique within the entire client session).                             // 1154\n  // Useful for temporary DOM ids.                                                                       // 1155\n  var idCounter = 0;                                                                                     // 1156\n  _.uniqueId = function(prefix) {                                                                        // 1157\n    var id = ++idCounter + '';                                                                           // 1158\n    return prefix ? prefix + id : id;                                                                    // 1159\n  };                                                                                                     // 1160\n                                                                                                         // 1161\n  // By default, Underscore uses ERB-style template delimiters, change the                               // 1162\n  // following template settings to use alternative delimiters.                                          // 1163\n  _.templateSettings = {                                                                                 // 1164\n    evaluate    : /<%([\\s\\S]+?)%>/g,                                                                     // 1165\n    interpolate : /<%=([\\s\\S]+?)%>/g,                                                                    // 1166\n    escape      : /<%-([\\s\\S]+?)%>/g                                                                     // 1167\n  };                                                                                                     // 1168\n                                                                                                         // 1169\n  // When customizing `templateSettings`, if you don't want to define an                                 // 1170\n  // interpolation, evaluation or escaping regex, we need one that is                                    // 1171\n  // guaranteed not to match.                                                                            // 1172\n  var noMatch = /(.)^/;                                                                                  // 1173\n                                                                                                         // 1174\n  // Certain characters need to be escaped so that they can be put into a                                // 1175\n  // string literal.                                                                                     // 1176\n  var escapes = {                                                                                        // 1177\n    \"'\":      \"'\",                                                                                       // 1178\n    '\\\\':     '\\\\',                                                                                      // 1179\n    '\\r':     'r',                                                                                       // 1180\n    '\\n':     'n',                                                                                       // 1181\n    '\\t':     't',                                                                                       // 1182\n    '\\u2028': 'u2028',                                                                                   // 1183\n    '\\u2029': 'u2029'                                                                                    // 1184\n  };                                                                                                     // 1185\n                                                                                                         // 1186\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;                                                          // 1187\n                                                                                                         // 1188\n  // JavaScript micro-templating, similar to John Resig's implementation.                                // 1189\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,                           // 1190\n  // and correctly escapes quotes within interpolated code.                                              // 1191\n  _.template = function(text, data, settings) {                                                          // 1192\n    var render;                                                                                          // 1193\n    settings = _.defaults({}, settings, _.templateSettings);                                             // 1194\n                                                                                                         // 1195\n    // Combine delimiters into one regular expression via alternation.                                   // 1196\n    var matcher = new RegExp([                                                                           // 1197\n      (settings.escape || noMatch).source,                                                               // 1198\n      (settings.interpolate || noMatch).source,                                                          // 1199\n      (settings.evaluate || noMatch).source                                                              // 1200\n    ].join('|') + '|$', 'g');                                                                            // 1201\n                                                                                                         // 1202\n    // Compile the template source, escaping string literals appropriately.                              // 1203\n    var index = 0;                                                                                       // 1204\n    var source = \"__p+='\";                                                                               // 1205\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                       // 1206\n      source += text.slice(index, offset)                                                                // 1207\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });                            // 1208\n                                                                                                         // 1209\n      if (escape) {                                                                                      // 1210\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";                             // 1211\n      }                                                                                                  // 1212\n      if (interpolate) {                                                                                 // 1213\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";                                  // 1214\n      }                                                                                                  // 1215\n      if (evaluate) {                                                                                    // 1216\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";                                                        // 1217\n      }                                                                                                  // 1218\n      index = offset + match.length;                                                                     // 1219\n      return match;                                                                                      // 1220\n    });                                                                                                  // 1221\n    source += \"';\\n\";                                                                                    // 1222\n                                                                                                         // 1223\n    // If a variable is not specified, place data values in local scope.                                 // 1224\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';                                // 1225\n                                                                                                         // 1226\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +                                                // 1227\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +                                              // 1228\n      source + \"return __p;\\n\";                                                                          // 1229\n                                                                                                         // 1230\n    try {                                                                                                // 1231\n      render = new Function(settings.variable || 'obj', '_', source);                                    // 1232\n    } catch (e) {                                                                                        // 1233\n      e.source = source;                                                                                 // 1234\n      throw e;                                                                                           // 1235\n    }                                                                                                    // 1236\n                                                                                                         // 1237\n    if (data) return render(data, _);                                                                    // 1238\n    var template = function(data) {                                                                      // 1239\n      return render.call(this, data, _);                                                                 // 1240\n    };                                                                                                   // 1241\n                                                                                                         // 1242\n    // Provide the compiled function source as a convenience for precompilation.                         // 1243\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';                // 1244\n                                                                                                         // 1245\n    return template;                                                                                     // 1246\n  };                                                                                                     // 1247\n                                                                                                         // 1248\n  // Add a \"chain\" function, which will delegate to the wrapper.                                         // 1249\n  _.chain = function(obj) {                                                                              // 1250\n    return _(obj).chain();                                                                               // 1251\n  };                                                                                                     // 1252\n                                                                                                         // 1253\n  // OOP                                                                                                 // 1254\n  // ---------------                                                                                     // 1255\n  // If Underscore is called as a function, it returns a wrapped object that                             // 1256\n  // can be used OO-style. This wrapper holds altered versions of all the                                // 1257\n  // underscore functions. Wrapped objects may be chained.                                               // 1258\n                                                                                                         // 1259\n  // Helper function to continue chaining intermediate results.                                          // 1260\n  var result = function(obj) {                                                                           // 1261\n    return this._chain ? _(obj).chain() : obj;                                                           // 1262\n  };                                                                                                     // 1263\n                                                                                                         // 1264\n  // Add all of the Underscore functions to the wrapper object.                                          // 1265\n  _.mixin(_);                                                                                            // 1266\n                                                                                                         // 1267\n  // Add all mutator Array functions to the wrapper.                                                     // 1268\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                // 1269\n    var method = ArrayProto[name];                                                                       // 1270\n    _.prototype[name] = function() {                                                                     // 1271\n      var obj = this._wrapped;                                                                           // 1272\n      method.apply(obj, arguments);                                                                      // 1273\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];                      // 1274\n      return result.call(this, obj);                                                                     // 1275\n    };                                                                                                   // 1276\n  });                                                                                                    // 1277\n                                                                                                         // 1278\n  // Add all accessor Array functions to the wrapper.                                                    // 1279\n  each(['concat', 'join', 'slice'], function(name) {                                                     // 1280\n    var method = ArrayProto[name];                                                                       // 1281\n    _.prototype[name] = function() {                                                                     // 1282\n      return result.call(this, method.apply(this._wrapped, arguments));                                  // 1283\n    };                                                                                                   // 1284\n  });                                                                                                    // 1285\n                                                                                                         // 1286\n  _.extend(_.prototype, {                                                                                // 1287\n                                                                                                         // 1288\n    // Start chaining a wrapped Underscore object.                                                       // 1289\n    chain: function() {                                                                                  // 1290\n      this._chain = true;                                                                                // 1291\n      return this;                                                                                       // 1292\n    },                                                                                                   // 1293\n                                                                                                         // 1294\n    // Extracts the result from a wrapped and chained object.                                            // 1295\n    value: function() {                                                                                  // 1296\n      return this._wrapped;                                                                              // 1297\n    }                                                                                                    // 1298\n                                                                                                         // 1299\n  });                                                                                                    // 1300\n                                                                                                         // 1301\n}).call(this);                                                                                           // 1302\n                                                                                                         // 1303\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                       //\n// packages/underscore/post.js                                                                           //\n//                                                                                                       //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                         //\n// This exports object was created in pre.js.  Now copy the `_` object from it                           // 1\n// into the package-scope variable `_`, which will get exported.                                         // 2\n_ = exports._;                                                                                           // 3\n                                                                                                         // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.underscore = {\n  _: _\n};\n\n})();\n","servePath":"/packages/underscore.js","sourceMap":{"version":3,"sources":["/packages/underscore/pre.js","/packages/underscore/underscore.js","/packages/underscore/post.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,6G;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH;;;;;;;;;;;;;;;;;;ACtxCA;AACA;AACA;AACA,6G","file":"/packages/underscore.js","sourcesContent":["// Define an object named exports. This will cause underscore.js to put `_` as a\n// field on it, instead of in the global namespace.  See also post.js.\nexports = {};\n","//     Underscore.js 1.5.2\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.5.2';\n\n  // Collection Functions\n  // --------------------\n\n  // METEOR CHANGE: Define _isArguments instead of depending on\n  // _.isArguments which is defined using each. In looksLikeArray\n  // (which each depends on), we then use _isArguments instead of\n  // _.isArguments.\n  var _isArguments = function (obj) {\n    return toString.call(obj) === '[object Arguments]';\n  };\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_isArguments(arguments)) {\n    _isArguments = function (obj) {\n      return !!(obj && hasOwnProperty.call(obj, 'callee') && typeof obj.callee === 'function');\n    };\n  }\n\n  // METEOR CHANGE: _.each({length: 5}) should be treated like an object, not an\n  // array. This looksLikeArray function is introduced by Meteor, and replaces\n  // all instances of `obj.length === +obj.length`.\n  // https://github.com/meteor/meteor/issues/594\n  // https://github.com/jashkenas/underscore/issues/770\n  var looksLikeArray = function (obj) {\n    return (obj.length === +obj.length\n            // _.isArguments not yet necessarily defined here\n            && (_isArguments(obj) || obj.constructor !== Object));\n  };\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (looksLikeArray(obj)) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (!looksLikeArray(obj)) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? void 0 : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed > result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array, using the modern version of the \n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from an array.\n  // If **n** is not specified, returns a single random element from the array.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (arguments.length < 2 || guard) {\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, value, context) {\n      var result = {};\n      var iterator = value == null ? _.identity : lookupIterator(value);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (looksLikeArray(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (looksLikeArray(obj)) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n == null) || guard ? array[0] : slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) {\n      return array[array.length - 1];\n    } else {\n      return slice.call(array, Math.max(array.length - n, 0));\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, \"length\").concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error(\"bindAll must be passed function names\");\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = new Date();\n      var later = function() {\n        var last = (new Date()) - timestamp;\n        if (last < wait) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) result = func.apply(context, args);\n        }\n      };\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","// This exports object was created in pre.js.  Now copy the `_` object from it\n// into the package-scope variable `_`, which will get exported.\n_ = exports._;\n"]}}]