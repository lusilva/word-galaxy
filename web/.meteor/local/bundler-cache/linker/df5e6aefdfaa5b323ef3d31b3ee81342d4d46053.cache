[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Autoupdate, ClientVersions;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/autoupdate/autoupdate_server.js                                     //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\n// Publish the current client versions to the client.  When a client            // 1\n// sees the subscription change and that there is a new version of the          // 2\n// client available on the server, it can reload.                               // 3\n//                                                                              // 4\n// By default there are two current client versions. The refreshable client     // 5\n// version is identified by a hash of the client resources seen by the browser  // 6\n// that are refreshable, such as CSS, while the non refreshable client version  // 7\n// is identified by a hash of the rest of the client assets                     // 8\n// (the HTML, code, and static files in the `public` directory).                // 9\n//                                                                              // 10\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be           // 11\n// used as the client id instead.  You can use this to control when             // 12\n// the client reloads.  For example, if you want to only force a                // 13\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION             // 14\n// which you only change when something worth pushing to clients                // 15\n// immediately happens.                                                         // 16\n//                                                                              // 17\n// The server publishes a `meteor_autoupdate_clientVersions`                    // 18\n// collection. There are two documents in this collection, a document           // 19\n// with _id 'version' which represents the non refreshable client assets,       // 20\n// and a document with _id 'version-refreshable' which represents the           // 21\n// refreshable client assets. Each document has a 'version' field               // 22\n// which is equivalent to the hash of the relevant assets. The refreshable      // 23\n// document also contains a list of the refreshable assets, so that the client  // 24\n// can swap in the new assets without forcing a page refresh. Clients can       // 25\n// observe changes on these documents to detect when there is a new             // 26\n// version available.                                                           // 27\n//                                                                              // 28\n// In this implementation only two documents are present in the collection      // 29\n// the current refreshable client version and the current nonRefreshable client\n// version.  Developers can easily experiment with different versioning and     // 31\n// updating models by forking this package.                                     // 32\n                                                                                // 33\nvar Future = Npm.require(\"fibers/future\");                                      // 34\n                                                                                // 35\nAutoupdate = {};                                                                // 36\n                                                                                // 37\n// The collection of acceptable client versions.                                // 38\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\",       // 39\n  { connection: null });                                                        // 40\n                                                                                // 41\n// The client hash includes __meteor_runtime_config__, so wait until            // 42\n// all packages have loaded and have had a chance to populate the               // 43\n// runtime config before using the client hash as our default auto              // 44\n// update version id.                                                           // 45\n                                                                                // 46\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before     // 47\n// startup.                                                                     // 48\nAutoupdate.autoupdateVersion = null;                                            // 49\nAutoupdate.autoupdateVersionRefreshable = null;                                 // 50\nAutoupdate.autoupdateVersionCordova = null;                                     // 51\nAutoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;        // 52\n                                                                                // 53\nvar syncQueue = new Meteor._SynchronousQueue();                                 // 54\n                                                                                // 55\n// updateVersions can only be called after the server has fully loaded.         // 56\nvar updateVersions = function (shouldReloadClientProgram) {                     // 57\n  // Step 1: load the current client program on the server and update the       // 58\n  // hash values in __meteor_runtime_config__.                                  // 59\n  if (shouldReloadClientProgram) {                                              // 60\n    WebAppInternals.reloadClientPrograms();                                     // 61\n  }                                                                             // 62\n                                                                                // 63\n  // If we just re-read the client program, or if we don't have an autoupdate   // 64\n  // version, calculate it.                                                     // 65\n  if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {     // 66\n    Autoupdate.autoupdateVersion =                                              // 67\n      process.env.AUTOUPDATE_VERSION ||                                         // 68\n      WebApp.calculateClientHashNonRefreshable();                               // 69\n  }                                                                             // 70\n  // If we just recalculated it OR if it was set by (eg) test-in-browser,       // 71\n  // ensure it ends up in __meteor_runtime_config__.                            // 72\n  __meteor_runtime_config__.autoupdateVersion =                                 // 73\n    Autoupdate.autoupdateVersion;                                               // 74\n                                                                                // 75\n  Autoupdate.autoupdateVersionRefreshable =                                     // 76\n    __meteor_runtime_config__.autoupdateVersionRefreshable =                    // 77\n      process.env.AUTOUPDATE_VERSION ||                                         // 78\n      WebApp.calculateClientHashRefreshable();                                  // 79\n                                                                                // 80\n  Autoupdate.autoupdateVersionCordova =                                         // 81\n    __meteor_runtime_config__.autoupdateVersionCordova =                        // 82\n      process.env.AUTOUPDATE_VERSION ||                                         // 83\n      WebApp.calculateClientHashCordova();                                      // 84\n                                                                                // 85\n  // Step 2: form the new client boilerplate which contains the updated         // 86\n  // assets and __meteor_runtime_config__.                                      // 87\n  if (shouldReloadClientProgram) {                                              // 88\n    WebAppInternals.generateBoilerplate();                                      // 89\n  }                                                                             // 90\n                                                                                // 91\n  // XXX COMPAT WITH 0.8.3                                                      // 92\n  if (! ClientVersions.findOne({current: true})) {                              // 93\n    // To ensure apps with version of Meteor prior to 0.9.0 (in                 // 94\n    // which the structure of documents in `ClientVersions` was                 // 95\n    // different) also reload.                                                  // 96\n    ClientVersions.insert({current: true});                                     // 97\n  }                                                                             // 98\n                                                                                // 99\n  if (! ClientVersions.findOne({_id: \"version\"})) {                             // 100\n    ClientVersions.insert({                                                     // 101\n      _id: \"version\",                                                           // 102\n      version: Autoupdate.autoupdateVersion                                     // 103\n    });                                                                         // 104\n  } else {                                                                      // 105\n    ClientVersions.update(\"version\", { $set: {                                  // 106\n      version: Autoupdate.autoupdateVersion                                     // 107\n    }});                                                                        // 108\n  }                                                                             // 109\n                                                                                // 110\n  if (! ClientVersions.findOne({_id: \"version-cordova\"})) {                     // 111\n    ClientVersions.insert({                                                     // 112\n      _id: \"version-cordova\",                                                   // 113\n      version: Autoupdate.autoupdateVersionCordova,                             // 114\n      refreshable: false                                                        // 115\n    });                                                                         // 116\n  } else {                                                                      // 117\n    ClientVersions.update(\"version-cordova\", { $set: {                          // 118\n      version: Autoupdate.autoupdateVersionCordova                              // 119\n    }});                                                                        // 120\n  }                                                                             // 121\n                                                                                // 122\n  // Use `onListening` here because we need to use                              // 123\n  // `WebAppInternals.refreshableAssets`, which is only set after               // 124\n  // `WebApp.generateBoilerplate` is called by `main` in webapp.                // 125\n  WebApp.onListening(function () {                                              // 126\n    if (! ClientVersions.findOne({_id: \"version-refreshable\"})) {               // 127\n      ClientVersions.insert({                                                   // 128\n        _id: \"version-refreshable\",                                             // 129\n        version: Autoupdate.autoupdateVersionRefreshable,                       // 130\n        assets: WebAppInternals.refreshableAssets                               // 131\n      });                                                                       // 132\n    } else {                                                                    // 133\n      ClientVersions.update(\"version-refreshable\", { $set: {                    // 134\n        version: Autoupdate.autoupdateVersionRefreshable,                       // 135\n        assets: WebAppInternals.refreshableAssets                               // 136\n      }});                                                                      // 137\n    }                                                                           // 138\n  });                                                                           // 139\n};                                                                              // 140\n                                                                                // 141\nMeteor.publish(                                                                 // 142\n  \"meteor_autoupdate_clientVersions\",                                           // 143\n  function (appId) {                                                            // 144\n    // `null` happens when a client doesn't have an appId and passes            // 145\n    // `undefined` to `Meteor.subscribe`. `undefined` is translated to          // 146\n    // `null` as JSON doesn't have `undefined.                                  // 147\n    check(appId, Match.OneOf(String, undefined, null));                         // 148\n                                                                                // 149\n    // Don't notify clients using wrong appId such as mobile apps built with a  // 150\n    // different server but pointing at the same local url                      // 151\n    if (Autoupdate.appId && appId && Autoupdate.appId !== appId)                // 152\n      return [];                                                                // 153\n                                                                                // 154\n    return ClientVersions.find();                                               // 155\n  },                                                                            // 156\n  {is_auto: true}                                                               // 157\n);                                                                              // 158\n                                                                                // 159\nMeteor.startup(function () {                                                    // 160\n  updateVersions(false);                                                        // 161\n});                                                                             // 162\n                                                                                // 163\nvar fut = new Future();                                                         // 164\n                                                                                // 165\n// We only want 'refresh' to trigger 'updateVersions' AFTER onListen,           // 166\n// so we add a queued task that waits for onListen before 'refresh' can queue   // 167\n// tasks. Note that the `onListening` callbacks do not fire until after         // 168\n// Meteor.startup, so there is no concern that the 'updateVersions' calls from  // 169\n// 'refresh' will overlap with the `updateVersions` call from Meteor.startup.   // 170\n                                                                                // 171\nsyncQueue.queueTask(function () {                                               // 172\n  fut.wait();                                                                   // 173\n});                                                                             // 174\n                                                                                // 175\nWebApp.onListening(function () {                                                // 176\n  fut.return();                                                                 // 177\n});                                                                             // 178\n                                                                                // 179\nvar enqueueVersionsRefresh = function () {                                      // 180\n  syncQueue.queueTask(function () {                                             // 181\n    updateVersions(true);                                                       // 182\n  });                                                                           // 183\n};                                                                              // 184\n                                                                                // 185\n// Listen for the special {refresh: 'client'} message, which signals that a     // 186\n// client asset has changed.                                                    // 187\nprocess.on('message', Meteor.bindEnvironment(function (m) {                     // 188\n  if (m && m.refresh === 'client') {                                            // 189\n    enqueueVersionsRefresh();                                                   // 190\n  }                                                                             // 191\n}, \"handling client refresh message\"));                                         // 192\n                                                                                // 193\n// Another way to tell the process to refresh: send SIGHUP signal               // 194\nprocess.on('SIGHUP', Meteor.bindEnvironment(function () {                       // 195\n  enqueueVersionsRefresh();                                                     // 196\n}, \"handling SIGHUP signal for refresh\"));                                      // 197\n                                                                                // 198\n                                                                                // 199\n//////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.autoupdate = {\n  Autoupdate: Autoupdate\n};\n\n})();\n","servePath":"/packages/autoupdate.js","sourceMap":{"version":3,"sources":["/packages/autoupdate/autoupdate_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sF","file":"/packages/autoupdate.js","sourcesContent":["// Publish the current client versions to the client.  When a client\n// sees the subscription change and that there is a new version of the\n// client available on the server, it can reload.\n//\n// By default there are two current client versions. The refreshable client\n// version is identified by a hash of the client resources seen by the browser\n// that are refreshable, such as CSS, while the non refreshable client version\n// is identified by a hash of the rest of the client assets\n// (the HTML, code, and static files in the `public` directory).\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be\n// used as the client id instead.  You can use this to control when\n// the client reloads.  For example, if you want to only force a\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION\n// which you only change when something worth pushing to clients\n// immediately happens.\n//\n// The server publishes a `meteor_autoupdate_clientVersions`\n// collection. There are two documents in this collection, a document\n// with _id 'version' which represents the non refreshable client assets,\n// and a document with _id 'version-refreshable' which represents the\n// refreshable client assets. Each document has a 'version' field\n// which is equivalent to the hash of the relevant assets. The refreshable\n// document also contains a list of the refreshable assets, so that the client\n// can swap in the new assets without forcing a page refresh. Clients can\n// observe changes on these documents to detect when there is a new\n// version available.\n//\n// In this implementation only two documents are present in the collection\n// the current refreshable client version and the current nonRefreshable client\n// version.  Developers can easily experiment with different versioning and\n// updating models by forking this package.\n\nvar Future = Npm.require(\"fibers/future\");\n\nAutoupdate = {};\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\",\n  { connection: null });\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before\n// startup.\nAutoupdate.autoupdateVersion = null;\nAutoupdate.autoupdateVersionRefreshable = null;\nAutoupdate.autoupdateVersionCordova = null;\nAutoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;\n\nvar syncQueue = new Meteor._SynchronousQueue();\n\n// updateVersions can only be called after the server has fully loaded.\nvar updateVersions = function (shouldReloadClientProgram) {\n  // Step 1: load the current client program on the server and update the\n  // hash values in __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.reloadClientPrograms();\n  }\n\n  // If we just re-read the client program, or if we don't have an autoupdate\n  // version, calculate it.\n  if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {\n    Autoupdate.autoupdateVersion =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashNonRefreshable();\n  }\n  // If we just recalculated it OR if it was set by (eg) test-in-browser,\n  // ensure it ends up in __meteor_runtime_config__.\n  __meteor_runtime_config__.autoupdateVersion =\n    Autoupdate.autoupdateVersion;\n\n  Autoupdate.autoupdateVersionRefreshable =\n    __meteor_runtime_config__.autoupdateVersionRefreshable =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashRefreshable();\n\n  Autoupdate.autoupdateVersionCordova =\n    __meteor_runtime_config__.autoupdateVersionCordova =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashCordova();\n\n  // Step 2: form the new client boilerplate which contains the updated\n  // assets and __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.generateBoilerplate();\n  }\n\n  // XXX COMPAT WITH 0.8.3\n  if (! ClientVersions.findOne({current: true})) {\n    // To ensure apps with version of Meteor prior to 0.9.0 (in\n    // which the structure of documents in `ClientVersions` was\n    // different) also reload.\n    ClientVersions.insert({current: true});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version\"})) {\n    ClientVersions.insert({\n      _id: \"version\",\n      version: Autoupdate.autoupdateVersion\n    });\n  } else {\n    ClientVersions.update(\"version\", { $set: {\n      version: Autoupdate.autoupdateVersion\n    }});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version-cordova\"})) {\n    ClientVersions.insert({\n      _id: \"version-cordova\",\n      version: Autoupdate.autoupdateVersionCordova,\n      refreshable: false\n    });\n  } else {\n    ClientVersions.update(\"version-cordova\", { $set: {\n      version: Autoupdate.autoupdateVersionCordova\n    }});\n  }\n\n  // Use `onListening` here because we need to use\n  // `WebAppInternals.refreshableAssets`, which is only set after\n  // `WebApp.generateBoilerplate` is called by `main` in webapp.\n  WebApp.onListening(function () {\n    if (! ClientVersions.findOne({_id: \"version-refreshable\"})) {\n      ClientVersions.insert({\n        _id: \"version-refreshable\",\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      });\n    } else {\n      ClientVersions.update(\"version-refreshable\", { $set: {\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      }});\n    }\n  });\n};\n\nMeteor.publish(\n  \"meteor_autoupdate_clientVersions\",\n  function (appId) {\n    // `null` happens when a client doesn't have an appId and passes\n    // `undefined` to `Meteor.subscribe`. `undefined` is translated to\n    // `null` as JSON doesn't have `undefined.\n    check(appId, Match.OneOf(String, undefined, null));\n\n    // Don't notify clients using wrong appId such as mobile apps built with a\n    // different server but pointing at the same local url\n    if (Autoupdate.appId && appId && Autoupdate.appId !== appId)\n      return [];\n\n    return ClientVersions.find();\n  },\n  {is_auto: true}\n);\n\nMeteor.startup(function () {\n  updateVersions(false);\n});\n\nvar fut = new Future();\n\n// We only want 'refresh' to trigger 'updateVersions' AFTER onListen,\n// so we add a queued task that waits for onListen before 'refresh' can queue\n// tasks. Note that the `onListening` callbacks do not fire until after\n// Meteor.startup, so there is no concern that the 'updateVersions' calls from\n// 'refresh' will overlap with the `updateVersions` call from Meteor.startup.\n\nsyncQueue.queueTask(function () {\n  fut.wait();\n});\n\nWebApp.onListening(function () {\n  fut.return();\n});\n\nvar enqueueVersionsRefresh = function () {\n  syncQueue.queueTask(function () {\n    updateVersions(true);\n  });\n};\n\n// Listen for the special {refresh: 'client'} message, which signals that a\n// client asset has changed.\nprocess.on('message', Meteor.bindEnvironment(function (m) {\n  if (m && m.refresh === 'client') {\n    enqueueVersionsRefresh();\n  }\n}, \"handling client refresh message\"));\n\n// Another way to tell the process to refresh: send SIGHUP signal\nprocess.on('SIGHUP', Meteor.bindEnvironment(function () {\n  enqueueVersionsRefresh();\n}, \"handling SIGHUP signal for refresh\"));\n\n"]}}]