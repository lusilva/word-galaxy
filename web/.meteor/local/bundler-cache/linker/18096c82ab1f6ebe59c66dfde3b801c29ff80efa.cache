[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar HTML = Package.htmljs.HTML;\nvar HTMLTools = Package['html-tools'].HTMLTools;\nvar BlazeTools = Package['blaze-tools'].BlazeTools;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar SpacebarsCompiler, TemplateTag, ReactComponentSiblingForbidder;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/templatetag.js                                                          //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\nSpacebarsCompiler = {};                                                                                // 1\n                                                                                                       // 2\n// A TemplateTag is the result of parsing a single `{{...}}` tag.                                      // 3\n//                                                                                                     // 4\n// The `.type` of a TemplateTag is one of:                                                             // 5\n//                                                                                                     // 6\n// - `\"DOUBLE\"` - `{{foo}}`                                                                            // 7\n// - `\"TRIPLE\"` - `{{{foo}}}`                                                                          // 8\n// - `\"EXPR\"` - `(foo)`                                                                                // 9\n// - `\"COMMENT\"` - `{{! foo}}`                                                                         // 10\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`                                                                 // 11\n// - `\"INCLUSION\"` - `{{> foo}}`                                                                       // 12\n// - `\"BLOCKOPEN\"` - `{{#foo}}`                                                                        // 13\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`                                                                       // 14\n// - `\"ELSE\"` - `{{else}}`                                                                             // 15\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on                                                     // 16\n//                                                                                                     // 17\n// Besides `type`, the mandatory properties of a TemplateTag are:                                      // 18\n//                                                                                                     // 19\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`                              // 20\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,                            // 21\n//   and BLOCKCLOSE.                                                                                   // 22\n//                                                                                                     // 23\n// - `args` - An array of zero or more argument specs.  An argument spec                               // 24\n//   is a two or three element array, consisting of a type, value, and                                 // 25\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`                            // 26\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,                                // 27\n//   TRIPLE, INCLUSION, and BLOCKOPEN.                                                                 // 28\n//                                                                                                     // 29\n// - `value` - A string of the comment's text. Applies to COMMENT and                                  // 30\n//   BLOCKCOMMENT.                                                                                     // 31\n//                                                                                                     // 32\n// These additional are typically set during parsing:                                                  // 33\n//                                                                                                     // 34\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort                          // 35\n//   of site the TemplateTag was encountered (e.g. at element level or as                              // 36\n//   part of an attribute value). Its absence implies                                                  // 37\n//   TEMPLATE_TAG_POSITION.ELEMENT.                                                                    // 38\n//                                                                                                     // 39\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are                                 // 40\n//   parsed, they are put here.  `elseContent` will only be present if                                 // 41\n//   an `{{else}}` was found.                                                                          // 42\n                                                                                                       // 43\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;                                           // 44\n                                                                                                       // 45\nTemplateTag = SpacebarsCompiler.TemplateTag = function () {                                            // 46\n  HTMLTools.TemplateTag.apply(this, arguments);                                                        // 47\n};                                                                                                     // 48\nTemplateTag.prototype = new HTMLTools.TemplateTag;                                                     // 49\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';                               // 50\n                                                                                                       // 51\nvar makeStacheTagStartRegex = function (r) {                                                           // 52\n  return new RegExp(r.source + /(?![{>!#/])/.source,                                                   // 53\n                    r.ignoreCase ? 'i' : '');                                                          // 54\n};                                                                                                     // 55\n                                                                                                       // 56\n// \"starts\" regexes are used to see what type of template                                              // 57\n// tag the parser is looking at.  They must match a non-empty                                          // 58\n// result, but not the interesting part of the tag.                                                    // 59\nvar starts = {                                                                                         // 60\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,                                                                            // 61\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),                                             // 62\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),                                                   // 63\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),                                                 // 64\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),                                                // 65\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),                                                       // 66\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),                                            // 67\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),                                            // 68\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)                                           // 69\n};                                                                                                     // 70\n                                                                                                       // 71\nvar ends = {                                                                                           // 72\n  DOUBLE: /^\\s*\\}\\}/,                                                                                  // 73\n  TRIPLE: /^\\s*\\}\\}\\}/,                                                                                // 74\n  EXPR: /^\\s*\\)/                                                                                       // 75\n};                                                                                                     // 76\n                                                                                                       // 77\nvar endsString = {                                                                                     // 78\n  DOUBLE: '}}',                                                                                        // 79\n  TRIPLE: '}}}',                                                                                       // 80\n  EXPR: ')'                                                                                            // 81\n};                                                                                                     // 82\n                                                                                                       // 83\n// Parse a tag from the provided scanner or string.  If the input                                      // 84\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds                                  // 85\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using                              // 86\n// `scanner.fatal` if a scanner is provided).                                                          // 87\nTemplateTag.parse = function (scannerOrString) {                                                       // 88\n  var scanner = scannerOrString;                                                                       // 89\n  if (typeof scanner === 'string')                                                                     // 90\n    scanner = new HTMLTools.Scanner(scannerOrString);                                                  // 91\n                                                                                                       // 92\n  if (! (scanner.peek() === '{' &&                                                                     // 93\n         (scanner.rest()).slice(0, 2) === '{{'))                                                       // 94\n    return null;                                                                                       // 95\n                                                                                                       // 96\n  var run = function (regex) {                                                                         // 97\n    // regex is assumed to start with `^`                                                              // 98\n    var result = regex.exec(scanner.rest());                                                           // 99\n    if (! result)                                                                                      // 100\n      return null;                                                                                     // 101\n    var ret = result[0];                                                                               // 102\n    scanner.pos += ret.length;                                                                         // 103\n    return ret;                                                                                        // 104\n  };                                                                                                   // 105\n                                                                                                       // 106\n  var advance = function (amount) {                                                                    // 107\n    scanner.pos += amount;                                                                             // 108\n  };                                                                                                   // 109\n                                                                                                       // 110\n  var scanIdentifier = function (isFirstInPath) {                                                      // 111\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);                                          // 112\n    if (! id) {                                                                                        // 113\n      expected('IDENTIFIER');                                                                          // 114\n    }                                                                                                  // 115\n    if (isFirstInPath &&                                                                               // 116\n        (id === 'null' || id === 'true' || id === 'false'))                                            // 117\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");              // 118\n                                                                                                       // 119\n    return id;                                                                                         // 120\n  };                                                                                                   // 121\n                                                                                                       // 122\n  var scanPath = function () {                                                                         // 123\n    var segments = [];                                                                                 // 124\n                                                                                                       // 125\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc                                   // 126\n    var dots;                                                                                          // 127\n    if ((dots = run(/^[\\.\\/]+/))) {                                                                    // 128\n      var ancestorStr = '.'; // eg `../../..` maps to `....`                                           // 129\n      var endsWithSlash = /\\/$/.test(dots);                                                            // 130\n                                                                                                       // 131\n      if (endsWithSlash)                                                                               // 132\n        dots = dots.slice(0, -1);                                                                      // 133\n                                                                                                       // 134\n      _.each(dots.split('/'), function(dotClause, index) {                                             // 135\n        if (index === 0) {                                                                             // 136\n          if (dotClause !== '.' && dotClause !== '..')                                                 // 137\n            expected(\"`.`, `..`, `./` or `../`\");                                                      // 138\n        } else {                                                                                       // 139\n          if (dotClause !== '..')                                                                      // 140\n            expected(\"`..` or `../`\");                                                                 // 141\n        }                                                                                              // 142\n                                                                                                       // 143\n        if (dotClause === '..')                                                                        // 144\n          ancestorStr += '.';                                                                          // 145\n      });                                                                                              // 146\n                                                                                                       // 147\n      segments.push(ancestorStr);                                                                      // 148\n                                                                                                       // 149\n      if (!endsWithSlash)                                                                              // 150\n        return segments;                                                                               // 151\n    }                                                                                                  // 152\n                                                                                                       // 153\n    while (true) {                                                                                     // 154\n      // scan a path segment                                                                           // 155\n                                                                                                       // 156\n      if (run(/^\\[/)) {                                                                                // 157\n        var seg = run(/^[\\s\\S]*?\\]/);                                                                  // 158\n        if (! seg)                                                                                     // 159\n          error(\"Unterminated path segment\");                                                          // 160\n        seg = seg.slice(0, -1);                                                                        // 161\n        if (! seg && ! segments.length)                                                                // 162\n          error(\"Path can't start with empty string\");                                                 // 163\n        segments.push(seg);                                                                            // 164\n      } else {                                                                                         // 165\n        var id = scanIdentifier(! segments.length);                                                    // 166\n        if (id === 'this') {                                                                           // 167\n          if (! segments.length) {                                                                     // 168\n            // initial `this`                                                                          // 169\n            segments.push('.');                                                                        // 170\n          } else {                                                                                     // 171\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }                                                                                            // 173\n        } else {                                                                                       // 174\n          segments.push(id);                                                                           // 175\n        }                                                                                              // 176\n      }                                                                                                // 177\n                                                                                                       // 178\n      var sep = run(/^[\\.\\/]/);                                                                        // 179\n      if (! sep)                                                                                       // 180\n        break;                                                                                         // 181\n    }                                                                                                  // 182\n                                                                                                       // 183\n    return segments;                                                                                   // 184\n  };                                                                                                   // 185\n                                                                                                       // 186\n  // scan the keyword portion of a keyword argument                                                    // 187\n  // (the \"foo\" portion in \"foo=bar\").                                                                 // 188\n  // Result is either the keyword matched, or null                                                     // 189\n  // if we're not at a keyword argument position.                                                      // 190\n  var scanArgKeyword = function () {                                                                   // 191\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());                             // 192\n    if (match) {                                                                                       // 193\n      scanner.pos += match[0].length;                                                                  // 194\n      return match[1];                                                                                 // 195\n    } else {                                                                                           // 196\n      return null;                                                                                     // 197\n    }                                                                                                  // 198\n  };                                                                                                   // 199\n                                                                                                       // 200\n  // scan an argument; succeeds or errors.                                                             // 201\n  // Result is an array of two or three items:                                                         // 202\n  // type , value, and (indicating a keyword argument)                                                 // 203\n  // keyword name.                                                                                     // 204\n  var scanArg = function () {                                                                          // 205\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg                                     // 206\n    var value = scanArgValue();                                                                        // 207\n    return keyword ? value.concat(keyword) : value;                                                    // 208\n  };                                                                                                   // 209\n                                                                                                       // 210\n  // scan an argument value (for keyword or positional arguments);                                     // 211\n  // succeeds or errors.  Result is an array of type, value.                                           // 212\n  var scanArgValue = function () {                                                                     // 213\n    var startPos = scanner.pos;                                                                        // 214\n    var result;                                                                                        // 215\n    if ((result = BlazeTools.parseNumber(scanner))) {                                                  // 216\n      return ['NUMBER', result.value];                                                                 // 217\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {                                    // 218\n      return ['STRING', result.value];                                                                 // 219\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {                                                       // 220\n      return ['PATH', scanPath()];                                                                     // 221\n    } else if (run(/^\\(/)) {                                                                           // 222\n      return ['EXPR', scanExpr('EXPR')];                                                               // 223\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {                           // 224\n      var id = result;                                                                                 // 225\n      if (id === 'null') {                                                                             // 226\n        return ['NULL', null];                                                                         // 227\n      } else if (id === 'true' || id === 'false') {                                                    // 228\n        return ['BOOLEAN', id === 'true'];                                                             // 229\n      } else {                                                                                         // 230\n        scanner.pos = startPos; // unconsume `id`                                                      // 231\n        return ['PATH', scanPath()];                                                                   // 232\n      }                                                                                                // 233\n    } else {                                                                                           // 234\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }                                                                                                  // 236\n  };                                                                                                   // 237\n                                                                                                       // 238\n  var scanExpr = function (type) {                                                                     // 239\n    var endType = type;                                                                                // 240\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN')                                                  // 241\n      endType = 'DOUBLE';                                                                              // 242\n                                                                                                       // 243\n    var tag = new TemplateTag;                                                                         // 244\n    tag.type = type;                                                                                   // 245\n    tag.path = scanPath();                                                                             // 246\n    tag.args = [];                                                                                     // 247\n    var foundKwArg = false;                                                                            // 248\n    while (true) {                                                                                     // 249\n      run(/^\\s*/);                                                                                     // 250\n      if (run(ends[endType]))                                                                          // 251\n        break;                                                                                         // 252\n      else if (/^[})]/.test(scanner.peek())) {                                                         // 253\n        expected('`' + endsString[endType] + '`');                                                     // 254\n      }                                                                                                // 255\n      var newArg = scanArg();                                                                          // 256\n      if (newArg.length === 3) {                                                                       // 257\n        foundKwArg = true;                                                                             // 258\n      } else {                                                                                         // 259\n        if (foundKwArg)                                                                                // 260\n          error(\"Can't have a non-keyword argument after a keyword argument\");                         // 261\n      }                                                                                                // 262\n      tag.args.push(newArg);                                                                           // 263\n                                                                                                       // 264\n      // expect a whitespace or a closing ')' or '}'                                                   // 265\n      if (run(/^(?=[\\s})])/) !== '')                                                                   // 266\n        expected('space');                                                                             // 267\n    }                                                                                                  // 268\n                                                                                                       // 269\n    return tag;                                                                                        // 270\n  };                                                                                                   // 271\n                                                                                                       // 272\n  var type;                                                                                            // 273\n                                                                                                       // 274\n  var error = function (msg) {                                                                         // 275\n    scanner.fatal(msg);                                                                                // 276\n  };                                                                                                   // 277\n                                                                                                       // 278\n  var expected = function (what) {                                                                     // 279\n    error('Expected ' + what);                                                                         // 280\n  };                                                                                                   // 281\n                                                                                                       // 282\n  // must do ESCAPE first, immediately followed by ELSE                                                // 283\n  // order of others doesn't matter                                                                    // 284\n  if (run(starts.ESCAPE)) type = 'ESCAPE';                                                             // 285\n  else if (run(starts.ELSE)) type = 'ELSE';                                                            // 286\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';                                                        // 287\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';                                                        // 288\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';                                            // 289\n  else if (run(starts.COMMENT)) type = 'COMMENT';                                                      // 290\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';                                                  // 291\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';                                                  // 292\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';                                                // 293\n  else                                                                                                 // 294\n    error('Unknown stache tag');                                                                       // 295\n                                                                                                       // 296\n  var tag = new TemplateTag;                                                                           // 297\n  tag.type = type;                                                                                     // 298\n                                                                                                       // 299\n  if (type === 'BLOCKCOMMENT') {                                                                       // 300\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);                                                           // 301\n    if (! result)                                                                                      // 302\n      error(\"Unclosed block comment\");                                                                 // 303\n    tag.value = result.slice(0, result.lastIndexOf('--'));                                             // 304\n  } else if (type === 'COMMENT') {                                                                     // 305\n    var result = run(/^[\\s\\S]*?\\}\\}/);                                                                 // 306\n    if (! result)                                                                                      // 307\n      error(\"Unclosed comment\");                                                                       // 308\n    tag.value = result.slice(0, -2);                                                                   // 309\n  } else if (type === 'BLOCKCLOSE') {                                                                  // 310\n    tag.path = scanPath();                                                                             // 311\n    if (! run(ends.DOUBLE))                                                                            // 312\n      expected('`}}`');                                                                                // 313\n  } else if (type === 'ELSE') {                                                                        // 314\n    if (! run(ends.DOUBLE))                                                                            // 315\n      expected('`}}`');                                                                                // 316\n  } else if (type === 'ESCAPE') {                                                                      // 317\n    var result = run(/^\\{*\\|/);                                                                        // 318\n    tag.value = '{{' + result.slice(0, -1);                                                            // 319\n  } else {                                                                                             // 320\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION                                                            // 321\n    tag = scanExpr(type);                                                                              // 322\n  }                                                                                                    // 323\n                                                                                                       // 324\n  return tag;                                                                                          // 325\n};                                                                                                     // 326\n                                                                                                       // 327\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner                      // 328\n// at its original position.                                                                           // 329\n//                                                                                                     // 330\n// An error will still be thrown if there is not a valid template tag at                               // 331\n// the current position.                                                                               // 332\nTemplateTag.peek = function (scanner) {                                                                // 333\n  var startPos = scanner.pos;                                                                          // 334\n  var result = TemplateTag.parse(scanner);                                                             // 335\n  scanner.pos = startPos;                                                                              // 336\n  return result;                                                                                       // 337\n};                                                                                                     // 338\n                                                                                                       // 339\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete                             // 340\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather                             // 341\n// than just the BLOCKOPEN tag.                                                                        // 342\n//                                                                                                     // 343\n// In addition:                                                                                        // 344\n//                                                                                                     // 345\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.                                   // 346\n//                                                                                                     // 347\n// - Returns `null` for a COMMENT.  (This case is distinguishable from                                 // 348\n//   parsing no tag by the fact that the scanner is advanced.)                                         // 349\n//                                                                                                     // 350\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the                            // 351\n//   TemplateTag's `.position` property.                                                               // 352\n//                                                                                                     // 353\n// - Validates the tag's well-formedness and legality at in its position.                              // 354\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {                                  // 355\n  var scanner = scannerOrString;                                                                       // 356\n  if (typeof scanner === 'string')                                                                     // 357\n    scanner = new HTMLTools.Scanner(scannerOrString);                                                  // 358\n                                                                                                       // 359\n  var startPos = scanner.pos; // for error messages                                                    // 360\n  var result = TemplateTag.parse(scannerOrString);                                                     // 361\n  if (! result)                                                                                        // 362\n    return result;                                                                                     // 363\n                                                                                                       // 364\n  if (result.type === 'BLOCKCOMMENT')                                                                  // 365\n    return null;                                                                                       // 366\n                                                                                                       // 367\n  if (result.type === 'COMMENT')                                                                       // 368\n    return null;                                                                                       // 369\n                                                                                                       // 370\n  if (result.type === 'ELSE')                                                                          // 371\n    scanner.fatal(\"Unexpected {{else}}\");                                                              // 372\n                                                                                                       // 373\n  if (result.type === 'BLOCKCLOSE')                                                                    // 374\n    scanner.fatal(\"Unexpected closing template tag\");                                                  // 375\n                                                                                                       // 376\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);                                              // 377\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)                                                      // 378\n    result.position = position;                                                                        // 379\n                                                                                                       // 380\n  if (result.type === 'BLOCKOPEN') {                                                                   // 381\n    // parse block contents                                                                            // 382\n                                                                                                       // 383\n    // Construct a string version of `.path` for comparing start and                                   // 384\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`                                // 385\n    // and now becomes `foo,0`.  This form may also show up in error                                   // 386\n    // messages.                                                                                       // 387\n    var blockName = result.path.join(',');                                                             // 388\n                                                                                                       // 389\n    var textMode = null;                                                                               // 390\n      if (blockName === 'markdown' ||                                                                  // 391\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {                                             // 392\n        textMode = HTML.TEXTMODE.STRING;                                                               // 393\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||                                       // 394\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                                    // 395\n        textMode = HTML.TEXTMODE.RCDATA;                                                               // 396\n      }                                                                                                // 397\n      var parserOptions = {                                                                            // 398\n        getTemplateTag: TemplateTag.parseCompleteTag,                                                  // 399\n        shouldStop: isAtBlockCloseOrElse,                                                              // 400\n        textMode: textMode                                                                             // 401\n      };                                                                                               // 402\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);                                  // 403\n                                                                                                       // 404\n    if (scanner.rest().slice(0, 2) !== '{{')                                                           // 405\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);                              // 406\n                                                                                                       // 407\n    var lastPos = scanner.pos; // save for error messages                                              // 408\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}                                  // 409\n                                                                                                       // 410\n    if (tmplTag.type === 'ELSE') {                                                                     // 411\n      // parse {{else}} and content up to close tag                                                    // 412\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);                            // 413\n                                                                                                       // 414\n      if (scanner.rest().slice(0, 2) !== '{{')                                                         // 415\n        scanner.fatal(\"Expected block close for \" + blockName);                                        // 416\n                                                                                                       // 417\n      lastPos = scanner.pos;                                                                           // 418\n      tmplTag = TemplateTag.parse(scanner);                                                            // 419\n    }                                                                                                  // 420\n                                                                                                       // 421\n    if (tmplTag.type === 'BLOCKCLOSE') {                                                               // 422\n      var blockName2 = tmplTag.path.join(',');                                                         // 423\n      if (blockName !== blockName2) {                                                                  // 424\n        scanner.pos = lastPos;                                                                         // 425\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +                              // 426\n                      blockName2);                                                                     // 427\n      }                                                                                                // 428\n    } else {                                                                                           // 429\n      scanner.pos = lastPos;                                                                           // 430\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +                                // 431\n                    tmplTag.type);                                                                     // 432\n    }                                                                                                  // 433\n  }                                                                                                    // 434\n                                                                                                       // 435\n  var finalPos = scanner.pos;                                                                          // 436\n  scanner.pos = startPos;                                                                              // 437\n  validateTag(result, scanner);                                                                        // 438\n  scanner.pos = finalPos;                                                                              // 439\n                                                                                                       // 440\n  return result;                                                                                       // 441\n};                                                                                                     // 442\n                                                                                                       // 443\nvar isAtBlockCloseOrElse = function (scanner) {                                                        // 444\n  // Detect `{{else}}` or `{{/foo}}`.                                                                  // 445\n  //                                                                                                   // 446\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,                              // 447\n  // for efficiency (we're called for every input token) and to be                                     // 448\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it                              // 449\n  // sees `{{` followed by a malformed tag.                                                            // 450\n  var rest, type;                                                                                      // 451\n  return (scanner.peek() === '{' &&                                                                    // 452\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&                                              // 453\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&                                                          // 454\n          (type = TemplateTag.peek(scanner).type) &&                                                   // 455\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));                                                 // 456\n};                                                                                                     // 457\n                                                                                                       // 458\n// Validate that `templateTag` is correctly formed and legal for its                                   // 459\n// HTML position.  Use `scanner` to report errors. On success, does                                    // 460\n// nothing.                                                                                            // 461\nvar validateTag = function (ttag, scanner) {                                                           // 462\n                                                                                                       // 463\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {                                        // 464\n    var args = ttag.args;                                                                              // 465\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&                                 // 466\n        args[1][1][0] === 'in') {                                                                      // 467\n      // For slightly better error messages, we detect the each-in case                                // 468\n      // here in order not to complain if the user writes `{{#each 3 in x}}`                           // 469\n      // that \"3 is not a function\"                                                                    // 470\n    } else {                                                                                           // 471\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {                          // 472\n        // we have a positional argument that is not a PATH followed by                                // 473\n        // other arguments                                                                             // 474\n        scanner.fatal(\"First argument must be a function, to be called on \" +                          // 475\n                      \"the rest of the arguments; found \" + args[0][0]);                               // 476\n      }                                                                                                // 477\n    }                                                                                                  // 478\n  }                                                                                                    // 479\n                                                                                                       // 480\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;                                       // 481\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                                               // 482\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {                                            // 483\n      return;                                                                                          // 484\n    } else if (ttag.type === 'BLOCKOPEN') {                                                            // 485\n      var path = ttag.path;                                                                            // 486\n      var path0 = path[0];                                                                             // 487\n      if (! (path.length === 1 && (path0 === 'if' ||                                                   // 488\n                                   path0 === 'unless' ||                                               // 489\n                                   path0 === 'with' ||                                                 // 490\n                                   path0 === 'each'))) {                                               // 491\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }                                                                                                // 493\n    } else {                                                                                           // 494\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");                  // 495\n    }                                                                                                  // 496\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {                                        // 497\n    if (! (ttag.type === 'DOUBLE')) {                                                                  // 498\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }                                                                                                  // 500\n    if (scanner.peek() === '=') {                                                                      // 501\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }                                                                                                  // 503\n  }                                                                                                    // 504\n                                                                                                       // 505\n};                                                                                                     // 506\n                                                                                                       // 507\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/optimizer.js                                                            //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't                              // 1\n// contain template tags.                                                                              // 2\n                                                                                                       // 3\nvar constant = function (value) {                                                                      // 4\n  return function () { return value; };                                                                // 5\n};                                                                                                     // 6\n                                                                                                       // 7\nvar OPTIMIZABLE = {                                                                                    // 8\n  NONE: 0,                                                                                             // 9\n  PARTS: 1,                                                                                            // 10\n  FULL: 2                                                                                              // 11\n};                                                                                                     // 12\n                                                                                                       // 13\n// We can only turn content into an HTML string if it contains no template                             // 14\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content                              // 15\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an                                  // 16\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree                             // 17\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.                         // 18\n//                                                                                                     // 19\n// For example, we always create SVG elements programmatically, since SVG                              // 20\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.                            // 21\n// However, if we are given a big tree that contains SVG somewhere, we                                 // 22\n// return PARTS so that the optimizer can descend into the tree and optimize                           // 23\n// other parts of it.                                                                                  // 24\nvar CanOptimizeVisitor = HTML.Visitor.extend();                                                        // 25\nCanOptimizeVisitor.def({                                                                               // 26\n  visitNull: constant(OPTIMIZABLE.FULL),                                                               // 27\n  visitPrimitive: constant(OPTIMIZABLE.FULL),                                                          // 28\n  visitComment: constant(OPTIMIZABLE.FULL),                                                            // 29\n  visitCharRef: constant(OPTIMIZABLE.FULL),                                                            // 30\n  visitRaw: constant(OPTIMIZABLE.FULL),                                                                // 31\n  visitObject: constant(OPTIMIZABLE.NONE),                                                             // 32\n  visitFunction: constant(OPTIMIZABLE.NONE),                                                           // 33\n  visitArray: function (x) {                                                                           // 34\n    for (var i = 0; i < x.length; i++)                                                                 // 35\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)                                                       // 36\n        return OPTIMIZABLE.PARTS;                                                                      // 37\n    return OPTIMIZABLE.FULL;                                                                           // 38\n  },                                                                                                   // 39\n  visitTag: function (tag) {                                                                           // 40\n    var tagName = tag.tagName;                                                                         // 41\n    if (tagName === 'textarea') {                                                                      // 42\n      // optimizing into a TEXTAREA's RCDATA would require being a little                              // 43\n      // more clever.                                                                                  // 44\n      return OPTIMIZABLE.NONE;                                                                         // 45\n    } else if (tagName === 'script') {                                                                 // 46\n      // script tags don't work when rendered from strings                                             // 47\n      return OPTIMIZABLE.NONE;                                                                         // 48\n    } else if (! (HTML.isKnownElement(tagName) &&                                                      // 49\n                  ! HTML.isKnownSVGElement(tagName))) {                                                // 50\n      // foreign elements like SVG can't be stringified for innerHTML.                                 // 51\n      return OPTIMIZABLE.NONE;                                                                         // 52\n    } else if (tagName === 'table') {                                                                  // 53\n      // Avoid ever producing HTML containing `<table><tr>...`, because the                            // 54\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and                         // 55\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary                               // 56\n      // (assuming IE 8+).                                                                             // 57\n      return OPTIMIZABLE.NONE;                                                                         // 58\n    }                                                                                                  // 59\n                                                                                                       // 60\n    var children = tag.children;                                                                       // 61\n    for (var i = 0; i < children.length; i++)                                                          // 62\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)                                                // 63\n        return OPTIMIZABLE.PARTS;                                                                      // 64\n                                                                                                       // 65\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)                                          // 66\n      return OPTIMIZABLE.PARTS;                                                                        // 67\n                                                                                                       // 68\n    return OPTIMIZABLE.FULL;                                                                           // 69\n  },                                                                                                   // 70\n  visitAttributes: function (attrs) {                                                                  // 71\n    if (attrs) {                                                                                       // 72\n      var isArray = HTML.isArray(attrs);                                                               // 73\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {                                         // 74\n        var a = (isArray ? attrs[i] : attrs);                                                          // 75\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))                           // 76\n          return OPTIMIZABLE.PARTS;                                                                    // 77\n        for (var k in a)                                                                               // 78\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)                                                   // 79\n            return OPTIMIZABLE.PARTS;                                                                  // 80\n      }                                                                                                // 81\n    }                                                                                                  // 82\n    return OPTIMIZABLE.FULL;                                                                           // 83\n  }                                                                                                    // 84\n});                                                                                                    // 85\n                                                                                                       // 86\nvar getOptimizability = function (content) {                                                           // 87\n  return (new CanOptimizeVisitor).visit(content);                                                      // 88\n};                                                                                                     // 89\n                                                                                                       // 90\nvar toRaw = function (x) {                                                                             // 91\n  return HTML.Raw(HTML.toHTML(x));                                                                     // 92\n};                                                                                                     // 93\n                                                                                                       // 94\nvar TreeTransformer = HTML.TransformingVisitor.extend();                                               // 95\nTreeTransformer.def({                                                                                  // 96\n  visitAttributes: function (attrs/*, ...*/) {                                                         // 97\n    // pass template tags through by default                                                           // 98\n    if (attrs instanceof HTMLTools.TemplateTag)                                                        // 99\n      return attrs;                                                                                    // 100\n                                                                                                       // 101\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(                                   // 102\n      this, arguments);                                                                                // 103\n  }                                                                                                    // 104\n});                                                                                                    // 105\n                                                                                                       // 106\n// Replace parts of the HTMLjs tree that have no template tags (or                                     // 107\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.                                        // 108\nvar OptimizingVisitor = TreeTransformer.extend();                                                      // 109\nOptimizingVisitor.def({                                                                                // 110\n  visitNull: toRaw,                                                                                    // 111\n  visitPrimitive: toRaw,                                                                               // 112\n  visitComment: toRaw,                                                                                 // 113\n  visitCharRef: toRaw,                                                                                 // 114\n  visitArray: function (array) {                                                                       // 115\n    var optimizability = getOptimizability(array);                                                     // 116\n    if (optimizability === OPTIMIZABLE.FULL) {                                                         // 117\n      return toRaw(array);                                                                             // 118\n    } else if (optimizability === OPTIMIZABLE.PARTS) {                                                 // 119\n      return TreeTransformer.prototype.visitArray.call(this, array);                                   // 120\n    } else {                                                                                           // 121\n      return array;                                                                                    // 122\n    }                                                                                                  // 123\n  },                                                                                                   // 124\n  visitTag: function (tag) {                                                                           // 125\n    var optimizability = getOptimizability(tag);                                                       // 126\n    if (optimizability === OPTIMIZABLE.FULL) {                                                         // 127\n      return toRaw(tag);                                                                               // 128\n    } else if (optimizability === OPTIMIZABLE.PARTS) {                                                 // 129\n      return TreeTransformer.prototype.visitTag.call(this, tag);                                       // 130\n    } else {                                                                                           // 131\n      return tag;                                                                                      // 132\n    }                                                                                                  // 133\n  },                                                                                                   // 134\n  visitChildren: function (children) {                                                                 // 135\n    // don't optimize the children array into a Raw object!                                            // 136\n    return TreeTransformer.prototype.visitArray.call(this, children);                                  // 137\n  },                                                                                                   // 138\n  visitAttributes: function (attrs) {                                                                  // 139\n    return attrs;                                                                                      // 140\n  }                                                                                                    // 141\n});                                                                                                    // 142\n                                                                                                       // 143\n// Combine consecutive HTML.Raws.  Remove empty ones.                                                  // 144\nvar RawCompactingVisitor = TreeTransformer.extend();                                                   // 145\nRawCompactingVisitor.def({                                                                             // 146\n  visitArray: function (array) {                                                                       // 147\n    var result = [];                                                                                   // 148\n    for (var i = 0; i < array.length; i++) {                                                           // 149\n      var item = array[i];                                                                             // 150\n      if ((item instanceof HTML.Raw) &&                                                                // 151\n          ((! item.value) ||                                                                           // 152\n           (result.length &&                                                                           // 153\n            (result[result.length - 1] instanceof HTML.Raw)))) {                                       // 154\n        // two cases: item is an empty Raw, or previous item is                                        // 155\n        // a Raw as well.  In the latter case, replace the previous                                    // 156\n        // Raw with a longer one that includes the new Raw.                                            // 157\n        if (item.value) {                                                                              // 158\n          result[result.length - 1] = HTML.Raw(                                                        // 159\n            result[result.length - 1].value + item.value);                                             // 160\n        }                                                                                              // 161\n      } else {                                                                                         // 162\n        result.push(item);                                                                             // 163\n      }                                                                                                // 164\n    }                                                                                                  // 165\n    return result;                                                                                     // 166\n  }                                                                                                    // 167\n});                                                                                                    // 168\n                                                                                                       // 169\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special                               // 170\n// characters with simple strings.                                                                     // 171\nvar RawReplacingVisitor = TreeTransformer.extend();                                                    // 172\nRawReplacingVisitor.def({                                                                              // 173\n  visitRaw: function (raw) {                                                                           // 174\n    var html = raw.value;                                                                              // 175\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {                                              // 176\n      return html;                                                                                     // 177\n    } else {                                                                                           // 178\n      return raw;                                                                                      // 179\n    }                                                                                                  // 180\n  }                                                                                                    // 181\n});                                                                                                    // 182\n                                                                                                       // 183\nSpacebarsCompiler.optimize = function (tree) {                                                         // 184\n  tree = (new OptimizingVisitor).visit(tree);                                                          // 185\n  tree = (new RawCompactingVisitor).visit(tree);                                                       // 186\n  tree = (new RawReplacingVisitor).visit(tree);                                                        // 187\n  return tree;                                                                                         // 188\n};                                                                                                     // 189\n                                                                                                       // 190\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/react.js                                                                //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// A visitor to ensure that React components included via the `{{>                                     // 1\n// React}}` template defined in the react-template-helper package are                                  // 2\n// the only child in their parent component. Otherwise `React.render`                                  // 3\n// would eliminate all of their sibling nodes.                                                         // 4\n//                                                                                                     // 5\n// It's a little strange that this logic is in spacebars-compiler if                                   // 6\n// it's only relevant to a specific package but there's no way to have                                 // 7\n// a package hook into a build plugin.                                                                 // 8\nReactComponentSiblingForbidder = HTML.Visitor.extend();                                                // 9\nReactComponentSiblingForbidder.def({                                                                   // 10\n  visitArray: function (array, parentTag) {                                                            // 11\n    for (var i = 0; i < array.length; i++) {                                                           // 12\n      this.visit(array[i], parentTag);                                                                 // 13\n    }                                                                                                  // 14\n  },                                                                                                   // 15\n  visitObject: function (obj, parentTag) {                                                             // 16\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {                // 17\n      if (!parentTag) {                                                                                // 18\n        throw new Error(                                                                               // 19\n          \"{{> React}} must be used in a container element\"                                            // 20\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")                                      // 21\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }                                                                                                // 23\n                                                                                                       // 24\n      var numSiblings = 0;                                                                             // 25\n      for (var i = 0; i < parentTag.children.length; i++) {                                            // 26\n        var child = parentTag.children[i];                                                             // 27\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {                   // 28\n          numSiblings++;                                                                               // 29\n        }                                                                                              // 30\n      }                                                                                                // 31\n                                                                                                       // 32\n      if (numSiblings > 0) {                                                                           // 33\n        throw new Error(                                                                               // 34\n          \"{{> React}} must be used as the only child in a container element\"                          // 35\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")                                      // 36\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }                                                                                                // 38\n    }                                                                                                  // 39\n  },                                                                                                   // 40\n  visitTag: function (tag) {                                                                           // 41\n    this.visitArray(tag.children, tag /*parentTag*/);                                                  // 42\n  }                                                                                                    // 43\n});                                                                                                    // 44\n                                                                                                       // 45\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/codegen.js                                                              //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// ============================================================                                        // 1\n// Code-generation of template tags                                                                    // 2\n                                                                                                       // 3\n// The `CodeGen` class currently has no instance state, but in theory                                  // 4\n// it could be useful to track per-function state, like whether we                                     // 5\n// need to emit `var self = this` or not.                                                              // 6\nvar CodeGen = SpacebarsCompiler.CodeGen = function () {};                                              // 7\n                                                                                                       // 8\nvar builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {                                   // 9\n  'if': 'Blaze.If',                                                                                    // 10\n  'unless': 'Blaze.Unless',                                                                            // 11\n  'with': 'Spacebars.With',                                                                            // 12\n  'each': 'Blaze.Each',                                                                                // 13\n  'let': 'Blaze.Let'                                                                                   // 14\n};                                                                                                     // 15\n                                                                                                       // 16\n                                                                                                       // 17\n// Mapping of \"macros\" which, when preceded by `Template.`, expand                                     // 18\n// to special code rather than following the lookup rules for dotted                                   // 19\n// symbols.                                                                                            // 20\nvar builtInTemplateMacros = {                                                                          // 21\n  // `view` is a local variable defined in the generated render                                        // 22\n  // function for the template in which `Template.contentBlock` or                                     // 23\n  // `Template.elseBlock` is invoked.                                                                  // 24\n  'contentBlock': 'view.templateContentBlock',                                                         // 25\n  'elseBlock': 'view.templateElseBlock',                                                               // 26\n                                                                                                       // 27\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias                                         // 28\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that                                     // 29\n  // implements the dynamic template feature.                                                          // 30\n  'dynamic': 'Template.__dynamic',                                                                     // 31\n                                                                                                       // 32\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'                                 // 33\n};                                                                                                     // 34\n                                                                                                       // 35\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",                         // 36\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",                          // 37\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",                                      // 38\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",                                      // 39\n  \"registerHelper\", \"currentData\", \"parentData\"];                                                      // 40\n                                                                                                       // 41\n// A \"reserved name\" can't be used as a <template> name.  This                                         // 42\n// function is used by the template file scanner.                                                      // 43\n//                                                                                                     // 44\n// Note that the runtime imposes additional restrictions, for example                                  // 45\n// banning the name \"body\" and names of built-in object properties                                     // 46\n// like \"toString\".                                                                                    // 47\nSpacebarsCompiler.isReservedName = function (name) {                                                   // 48\n  return builtInBlockHelpers.hasOwnProperty(name) ||                                                   // 49\n    builtInTemplateMacros.hasOwnProperty(name) ||                                                      // 50\n    _.indexOf(additionalReservedNames, name) > -1;                                                     // 51\n};                                                                                                     // 52\n                                                                                                       // 53\nvar makeObjectLiteral = function (obj) {                                                               // 54\n  var parts = [];                                                                                      // 55\n  for (var k in obj)                                                                                   // 56\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);                                      // 57\n  return '{' + parts.join(', ') + '}';                                                                 // 58\n};                                                                                                     // 59\n                                                                                                       // 60\n_.extend(CodeGen.prototype, {                                                                          // 61\n  codeGenTemplateTag: function (tag) {                                                                 // 62\n    var self = this;                                                                                   // 63\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {                               // 64\n      // Special dynamic attributes: `<div {{attrs}}>...`                                              // 65\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)                                  // 66\n      return BlazeTools.EmitCode('function () { return ' +                                             // 67\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')                                     // 68\n          + '; }');                                                                                    // 69\n    } else {                                                                                           // 70\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {                                            // 71\n        var code = self.codeGenMustache(tag.path, tag.args);                                           // 72\n        if (tag.type === 'TRIPLE') {                                                                   // 73\n          code = 'Spacebars.makeRaw(' + code + ')';                                                    // 74\n        }                                                                                              // 75\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                           // 76\n          // Reactive attributes are already wrapped in a function,                                    // 77\n          // and there's no fine-grained reactivity.                                                   // 78\n          // Anywhere else, we need to create a View.                                                  // 79\n          code = 'Blaze.View(' +                                                                       // 80\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +                            // 81\n            'function () { return ' + code + '; })';                                                   // 82\n        }                                                                                              // 83\n        return BlazeTools.EmitCode(code);                                                              // 84\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {                               // 85\n        var path = tag.path;                                                                           // 86\n        var args = tag.args;                                                                           // 87\n                                                                                                       // 88\n        if (tag.type === 'BLOCKOPEN' &&                                                                // 89\n            builtInBlockHelpers.hasOwnProperty(path[0])) {                                             // 90\n          // if, unless, with, each.                                                                   // 91\n          //                                                                                           // 92\n          // If someone tries to do `{{> if}}`, we don't                                               // 93\n          // get here, but an error is thrown when we try to codegen the path.                         // 94\n                                                                                                       // 95\n          // Note: If we caught these errors earlier, while scanning, we'd be able to                  // 96\n          // provide nice line numbers.                                                                // 97\n          if (path.length > 1)                                                                         // 98\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);                       // 99\n          if (! args.length)                                                                           // 100\n            throw new Error(\"#\" + path[0] + \" requires an argument\");                                  // 101\n                                                                                                       // 102\n          var dataCode = null;                                                                         // 103\n          // #each has a special treatment as it features two different forms:                         // 104\n          // - {{#each people}}                                                                        // 105\n          // - {{#each person in people}}                                                              // 106\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&                       // 107\n              args[1][1].length && args[1][1][0] === 'in') {                                           // 108\n            // minimum conditions are met for each-in.  now validate this                              // 109\n            // isn't some weird case.                                                                  // 110\n            var eachUsage = \"Use either {{#each items}} or \" +                                         // 111\n                  \"{{#each item in items}} form of #each.\";                                            // 112\n            var inArg = args[1];                                                                       // 113\n            if (! (args.length >= 3 && inArg[1].length === 1)) {                                       // 114\n              // we don't have at least 3 space-separated parts after #each, or                        // 115\n              // inArg doesn't look like ['PATH',['in']]                                               // 116\n              throw new Error(\"Malformed #each. \" + eachUsage);                                        // 117\n            }                                                                                          // 118\n            // split out the variable name and sequence arguments                                      // 119\n            var variableArg = args[0];                                                                 // 120\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&                         // 121\n                   variableArg[1][0].replace(/\\./g, ''))) {                                            // 122\n              throw new Error(\"Bad variable name in #each\");                                           // 123\n            }                                                                                          // 124\n            var variable = variableArg[1][0];                                                          // 125\n            dataCode = 'function () { return { _sequence: ' +                                          // 126\n              self.codeGenInclusionData(args.slice(2)) +                                               // 127\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';                            // 128\n          } else if (path[0] === 'let') {                                                              // 129\n            var dataProps = {};                                                                        // 130\n            _.each(args, function (arg) {                                                              // 131\n              if (arg.length !== 3) {                                                                  // 132\n                // not a keyword arg (x=y)                                                             // 133\n                throw new Error(\"Incorrect form of #let\");                                             // 134\n              }                                                                                        // 135\n              var argKey = arg[2];                                                                     // 136\n              dataProps[argKey] =                                                                      // 137\n                'function () { return Spacebars.call(' +                                               // 138\n                self.codeGenArgValue(arg) + '); }';                                                    // 139\n            });                                                                                        // 140\n            dataCode = makeObjectLiteral(dataProps);                                                   // 141\n          }                                                                                            // 142\n                                                                                                       // 143\n          if (! dataCode) {                                                                            // 144\n            // `args` must exist (tag.args.length > 0)                                                 // 145\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';                                  // 146\n          }                                                                                            // 147\n                                                                                                       // 148\n          // `content` must exist                                                                      // 149\n          var contentBlock = (('content' in tag) ?                                                     // 150\n                              self.codeGenBlock(tag.content) : null);                                  // 151\n          // `elseContent` may not exist                                                               // 152\n          var elseContentBlock = (('elseContent' in tag) ?                                             // 153\n                                  self.codeGenBlock(tag.elseContent) : null);                          // 154\n                                                                                                       // 155\n          var callArgs = [dataCode, contentBlock];                                                     // 156\n          if (elseContentBlock)                                                                        // 157\n            callArgs.push(elseContentBlock);                                                           // 158\n                                                                                                       // 159\n          return BlazeTools.EmitCode(                                                                  // 160\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');                           // 161\n                                                                                                       // 162\n        } else {                                                                                       // 163\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});                               // 164\n          if (path.length > 1) {                                                                       // 165\n            // capture reactivity                                                                      // 166\n            compCode = 'function () { return Spacebars.call(' + compCode +                             // 167\n              '); }';                                                                                  // 168\n          }                                                                                            // 169\n                                                                                                       // 170\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);                                      // 171\n          var content = (('content' in tag) ?                                                          // 172\n                         self.codeGenBlock(tag.content) : null);                                       // 173\n          var elseContent = (('elseContent' in tag) ?                                                  // 174\n                             self.codeGenBlock(tag.elseContent) : null);                               // 175\n                                                                                                       // 176\n          var includeArgs = [compCode];                                                                // 177\n          if (content) {                                                                               // 178\n            includeArgs.push(content);                                                                 // 179\n            if (elseContent)                                                                           // 180\n              includeArgs.push(elseContent);                                                           // 181\n          }                                                                                            // 182\n                                                                                                       // 183\n          var includeCode =                                                                            // 184\n                'Spacebars.include(' + includeArgs.join(', ') + ')';                                   // 185\n                                                                                                       // 186\n          // calling convention compat -- set the data context around the                              // 187\n          // entire inclusion, so that if the name of the inclusion is                                 // 188\n          // a helper function, it gets the data context in `this`.                                    // 189\n          // This makes for a pretty confusing calling convention --                                   // 190\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`                             // 191\n          // -- but it's what we shipped for 0.8.0.  The rationale is that                             // 192\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.                                   // 193\n          if (dataCode) {                                                                              // 194\n            includeCode =                                                                              // 195\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +                          // 196\n              includeCode + '; })';                                                                    // 197\n          }                                                                                            // 198\n                                                                                                       // 199\n          // XXX BACK COMPAT - UI is the old name, Template is the new                                 // 200\n          if ((path[0] === 'UI' || path[0] === 'Template') &&                                          // 201\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {                               // 202\n            // Call contentBlock and elseBlock in the appropriate scope                                // 203\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '                    // 204\n              + includeCode + '; })';                                                                  // 205\n          }                                                                                            // 206\n                                                                                                       // 207\n          return BlazeTools.EmitCode(includeCode);                                                     // 208\n        }                                                                                              // 209\n      } else if (tag.type === 'ESCAPE') {                                                              // 210\n        return tag.value;                                                                              // 211\n      } else {                                                                                         // 212\n        // Can't get here; TemplateTag validation should catch any                                     // 213\n        // inappropriate tag types that might come out of the parser.                                  // 214\n        throw new Error(\"Unexpected template tag type: \" + tag.type);                                  // 215\n      }                                                                                                // 216\n    }                                                                                                  // 217\n  },                                                                                                   // 218\n                                                                                                       // 219\n  // `path` is an array of at least one string.                                                        // 220\n  //                                                                                                   // 221\n  // If `path.length > 1`, the generated code may be reactive                                          // 222\n  // (i.e. it may invalidate the current computation).                                                 // 223\n  //                                                                                                   // 224\n  // No code is generated to call the result if it's a function.                                       // 225\n  //                                                                                                   // 226\n  // Options:                                                                                          // 227\n  //                                                                                                   // 228\n  // - lookupTemplate {Boolean} If true, generated code also looks in                                  // 229\n  //   the list of templates. (After helpers, before data context).                                    // 230\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only                                   // 231\n  //   used for non-dotted paths.                                                                      // 232\n  codeGenPath: function (path, opts) {                                                                 // 233\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))                                                   // 234\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");                                // 235\n    // Let `{{#if Template.contentBlock}}` check whether this template was                             // 236\n    // invoked via inclusion or as a block helper, in addition to supporting                           // 237\n    // `{{> Template.contentBlock}}`.                                                                  // 238\n    // XXX BACK COMPAT - UI is the old name, Template is the new                                       // 239\n    if (path.length >= 2 &&                                                                            // 240\n        (path[0] === 'UI' || path[0] === 'Template')                                                   // 241\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {                                            // 242\n      if (path.length > 2)                                                                             // 243\n        throw new Error(\"Unexpected dotted path beginning with \" +                                     // 244\n                        path[0] + '.' + path[1]);                                                      // 245\n      return builtInTemplateMacros[path[1]];                                                           // 246\n    }                                                                                                  // 247\n                                                                                                       // 248\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);                                               // 249\n    var lookupMethod = 'lookup';                                                                       // 250\n    if (opts && opts.lookupTemplate && path.length === 1)                                              // 251\n      lookupMethod = 'lookupTemplate';                                                                 // 252\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';                                     // 253\n                                                                                                       // 254\n    if (path.length > 1) {                                                                             // 255\n      code = 'Spacebars.dot(' + code + ', ' +                                                          // 256\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';                                 // 257\n    }                                                                                                  // 258\n                                                                                                       // 259\n    return code;                                                                                       // 260\n  },                                                                                                   // 261\n                                                                                                       // 262\n  // Generates code for an `[argType, argValue]` argument spec,                                        // 263\n  // ignoring the third element (keyword argument name) if present.                                    // 264\n  //                                                                                                   // 265\n  // The resulting code may be reactive (in the case of a PATH of                                      // 266\n  // more than one element) and is not wrapped in a closure.                                           // 267\n  codeGenArgValue: function (arg) {                                                                    // 268\n    var self = this;                                                                                   // 269\n                                                                                                       // 270\n    var argType = arg[0];                                                                              // 271\n    var argValue = arg[1];                                                                             // 272\n                                                                                                       // 273\n    var argCode;                                                                                       // 274\n    switch (argType) {                                                                                 // 275\n    case 'STRING':                                                                                     // 276\n    case 'NUMBER':                                                                                     // 277\n    case 'BOOLEAN':                                                                                    // 278\n    case 'NULL':                                                                                       // 279\n      argCode = BlazeTools.toJSLiteral(argValue);                                                      // 280\n      break;                                                                                           // 281\n    case 'PATH':                                                                                       // 282\n      argCode = self.codeGenPath(argValue);                                                            // 283\n      break;                                                                                           // 284\n    case 'EXPR':                                                                                       // 285\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]                  // 286\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');                    // 287\n      break;                                                                                           // 288\n    default:                                                                                           // 289\n      // can't get here                                                                                // 290\n      throw new Error(\"Unexpected arg type: \" + argType);                                              // 291\n    }                                                                                                  // 292\n                                                                                                       // 293\n    return argCode;                                                                                    // 294\n  },                                                                                                   // 295\n                                                                                                       // 296\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.                               // 297\n  // The resulting code has no function literals and must be wrapped in                                // 298\n  // one for fine-grained reactivity.                                                                  // 299\n  codeGenMustache: function (path, args, mustacheType) {                                               // 300\n    var self = this;                                                                                   // 301\n                                                                                                       // 302\n    var nameCode = self.codeGenPath(path);                                                             // 303\n    var argCode = self.codeGenMustacheArgs(args);                                                      // 304\n    var mustache = (mustacheType || 'mustache');                                                       // 305\n                                                                                                       // 306\n    return 'Spacebars.' + mustache + '(' + nameCode +                                                  // 307\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';                                                // 308\n  },                                                                                                   // 309\n                                                                                                       // 310\n  // returns: array of source strings, or null if no                                                   // 311\n  // args at all.                                                                                      // 312\n  codeGenMustacheArgs: function (tagArgs) {                                                            // 313\n    var self = this;                                                                                   // 314\n                                                                                                       // 315\n    var kwArgs = null; // source -> source                                                             // 316\n    var args = null; // [source]                                                                       // 317\n                                                                                                       // 318\n    // tagArgs may be null                                                                             // 319\n    _.each(tagArgs, function (arg) {                                                                   // 320\n      var argCode = self.codeGenArgValue(arg);                                                         // 321\n                                                                                                       // 322\n      if (arg.length > 2) {                                                                            // 323\n        // keyword argument (represented as [type, value, name])                                       // 324\n        kwArgs = (kwArgs || {});                                                                       // 325\n        kwArgs[arg[2]] = argCode;                                                                      // 326\n      } else {                                                                                         // 327\n        // positional argument                                                                         // 328\n        args = (args || []);                                                                           // 329\n        args.push(argCode);                                                                            // 330\n      }                                                                                                // 331\n    });                                                                                                // 332\n                                                                                                       // 333\n    // put kwArgs in options dictionary at end of args                                                 // 334\n    if (kwArgs) {                                                                                      // 335\n      args = (args || []);                                                                             // 336\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');                                    // 337\n    }                                                                                                  // 338\n                                                                                                       // 339\n    return args;                                                                                       // 340\n  },                                                                                                   // 341\n                                                                                                       // 342\n  codeGenBlock: function (content) {                                                                   // 343\n    return SpacebarsCompiler.codeGen(content);                                                         // 344\n  },                                                                                                   // 345\n                                                                                                       // 346\n  codeGenInclusionData: function (args) {                                                              // 347\n    var self = this;                                                                                   // 348\n                                                                                                       // 349\n    if (! args.length) {                                                                               // 350\n      // e.g. `{{#foo}}`                                                                               // 351\n      return null;                                                                                     // 352\n    } else if (args[0].length === 3) {                                                                 // 353\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`                                            // 354\n      var dataProps = {};                                                                              // 355\n      _.each(args, function (arg) {                                                                    // 356\n        var argKey = arg[2];                                                                           // 357\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';                       // 358\n      });                                                                                              // 359\n      return makeObjectLiteral(dataProps);                                                             // 360\n    } else if (args[0][0] !== 'PATH') {                                                                // 361\n      // literal first argument, e.g. `{{> foo \"blah\"}}`                                               // 362\n      //                                                                                               // 363\n      // tag validation has confirmed, in this case, that there is only                                // 364\n      // one argument (`args.length === 1`)                                                            // 365\n      return self.codeGenArgValue(args[0]);                                                            // 366\n    } else if (args.length === 1) {                                                                    // 367\n      // one argument, must be a PATH                                                                  // 368\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';                                   // 369\n    } else {                                                                                           // 370\n      // Multiple positional arguments; treat them as a nested                                         // 371\n      // \"data mustache\"                                                                               // 372\n      return self.codeGenMustache(args[0][1], args.slice(1),                                           // 373\n                                  'dataMustache');                                                     // 374\n    }                                                                                                  // 375\n                                                                                                       // 376\n  },                                                                                                   // 377\n                                                                                                       // 378\n  codeGenInclusionDataFunc: function (args) {                                                          // 379\n    var self = this;                                                                                   // 380\n    var dataCode = self.codeGenInclusionData(args);                                                    // 381\n    if (dataCode) {                                                                                    // 382\n      return 'function () { return ' + dataCode + '; }';                                               // 383\n    } else {                                                                                           // 384\n      return null;                                                                                     // 385\n    }                                                                                                  // 386\n  }                                                                                                    // 387\n                                                                                                       // 388\n});                                                                                                    // 389\n                                                                                                       // 390\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/compiler.js                                                             //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n                                                                                                       // 1\nSpacebarsCompiler.parse = function (input) {                                                           // 2\n                                                                                                       // 3\n  var tree = HTMLTools.parseFragment(                                                                  // 4\n    input,                                                                                             // 5\n    { getTemplateTag: TemplateTag.parseCompleteTag });                                                 // 6\n                                                                                                       // 7\n  return tree;                                                                                         // 8\n};                                                                                                     // 9\n                                                                                                       // 10\nSpacebarsCompiler.compile = function (input, options) {                                                // 11\n  var tree = SpacebarsCompiler.parse(input);                                                           // 12\n  return SpacebarsCompiler.codeGen(tree, options);                                                     // 13\n};                                                                                                     // 14\n                                                                                                       // 15\nSpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();                            // 16\nSpacebarsCompiler._TemplateTagReplacer.def({                                                           // 17\n  visitObject: function (x) {                                                                          // 18\n    if (x instanceof HTMLTools.TemplateTag) {                                                          // 19\n                                                                                                       // 20\n      // Make sure all TemplateTags in attributes have the right                                       // 21\n      // `.position` set on them.  This is a bit of a hack                                             // 22\n      // (we shouldn't be mutating that here), but it allows                                           // 23\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's                                     // 24\n      // \"value\", where the template tags were originally not                                          // 25\n      // in an attribute.                                                                              // 26\n      if (this.inAttributeValue)                                                                       // 27\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;                                     // 28\n                                                                                                       // 29\n      return this.codegen.codeGenTemplateTag(x);                                                       // 30\n    }                                                                                                  // 31\n                                                                                                       // 32\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);                               // 33\n  },                                                                                                   // 34\n  visitAttributes: function (attrs) {                                                                  // 35\n    if (attrs instanceof HTMLTools.TemplateTag)                                                        // 36\n      return this.codegen.codeGenTemplateTag(attrs);                                                   // 37\n                                                                                                       // 38\n    // call super (e.g. for case where `attrs` is an array)                                            // 39\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);                       // 40\n  },                                                                                                   // 41\n  visitAttribute: function (name, value, tag) {                                                        // 42\n    this.inAttributeValue = true;                                                                      // 43\n    var result = this.visit(value);                                                                    // 44\n    this.inAttributeValue = false;                                                                     // 45\n                                                                                                       // 46\n    if (result !== value) {                                                                            // 47\n      // some template tags must have been replaced, because otherwise                                 // 48\n      // we try to keep things `===` when transforming.  Wrap the code                                 // 49\n      // in a function as per the rules.  You can't have                                               // 50\n      // `{id: Blaze.View(...)}` as an attributes dict because the View                                // 51\n      // would be rendered more than once; you need to wrap it in a function                           // 52\n      // so that it's a different View each time.                                                      // 53\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));                                   // 54\n    }                                                                                                  // 55\n    return result;                                                                                     // 56\n  }                                                                                                    // 57\n});                                                                                                    // 58\n                                                                                                       // 59\nSpacebarsCompiler.codeGen = function (parseTree, options) {                                            // 60\n  // is this a template, rather than a block passed to                                                 // 61\n  // a block helper, say                                                                               // 62\n  var isTemplate = (options && options.isTemplate);                                                    // 63\n  var isBody = (options && options.isBody);                                                            // 64\n  var sourceName = (options && options.sourceName);                                                    // 65\n                                                                                                       // 66\n  var tree = parseTree;                                                                                // 67\n                                                                                                       // 68\n  // The flags `isTemplate` and `isBody` are kind of a hack.                                           // 69\n  if (isTemplate || isBody) {                                                                          // 70\n    // optimizing fragments would require being smarter about whether we are                           // 71\n    // in a TEXTAREA, say.                                                                             // 72\n    tree = SpacebarsCompiler.optimize(tree);                                                           // 73\n  }                                                                                                    // 74\n                                                                                                       // 75\n  // throws an error if using `{{> React}}` with siblings                                              // 76\n  new ReactComponentSiblingForbidder({sourceName: sourceName})                                         // 77\n    .visit(tree);                                                                                      // 78\n                                                                                                       // 79\n  var codegen = new SpacebarsCompiler.CodeGen;                                                         // 80\n  tree = (new SpacebarsCompiler._TemplateTagReplacer(                                                  // 81\n    {codegen: codegen})).visit(tree);                                                                  // 82\n                                                                                                       // 83\n  var code = '(function () { ';                                                                        // 84\n  if (isTemplate || isBody) {                                                                          // 85\n    code += 'var view = this; ';                                                                       // 86\n  }                                                                                                    // 87\n  code += 'return ';                                                                                   // 88\n  code += BlazeTools.toJS(tree);                                                                       // 89\n  code += '; })';                                                                                      // 90\n                                                                                                       // 91\n  code = SpacebarsCompiler._beautify(code);                                                            // 92\n                                                                                                       // 93\n  return code;                                                                                         // 94\n};                                                                                                     // 95\n                                                                                                       // 96\nSpacebarsCompiler._beautify = function (code) {                                                        // 97\n  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {                                         // 98\n    var result = Package.minifiers.UglifyJSMinify(                                                     // 99\n      code,                                                                                            // 100\n      { fromString: true,                                                                              // 101\n        mangle: false,                                                                                 // 102\n        compress: false,                                                                               // 103\n        output: { beautify: true,                                                                      // 104\n                  indent_level: 2,                                                                     // 105\n                  width: 80 } });                                                                      // 106\n    var output = result.code;                                                                          // 107\n    // Uglify interprets our expression as a statement and may add a semicolon.                        // 108\n    // Strip trailing semicolon.                                                                       // 109\n    output = output.replace(/;$/, '');                                                                 // 110\n    return output;                                                                                     // 111\n  } else {                                                                                             // 112\n    // don't actually beautify; no UglifyJS                                                            // 113\n    return code;                                                                                       // 114\n  }                                                                                                    // 115\n};                                                                                                     // 116\n                                                                                                       // 117\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['spacebars-compiler'] = {\n  SpacebarsCompiler: SpacebarsCompiler\n};\n\n})();\n","servePath":"/packages/spacebars-compiler.js","sourceMap":{"version":3,"sources":["/packages/spacebars-compiler/templatetag.js","/packages/spacebars-compiler/optimizer.js","/packages/spacebars-compiler/react.js","/packages/spacebars-compiler/codegen.js","/packages/spacebars-compiler/compiler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G;;;;;;;;;;;;;;;;;;AC1fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G;;;;;;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4G;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G;;;;;;;;;;;;;;;;;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G","file":"/packages/spacebars-compiler.js","sourcesContent":["SpacebarsCompiler = {};\n\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   and BLOCKCLOSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, and BLOCKOPEN.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\n\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nTemplateTag = SpacebarsCompiler.TemplateTag = function () {\n  HTMLTools.TemplateTag.apply(this, arguments);\n};\nTemplateTag.prototype = new HTMLTools.TemplateTag;\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source,\n                    r.ignoreCase ? 'i' : '');\n};\n\n// \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\n\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\n\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n};\n\n// Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  if (! (scanner.peek() === '{' &&\n         (scanner.rest()).slice(0, 2) === '{{'))\n    return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (! result)\n      return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n    if (! id) {\n      expected('IDENTIFIER');\n    }\n    if (isFirstInPath &&\n        (id === 'null' || id === 'true' || id === 'false'))\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = [];\n\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n    var dots;\n    if ((dots = run(/^[\\.\\/]+/))) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n      var endsWithSlash = /\\/$/.test(dots);\n\n      if (endsWithSlash)\n        dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function(dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..')\n            expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..')\n            expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..')\n          ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n\n      if (!endsWithSlash)\n        return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (! seg)\n          error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (! seg && ! segments.length)\n          error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(! segments.length);\n        if (id === 'this') {\n          if (! segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (! sep)\n        break;\n    }\n\n    return segments;\n  };\n\n  // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  };\n\n  // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  };\n\n  // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n    if ((result = BlazeTools.parseNumber(scanner))) {\n      return ['NUMBER', result.value];\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {\n      var id = result;\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN')\n      endType = 'DOUBLE';\n\n    var tag = new TemplateTag;\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType]))\n        break;\n      else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg)\n          error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n      tag.args.push(newArg);\n\n      // expect a whitespace or a closing ')' or '}'\n      if (run(/^(?=[\\s})])/) !== '')\n        expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  };\n\n  // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n  if (run(starts.ESCAPE)) type = 'ESCAPE';\n  else if (run(starts.ELSE)) type = 'ELSE';\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\n  else if (run(starts.COMMENT)) type = 'COMMENT';\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\n  else\n    error('Unknown stache tag');\n\n  var tag = new TemplateTag;\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n};\n\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n};\n\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  var startPos = scanner.pos; // for error messages\n  var result = TemplateTag.parse(scannerOrString);\n  if (! result)\n    return result;\n\n  if (result.type === 'BLOCKCOMMENT')\n    return null;\n\n  if (result.type === 'COMMENT')\n    return null;\n\n  if (result.type === 'ELSE')\n    scanner.fatal(\"Unexpected {{else}}\");\n\n  if (result.type === 'BLOCKCLOSE')\n    scanner.fatal(\"Unexpected closing template tag\");\n\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\n    result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n\n    var textMode = null;\n      if (blockName === 'markdown' ||\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n        textMode = HTML.TEXTMODE.STRING;\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n        textMode = HTML.TEXTMODE.RCDATA;\n      }\n      var parserOptions = {\n        getTemplateTag: TemplateTag.parseCompleteTag,\n        shouldStop: isAtBlockCloseOrElse,\n        textMode: textMode\n      };\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n    if (scanner.rest().slice(0, 2) !== '{{')\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n\n    var lastPos = scanner.pos; // save for error messages\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    if (tmplTag.type === 'ELSE') {\n      // parse {{else}} and content up to close tag\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n\n      if (scanner.rest().slice(0, 2) !== '{{')\n        scanner.fatal(\"Expected block close for \" + blockName);\n\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                      blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                    tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return (scanner.peek() === '{' &&\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\n          (type = TemplateTag.peek(scanner).type) &&\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\n};\n\n// Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\nvar validateTag = function (ttag, scanner) {\n\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&\n        args[1][1][0] === 'in') {\n      // For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" +\n                      \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n      if (! (path.length === 1 && (path0 === 'if' ||\n                                   path0 === 'unless' ||\n                                   path0 === 'with' ||\n                                   path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (! (ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n\n};\n","// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\n\nvar constant = function (value) {\n  return function () { return value; };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n};\n\n// We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++)\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (! (HTML.isKnownElement(tagName) &&\n                  ! HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.NONE;\n    }\n\n    var children = tag.children;\n    for (var i = 0; i < children.length; i++)\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)\n      return OPTIMIZABLE.PARTS;\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = (isArray ? attrs[i] : attrs);\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))\n          return OPTIMIZABLE.PARTS;\n        for (var k in a)\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)\n            return OPTIMIZABLE.PARTS;\n      }\n    }\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return (new CanOptimizeVisitor).visit(content);\n};\n\nvar toRaw = function (x) {\n  return HTML.Raw(HTML.toHTML(x));\n};\n\nvar TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs/*, ...*/) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return attrs;\n\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(\n      this, arguments);\n  }\n});\n\n// Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\n// Combine consecutive HTML.Raws.  Remove empty ones.\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n      if ((item instanceof HTML.Raw) &&\n          ((! item.value) ||\n           (result.length &&\n            (result[result.length - 1] instanceof HTML.Raw)))) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(\n            result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(item);\n      }\n    }\n    return result;\n  }\n});\n\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nSpacebarsCompiler.optimize = function (tree) {\n  tree = (new OptimizingVisitor).visit(tree);\n  tree = (new RawCompactingVisitor).visit(tree);\n  tree = (new RawReplacingVisitor).visit(tree);\n  return tree;\n};\n","// A visitor to ensure that React components included via the `{{>\n// React}}` template defined in the react-template-helper package are\n// the only child in their parent component. Otherwise `React.render`\n// would eliminate all of their sibling nodes.\n//\n// It's a little strange that this logic is in spacebars-compiler if\n// it's only relevant to a specific package but there's no way to have\n// a package hook into a build plugin.\nReactComponentSiblingForbidder = HTML.Visitor.extend();\nReactComponentSiblingForbidder.def({\n  visitArray: function (array, parentTag) {\n    for (var i = 0; i < array.length; i++) {\n      this.visit(array[i], parentTag);\n    }\n  },\n  visitObject: function (obj, parentTag) {\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {\n      if (!parentTag) {\n        throw new Error(\n          \"{{> React}} must be used in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n\n      var numSiblings = 0;\n      for (var i = 0; i < parentTag.children.length; i++) {\n        var child = parentTag.children[i];\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {\n          numSiblings++;\n        }\n      }\n\n      if (numSiblings > 0) {\n        throw new Error(\n          \"{{> React}} must be used as the only child in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n    }\n  },\n  visitTag: function (tag) {\n    this.visitArray(tag.children, tag /*parentTag*/);\n  }\n});\n","// ============================================================\n// Code-generation of template tags\n\n// The `CodeGen` class currently has no instance state, but in theory\n// it could be useful to track per-function state, like whether we\n// need to emit `var self = this` or not.\nvar CodeGen = SpacebarsCompiler.CodeGen = function () {};\n\nvar builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n\n\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\n\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",\n  \"registerHelper\", \"currentData\", \"parentData\"];\n\n// A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\nSpacebarsCompiler.isReservedName = function (name) {\n  return builtInBlockHelpers.hasOwnProperty(name) ||\n    builtInTemplateMacros.hasOwnProperty(name) ||\n    _.indexOf(additionalReservedNames, name) > -1;\n};\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n  for (var k in obj)\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' +\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')\n          + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' +\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +\n            'function () { return ' + code + '; })';\n        }\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' &&\n            builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1)\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (! args.length)\n            throw new Error(\"#\" + path[0] + \" requires an argument\");\n\n          var dataCode = null;\n          // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&\n              args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" +\n                  \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n            if (! (args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            }\n            // split out the variable name and sequence arguments\n            var variableArg = args[0];\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&\n                   variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' +\n              self.codeGenInclusionData(args.slice(2)) +\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n              var argKey = arg[2];\n              dataProps[argKey] =\n                'function () { return Spacebars.call(' +\n                self.codeGenArgValue(arg) + '); }';\n            });\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (! dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          }\n\n          // `content` must exist\n          var contentBlock = (('content' in tag) ?\n                              self.codeGenBlock(tag.content) : null);\n          // `elseContent` may not exist\n          var elseContentBlock = (('elseContent' in tag) ?\n                                  self.codeGenBlock(tag.elseContent) : null);\n\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock)\n            callArgs.push(elseContentBlock);\n\n          return BlazeTools.EmitCode(\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n\n        } else {\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode +\n              '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = (('content' in tag) ?\n                         self.codeGenBlock(tag.content) : null);\n          var elseContent = (('elseContent' in tag) ?\n                             self.codeGenBlock(tag.elseContent) : null);\n\n          var includeArgs = [compCode];\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent)\n              includeArgs.push(elseContent);\n          }\n\n          var includeCode =\n                'Spacebars.include(' + includeArgs.join(', ') + ')';\n\n          // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n          if (dataCode) {\n            includeCode =\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +\n              includeCode + '; })';\n          }\n\n          // XXX BACK COMPAT - UI is the old name, Template is the new\n          if ((path[0] === 'UI' || path[0] === 'Template') &&\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '\n              + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\n    // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n    if (path.length >= 2 &&\n        (path[0] === 'UI' || path[0] === 'Template')\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2)\n        throw new Error(\"Unexpected dotted path beginning with \" +\n                        path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1)\n      lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' +\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n\n    var argType = arg[0];\n    var argValue = arg[1];\n\n    var argCode;\n    switch (argType) {\n    case 'STRING':\n    case 'NUMBER':\n    case 'BOOLEAN':\n    case 'NULL':\n      argCode = BlazeTools.toJSLiteral(argValue);\n      break;\n    case 'PATH':\n      argCode = self.codeGenPath(argValue);\n      break;\n    case 'EXPR':\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n      break;\n    default:\n      // can't get here\n      throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = (mustacheType || 'mustache');\n\n    return 'Spacebars.' + mustache + '(' + nameCode +\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n\n    var kwArgs = null; // source -> source\n    var args = null; // [source]\n\n    // tagArgs may be null\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = (kwArgs || {});\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = (args || []);\n        args.push(argCode);\n      }\n    });\n\n    // put kwArgs in options dictionary at end of args\n    if (kwArgs) {\n      args = (args || []);\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n\n  codeGenBlock: function (content) {\n    return SpacebarsCompiler.codeGen(content);\n  },\n\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (! args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1),\n                                  'dataMustache');\n    }\n\n  },\n\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n\n});\n","\nSpacebarsCompiler.parse = function (input) {\n\n  var tree = HTMLTools.parseFragment(\n    input,\n    { getTemplateTag: TemplateTag.parseCompleteTag });\n\n  return tree;\n};\n\nSpacebarsCompiler.compile = function (input, options) {\n  var tree = SpacebarsCompiler.parse(input);\n  return SpacebarsCompiler.codeGen(tree, options);\n};\n\nSpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();\nSpacebarsCompiler._TemplateTagReplacer.def({\n  visitObject: function (x) {\n    if (x instanceof HTMLTools.TemplateTag) {\n\n      // Make sure all TemplateTags in attributes have the right\n      // `.position` set on them.  This is a bit of a hack\n      // (we shouldn't be mutating that here), but it allows\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\n      // \"value\", where the template tags were originally not\n      // in an attribute.\n      if (this.inAttributeValue)\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\n\n      return this.codegen.codeGenTemplateTag(x);\n    }\n\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return this.codegen.codeGenTemplateTag(attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    this.inAttributeValue = true;\n    var result = this.visit(value);\n    this.inAttributeValue = false;\n\n    if (result !== value) {\n      // some template tags must have been replaced, because otherwise\n      // we try to keep things `===` when transforming.  Wrap the code\n      // in a function as per the rules.  You can't have\n      // `{id: Blaze.View(...)}` as an attributes dict because the View\n      // would be rendered more than once; you need to wrap it in a function\n      // so that it's a different View each time.\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\n    }\n    return result;\n  }\n});\n\nSpacebarsCompiler.codeGen = function (parseTree, options) {\n  // is this a template, rather than a block passed to\n  // a block helper, say\n  var isTemplate = (options && options.isTemplate);\n  var isBody = (options && options.isBody);\n  var sourceName = (options && options.sourceName);\n\n  var tree = parseTree;\n\n  // The flags `isTemplate` and `isBody` are kind of a hack.\n  if (isTemplate || isBody) {\n    // optimizing fragments would require being smarter about whether we are\n    // in a TEXTAREA, say.\n    tree = SpacebarsCompiler.optimize(tree);\n  }\n\n  // throws an error if using `{{> React}}` with siblings\n  new ReactComponentSiblingForbidder({sourceName: sourceName})\n    .visit(tree);\n\n  var codegen = new SpacebarsCompiler.CodeGen;\n  tree = (new SpacebarsCompiler._TemplateTagReplacer(\n    {codegen: codegen})).visit(tree);\n\n  var code = '(function () { ';\n  if (isTemplate || isBody) {\n    code += 'var view = this; ';\n  }\n  code += 'return ';\n  code += BlazeTools.toJS(tree);\n  code += '; })';\n\n  code = SpacebarsCompiler._beautify(code);\n\n  return code;\n};\n\nSpacebarsCompiler._beautify = function (code) {\n  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {\n    var result = Package.minifiers.UglifyJSMinify(\n      code,\n      { fromString: true,\n        mangle: false,\n        compress: false,\n        output: { beautify: true,\n                  indent_level: 2,\n                  width: 80 } });\n    var output = result.code;\n    // Uglify interprets our expression as a statement and may add a semicolon.\n    // Strip trailing semicolon.\n    output = output.replace(/;$/, '');\n    return output;\n  } else {\n    // don't actually beautify; no UglifyJS\n    return code;\n  }\n};\n"]}}]