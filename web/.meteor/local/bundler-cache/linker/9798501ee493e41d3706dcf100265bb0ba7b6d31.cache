[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar Retry;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////\n//                                                                         //\n// packages/retry/retry.js                                                 //\n//                                                                         //\n/////////////////////////////////////////////////////////////////////////////\n                                                                           //\n// Retry logic with an exponential backoff.                                // 1\n//                                                                         // 2\n// options:                                                                // 3\n//  baseTimeout: time for initial reconnect attempt (ms).                  // 4\n//  exponent: exponential factor to increase timeout each attempt.         // 5\n//  maxTimeout: maximum time between retries (ms).                         // 6\n//  minCount: how many times to reconnect \"instantly\".                     // 7\n//  minTimeout: time to wait for the first `minCount` retries (ms).        // 8\n//  fuzz: factor to randomize retry times by (to avoid retry storms).      // 9\n                                                                           // 10\nRetry = function (options) {                                               // 11\n  var self = this;                                                         // 12\n  _.extend(self, _.defaults(_.clone(options || {}), {                      // 13\n    baseTimeout: 1000, // 1 second                                         // 14\n    exponent: 2.2,                                                         // 15\n    // The default is high-ish to ensure a server can recover from a       // 16\n    // failure caused by load.                                             // 17\n    maxTimeout: 5 * 60000, // 5 minutes                                    // 18\n    minTimeout: 10,                                                        // 19\n    minCount: 2,                                                           // 20\n    fuzz: 0.5 // +- 25%                                                    // 21\n  }));                                                                     // 22\n  self.retryTimer = null;                                                  // 23\n};                                                                         // 24\n                                                                           // 25\n_.extend(Retry.prototype, {                                                // 26\n                                                                           // 27\n  // Reset a pending retry, if any.                                        // 28\n  clear: function () {                                                     // 29\n    var self = this;                                                       // 30\n    if (self.retryTimer)                                                   // 31\n      clearTimeout(self.retryTimer);                                       // 32\n    self.retryTimer = null;                                                // 33\n  },                                                                       // 34\n                                                                           // 35\n  // Calculate how long to wait in milliseconds to retry, based on the     // 36\n  // `count` of which retry this is.                                       // 37\n  _timeout: function (count) {                                             // 38\n    var self = this;                                                       // 39\n                                                                           // 40\n    if (count < self.minCount)                                             // 41\n      return self.minTimeout;                                              // 42\n                                                                           // 43\n    var timeout = Math.min(                                                // 44\n      self.maxTimeout,                                                     // 45\n      self.baseTimeout * Math.pow(self.exponent, count));                  // 46\n    // fuzz the timeout randomly, to avoid reconnect storms when a         // 47\n    // server goes down.                                                   // 48\n    timeout = timeout * ((Random.fraction() * self.fuzz) +                 // 49\n                         (1 - self.fuzz/2));                               // 50\n    return timeout;                                                        // 51\n  },                                                                       // 52\n                                                                           // 53\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {                                       // 55\n    var self = this;                                                       // 56\n    var timeout = self._timeout(count);                                    // 57\n    if (self.retryTimer)                                                   // 58\n      clearTimeout(self.retryTimer);                                       // 59\n    self.retryTimer = Meteor.setTimeout(fn, timeout);                      // 60\n    return timeout;                                                        // 61\n  }                                                                        // 62\n                                                                           // 63\n});                                                                        // 64\n                                                                           // 65\n/////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.retry = {\n  Retry: Retry\n};\n\n})();\n","servePath":"/packages/retry.js","sourceMap":{"version":3,"sources":["/packages/retry/retry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gF","file":"/packages/retry.js","sourcesContent":["// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\nRetry = function (options) {\n  var self = this;\n  _.extend(self, _.defaults(_.clone(options || {}), {\n    baseTimeout: 1000, // 1 second\n    exponent: 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout: 5 * 60000, // 5 minutes\n    minTimeout: 10,\n    minCount: 2,\n    fuzz: 0.5 // +- 25%\n  }));\n  self.retryTimer = null;\n};\n\n_.extend(Retry.prototype, {\n\n  // Reset a pending retry, if any.\n  clear: function () {\n    var self = this;\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = null;\n  },\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout: function (count) {\n    var self = this;\n\n    if (count < self.minCount)\n      return self.minTimeout;\n\n    var timeout = Math.min(\n      self.maxTimeout,\n      self.baseTimeout * Math.pow(self.exponent, count));\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\n                         (1 - self.fuzz/2));\n    return timeout;\n  },\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {\n    var self = this;\n    var timeout = self._timeout(count);\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = Meteor.setTimeout(fn, timeout);\n    return timeout;\n  }\n\n});\n"]}}]